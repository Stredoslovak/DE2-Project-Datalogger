{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s6\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info 
{\title {\comment SD_CardTesting  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
01 \par
}}SD_CardTesting}
{\comment Generated by doxygen 1.15.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt SD_CardTesting}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 01\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Topic Index\par \pard\plain 
{\tc \v Topic Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Topics\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all topics with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Timer Library <timer.h> }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BME280 }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialization }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Registers }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor Settings }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor Mode }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
System }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor Data }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor Delay }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GPIO Library <gpio.h> }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TWI Library <twi.h> }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
UART Library <uart.h> }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Directory Hierarchy\par \pard\plain 
{\tc \v Directory Hierarchy}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Directories\par \pard\plain 
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280 }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEC \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280_defs.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FAT32 }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABED \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FAT32.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FAT32.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gas_index_algorithm }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEE \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sensirion_gas_index_algorithm.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sensirion_gas_index_algorithm.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gpio }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEF \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gpio.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gpio.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAML \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
include }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEG \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
timer.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
lib }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280 }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEC \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280_defs.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FAT32 }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABED \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FAT32.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FAT32.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gas_index_algorithm }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEE \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sensirion_gas_index_algorithm.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sensirion_gas_index_algorithm.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gpio }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEF \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gpio.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gpio.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAML \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
rtc }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
rtc.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
rtc.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sd }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SD_routines.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAON \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sd_routines.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sgp41 }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEK \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SensirionI2CSgp41.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SensirionI2CSgp41.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SPI }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SPI_routines.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SPI_routines.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
twi }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEN \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
twi.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
twi.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
uart }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEO \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
uart.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
uart.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
uart_compat.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
rtc }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
rtc.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
rtc.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sd }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SD_routines.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAON \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sd_routines.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sgp41 }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEK \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SensirionI2CSgp41.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SensirionI2CSgp41.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SPI }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SPI_routines.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SPI_routines.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
src }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEM \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
main.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sgp41.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
twi }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEN \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
twi.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
twi.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
uart }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEO \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
uart.c }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
uart.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
uart_compat.h }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b bme280_calib_data} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration data })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b bme280_data} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bme280 sensor structure which comprises of temperature, pressure and humidity data })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b bme280_dev} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bme280 device structure })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b bme280_settings} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bme280 sensor settings structure which comprises of mode, oversampling and filter settings })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b bme280_uncomp_data} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bme280 sensor structure which comprises of uncompensated temperature, pressure and humidity data })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b BS_Structure} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b dir_Structure} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b FSInfo_Structure} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GasIndexAlgorithmParams} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MBRinfo_Structure} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b partitionInfo_Structure} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b include/{\b timer.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/bme280/{\b bme280.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor driver for BME280 sensor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/bme280/{\b bme280.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor driver for BME280 sensor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/bme280/{\b bme280_defs.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/FAT32/{\b FAT32.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/FAT32/{\b FAT32.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/gas_index_algorithm/{\b sensirion_gas_index_algorithm.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/gas_index_algorithm/{\b sensirion_gas_index_algorithm.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/gpio/{\b gpio.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/gpio/{\b gpio.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAML \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/rtc/{\b rtc.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/rtc/{\b rtc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/sd/{\b SD_routines.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAON \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/sd/{\b sd_routines.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/sgp41/{\b SensirionI2CSgp41.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/sgp41/{\b SensirionI2CSgp41.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/SPI/{\b SPI_routines.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/SPI/{\b SPI_routines.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/twi/{\b twi.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/twi/{\b twi.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/uart/{\b uart.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/uart/{\b uart.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/uart/{\b uart_compat.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b bme.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b main.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b sgp41.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Topic Documentation{\tc \v Topic Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Timer Library <timer.h> }\par \pard\plain 
{\tc\tcl2 \v Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>}
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Timer library for AVR-GCC. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Definitions for 16-bit Timer/Counter1\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
t_OVF = 1/F_CPU * prescaler * 2^n where n = 16, F_CPU = 16 MHz \par
}}}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_stop}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stop timer, prescaler 000 --> STOP. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_ovf_4ms}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 4ms, prescaler 001 --> 1. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_ovf_33ms}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 33ms, prescaler 010 --> 8. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_ovf_262ms}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 262ms, prescaler 011 --> 64. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_ovf_1sec}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 1s, prescaler 100 --> 256. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_ovf_4sec}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 4s, prescaler // 101 --> 1024. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_ovf_enable}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable overflow interrupt, 1 --> enable. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_ovf_disable}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable overflow interrupt, 0 --> disable. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Definitions for 8-bit Timer/Counter0\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
t_OVF = 1/F_CPU * prescaler * 2^n where n = 8, F_CPU = 16 MHz \par
}}}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_stop}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stop timer, prescaler 000 --> STOP. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_ovf_16us}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 16us, prescaler 001 --> 1. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_ovf_128us}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 128us, prescaler 010 --> 8. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_ovf_1024us}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 1024us, prescaler 011 --> 64. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_ovf_4096us}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 4096us, prescaler 100 --> 256. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_ovf_16384us}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 16384us, prescaler // 101 --> 1024. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_ovf_enable}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable overflow interrupt, 1 --> enable. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_ovf_disable}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable overflow interrupt, 0 --> disable. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Definitions for 8-bit Timer/Counter2\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
t_OVF = 1/F_CPU * prescaler * 2^n where n = 8, F_CPU = 16 MHz \par
}}}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_stop}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stop timer, prescaler 000 --> STOP. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_16us}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 16us, prescaler 001 --> 1. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_128us}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 128us, prescaler 010 --> 8. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_512us}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 512us, prescaler 011 --> 32. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_1024us}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 1024us, prescaler 100 --> 64. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_2048us}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 2048us, prescaler 101 --> 128. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_4096us}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 4096us, prescaler 110 --> 256. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_16ms}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 16384us, prescaler 111 --> 1024. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_enable}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable overflow interrupt, 1 --> enable. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_disable}()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable overflow interrupt, 0 --> disable. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Timer library for AVR-GCC. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf21 #include <timer.h>} \par
}
\par
The library contains macros for controlling the timer modules.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Based on Microchip Atmel ATmega328P manual and no source file is needed for the library. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Copyright\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(c) 2019-2025 Tomas Fryza, MIT license \par
}}}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v tim0_ovf_1024us\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim0_ovf_1024us}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim0_ovf_1024us()}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR0B &= ~(1<<CS02); TCCR0B |= (1<<CS01) | (1<<CS00);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 1024us, prescaler 011 --> 64. }}\par
{
Definition at line {\b 77} of file {\b timer.h}.}\par
}
{\xe \v tim0_ovf_128us\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim0_ovf_128us}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim0_ovf_128us()}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR0B &= ~((1<<CS02) | (1<<CS00)); TCCR0B |= (1<<CS01);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 128us, prescaler 010 --> 8. }}\par
{
Definition at line {\b 74} of file {\b timer.h}.}\par
}
{\xe \v tim0_ovf_16384us\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim0_ovf_16384us}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim0_ovf_16384us()}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR0B &= ~(1<<CS01); TCCR0B |= (1<<CS02) | (1<<CS00);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 16384us, prescaler // 101 --> 1024. }}\par
{
Definition at line {\b 83} of file {\b timer.h}.}\par
}
{\xe \v tim0_ovf_16us\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim0_ovf_16us}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim0_ovf_16us()}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR1B &= ~((1<<CS02) | (1<<CS01)); TCCR0B |= (1<<CS00);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 16us, prescaler 001 --> 1. }}\par
{
Definition at line {\b 71} of file {\b timer.h}.}\par
}
{\xe \v tim0_ovf_4096us\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim0_ovf_4096us}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim0_ovf_4096us()}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR0B &= ~((1<<CS01) | (1<<CS00)); TCCR0B |= (1<<CS02);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 4096us, prescaler 100 --> 256. }}\par
{
Definition at line {\b 80} of file {\b timer.h}.}\par
}
{\xe \v tim0_ovf_disable\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim0_ovf_disable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim0_ovf_disable()}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TIMSK0 &= ~(1<<TOIE0);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable overflow interrupt, 0 --> disable. }}\par
{
Definition at line {\b 89} of file {\b timer.h}.}\par
}
{\xe \v tim0_ovf_enable\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim0_ovf_enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim0_ovf_enable()}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TIMSK0 |= (1<<TOIE0);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable overflow interrupt, 1 --> enable. }}\par
{
Definition at line {\b 86} of file {\b timer.h}.}\par
}
{\xe \v tim0_stop\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim0_stop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim0_stop()}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR0B &= ~((1<<CS02) | (1<<CS01) | (1<<CS00));\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stop timer, prescaler 000 --> STOP. }}\par
{
Definition at line {\b 68} of file {\b timer.h}.}\par
}
{\xe \v tim1_ovf_1sec\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim1_ovf_1sec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim1_ovf_1sec()}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR1B &= ~((1<<CS11) | (1<<CS10)); TCCR1B |= (1<<CS12);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 1s, prescaler 100 --> 256. }}\par
{
Definition at line {\b 50} of file {\b timer.h}.}\par
}
{\xe \v tim1_ovf_262ms\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim1_ovf_262ms}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim1_ovf_262ms()}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR1B &= ~(1<<CS12); TCCR1B |= (1<<CS11) | (1<<CS10);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 262ms, prescaler 011 --> 64. }}\par
{
Definition at line {\b 47} of file {\b timer.h}.}\par
}
{\xe \v tim1_ovf_33ms\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim1_ovf_33ms}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim1_ovf_33ms()}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR1B &= ~((1<<CS12) | (1<<CS10)); TCCR1B |= (1<<CS11);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 33ms, prescaler 010 --> 8. }}\par
{
Definition at line {\b 44} of file {\b timer.h}.}\par
}
{\xe \v tim1_ovf_4ms\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim1_ovf_4ms}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim1_ovf_4ms()}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR1B &= ~((1<<CS12) | (1<<CS11)); TCCR1B |= (1<<CS10);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 4ms, prescaler 001 --> 1. }}\par
{
Definition at line {\b 41} of file {\b timer.h}.}\par
}
{\xe \v tim1_ovf_4sec\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim1_ovf_4sec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim1_ovf_4sec()}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR1B &= ~(1<<CS11); TCCR1B |= (1<<CS12) | (1<<CS10);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 4s, prescaler // 101 --> 1024. }}\par
{
Definition at line {\b 53} of file {\b timer.h}.}\par
}
{\xe \v tim1_ovf_disable\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim1_ovf_disable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim1_ovf_disable()}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TIMSK1 &= ~(1<<TOIE1);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable overflow interrupt, 0 --> disable. }}\par
{
Definition at line {\b 59} of file {\b timer.h}.}\par
}
{\xe \v tim1_ovf_enable\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim1_ovf_enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim1_ovf_enable()}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TIMSK1 |= (1<<TOIE1);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable overflow interrupt, 1 --> enable. }}\par
{
Definition at line {\b 56} of file {\b timer.h}.}\par
}
{\xe \v tim1_stop\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim1_stop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim1_stop()}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR1B &= ~((1<<CS12) | (1<<CS11) | (1<<CS10));\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stop timer, prescaler 000 --> STOP. }}\par
{
Definition at line {\b 38} of file {\b timer.h}.}\par
}
{\xe \v tim2_ovf_1024us\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim2_ovf_1024us}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim2_ovf_1024us()}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR2B &= ~((1<<CS21) | (1<<CS20)); TCCR2B |= (1<<CS22);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 1024us, prescaler 100 --> 64. }}\par
{
Definition at line {\b 109} of file {\b timer.h}.}\par
}
{\xe \v tim2_ovf_128us\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim2_ovf_128us}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim2_ovf_128us()}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR2B &= ~((1<<CS22) | (1<<CS20)); TCCR2B |= (1<<CS21);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 128us, prescaler 010 --> 8. }}\par
{
Definition at line {\b 103} of file {\b timer.h}.}\par
}
{\xe \v tim2_ovf_16ms\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim2_ovf_16ms}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim2_ovf_16ms()}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR2B |= (1<<CS22) | (1<<CS21) | (1<<CS20);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 16384us, prescaler 111 --> 1024. }}\par
{
Definition at line {\b 118} of file {\b timer.h}.}\par
}
{\xe \v tim2_ovf_16us\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim2_ovf_16us}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim2_ovf_16us()}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR2B &= ~((1<<CS22) | (1<<CS21)); TCCR2B |= (1<<CS20);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 16us, prescaler 001 --> 1. }}\par
{
Definition at line {\b 100} of file {\b timer.h}.}\par
}
{\xe \v tim2_ovf_2048us\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim2_ovf_2048us}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim2_ovf_2048us()}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR2B &= ~(1<<CS21); TCCR2B |= (1<<CS22) | (1<<CS20);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 2048us, prescaler 101 --> 128. }}\par
{
Definition at line {\b 112} of file {\b timer.h}.}\par
}
{\xe \v tim2_ovf_4096us\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim2_ovf_4096us}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim2_ovf_4096us()}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR2B &= ~(1<<CS20); TCCR2B |= (1<<CS22) | (1<<CS21);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 4096us, prescaler 110 --> 256. }}\par
{
Definition at line {\b 115} of file {\b timer.h}.}\par
}
{\xe \v tim2_ovf_512us\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim2_ovf_512us}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim2_ovf_512us()}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR2B &= ~(1<<CS22); TCCR2B |= (1<<CS21) | (1<<CS20);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 512us, prescaler 011 --> 32. }}\par
{
Definition at line {\b 106} of file {\b timer.h}.}\par
}
{\xe \v tim2_ovf_disable\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim2_ovf_disable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim2_ovf_disable()}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TIMSK2 &= ~(1<<TOIE2);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable overflow interrupt, 0 --> disable. }}\par
{
Definition at line {\b 124} of file {\b timer.h}.}\par
}
{\xe \v tim2_ovf_enable\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim2_ovf_enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim2_ovf_enable()}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TIMSK2 |= (1<<TOIE2);\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable overflow interrupt, 1 --> enable. }}\par
{
Definition at line {\b 121} of file {\b timer.h}.}\par
}
{\xe \v tim2_stop\:Timer Library <timer.h>}
{\xe \v Timer Library <timer.h>\:tim2_stop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tim2_stop()}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TCCR2B &= ~((1<<CS22) | (1<<CS21) | (1<<CS20));\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stop timer, prescaler 000 --> STOP. }}\par
{
Definition at line {\b 97} of file {\b timer.h}.}\par
}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BME280 }\par \pard\plain 
{\tc\tcl2 \v BME280}
{\xe \v BME280}
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 Product Overview} and {\f2 Sensor API Source Code} }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Topics\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialization }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVC \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the sensor and device structure. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Registers }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVD \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic API for accessing sensor registers. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor Settings }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVE \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic API for accessing sensor settings. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor Mode }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVF \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic API for configuring sensor power mode. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
System }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVG \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
API that performs system-level operations. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor Data }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data processing of sensor. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor Delay }\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic API for measuring sensor delay. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 Product Overview} and {\f2 Sensor API Source Code} \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}\par \pard\plain 
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialization }\par \pard\plain 
{\tc\tcl3 \v Initialization}
{\xe \v Initialization}
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the sensor and device structure. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the sensor and device structure. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CPP guard \par
}{\pard\plain \s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid {\tc\tcl5 \v bme280_init}
bme280_init\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int8_t bme280_init({\cf17 struct} bme280_dev *dev);\par
}
\par
This API reads the chip-id of the sensor which is the first step to verify the sensor and also calibrates the sensor As this API is the entry point, call this API before using other APIs.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i dev} \cell }{: Structure instance of {\b bme280_dev}\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Result of API execution status.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{-> Success. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i >} \cell }{0 -> Warning. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <} \cell }{0 -> Fail. \cell }
{\row }
}
}}
\par \pard\plain 
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Registers }\par \pard\plain 
{\tc\tcl3 \v Registers}
{\xe \v Registers}
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic API for accessing sensor registers. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic API for accessing sensor registers. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\pard\plain \s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid {\tc\tcl5 \v bme280_set_regs}
bme280_set_regs\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int8_t bme280_set_regs({\cf17 const} uint8_t reg_addr, {\cf17 const} uint8_t *reg_data, uint32_t len, {\cf17 struct} bme280_dev *dev);\par
}
\par
This API writes the given data to the register address of the sensor\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i reg_addr} \cell }{: Register addresses to where the data is to be written \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i reg_data} \cell }{: Pointer to data buffer which is to be written in the reg_addr of sensor. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i len} \cell }{: No of bytes of data to write \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i dev} \cell }{: Structure instance of {\b bme280_dev}\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Result of API execution status.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{-> Success. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i >} \cell }{0 -> Warning. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <} \cell }{0 -> Fail. \cell }
{\row }
}
}}
{\pard\plain \s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid {\tc\tcl5 \v bme280_get_regs}
bme280_get_regs\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int8_t bme280_get_regs(uint8_t reg_addr, uint8_t *reg_data, uint32_t len, {\cf17 struct} bme280_dev *dev);\par
}
\par
This API reads the data from the given register address of sensor.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i reg_addr} \cell }{: Register address from where the data to be read \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i reg_data} \cell }{: Pointer to data buffer to store the read data. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i len} \cell }{: No of bytes of data to be read. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i dev} \cell }{: Structure instance of {\b bme280_dev}.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Result of API execution status.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{-> Success. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i >} \cell }{0 -> Warning. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <} \cell }{0 -> Fail. \cell }
{\row }
}
}}
\par \pard\plain 
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor Settings }\par \pard\plain 
{\tc\tcl3 \v Sensor Settings}
{\xe \v Sensor Settings}
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic API for accessing sensor settings. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic API for accessing sensor settings. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\pard\plain \s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid {\tc\tcl5 \v bme280_set_sensor_settings}
bme280_set_sensor_settings\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int8_t bme280_set_sensor_settings(uint8_t desired_settings, {\cf17 const} {\cf17 struct} bme280_settings *settings, {\cf17 struct} bme280_dev *dev);\par
}
\par
This API sets the oversampling, filter and standby duration (normal mode) settings in the sensor.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i desired_settings} \cell }{: Variable used to select the settings which are to be set in the sensor. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i settings} \cell }{: Structure instance of {\b bme280_settings}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i dev} \cell }{: Structure instance of {\b bme280_dev}.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: Below are the macros to be used by the user for selecting the desired settings. User can do OR operation of these macros for configuring multiple settings.\par
}}{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid * Macros                 |   Functionality\par
* -----------------------|----------------------------------------------\par
* BME280_SEL_OSR_PRESS   |   To set pressure oversampling.\par
* BME280_SEL_OSR_TEMP    |   To set temperature oversampling.\par
* BME280_SEL_OSR_HUM     |   To set humidity oversampling.\par
* BME280_SEL_FILTER      |   To set filter setting.\par
* BME280_SEL_STANDBY     |   To set standby duration setting.\par
*}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Result of API execution status\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{-> Success. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i >} \cell }{0 -> Warning. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <} \cell }{0 -> Fail. \cell }
{\row }
}
}}
{\pard\plain \s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid {\tc\tcl5 \v bme280_get_sensor_settings}
bme280_get_sensor_settings\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int8_t bme280_get_sensor_settings({\cf17 struct} bme280_settings *settings, {\cf17 struct} bme280_dev *dev);\par
}
\par
This API gets the oversampling, filter and standby duration (normal mode) settings from the sensor.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i settings} \cell }{: Structure instance of {\b bme280_settings}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i dev} \cell }{: Structure instance of {\b bme280_dev}.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Result of API execution status\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{-> Success. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i >} \cell }{0 -> Warning. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <} \cell }{0 -> Fail. \cell }
{\row }
}
}}
\par \pard\plain 
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor Mode }\par \pard\plain 
{\tc\tcl3 \v Sensor Mode}
{\xe \v Sensor Mode}
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic API for configuring sensor power mode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic API for configuring sensor power mode. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\pard\plain \s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid {\tc\tcl5 \v bme280_set_sensor_mode}
bme280_set_sensor_mode\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int8_t bme280_set_sensor_mode(uint8_t sensor_mode, {\cf17 const} {\cf17 struct} bme280_dev *dev);\par
}
\par
This API sets the power mode of the sensor.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i sensor_mode} \cell }{: Variable which contains the power mode to be set. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i dev} \cell }{: Structure instance of {\b bme280_dev}.\cell }
{\row }
}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid *    sensor_mode       |      Macros\par
* ---------------------|-------------------------\par
*     0                | BME280_POWERMODE_SLEEP\par
*     1                | BME280_POWERMODE_FORCED\par
*     3                | BME280_POWERMODE_NORMAL\par
*}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Result of API execution status\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{-> Success. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i >} \cell }{0 -> Warning. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <} \cell }{0 -> Fail. \cell }
{\row }
}
}}
{\pard\plain \s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid {\tc\tcl5 \v bme280_get_sensor_mode}
bme280_get_sensor_mode\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int8_t bme280_get_sensor_mode(uint8_t *sensor_mode, {\cf17 struct} bme280_dev *dev);\par
}
\par
This API gets the power mode of the sensor.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i sensor_mode} \cell }{: Pointer variable to store the power mode. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i dev} \cell }{: Structure instance of {\b bme280_dev}.\cell }
{\row }
}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid *    sensor_mode       |      Macros\par
* ---------------------|-------------------------\par
*     0                | BME280_POWERMODE_SLEEP\par
*     1                | BME280_POWERMODE_FORCED\par
*     3                | BME280_POWERMODE_NORMAL\par
*}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Result of API execution status\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{-> Success. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i >} \cell }{0 -> Warning. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <} \cell }{0 -> Fail. \cell }
{\row }
}
}}
\par \pard\plain 
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
System }\par \pard\plain 
{\tc\tcl3 \v System}
{\xe \v System}
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
API that performs system-level operations. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
API that performs system-level operations. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\pard\plain \s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid {\tc\tcl5 \v bme280_soft_reset}
bme280_soft_reset\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int8_t bme280_soft_reset({\cf17 struct} bme280_dev *dev);\par
}
\par
This API soft-resets the sensor.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i dev} \cell }{: Structure instance of {\b bme280_dev}.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Result of API execution status.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{-> Success. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i >} \cell }{0 -> Warning. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <} \cell }{0 -> Fail. \cell }
{\row }
}
}}
\par \pard\plain 
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor Data }\par \pard\plain 
{\tc\tcl3 \v Sensor Data}
{\xe \v Sensor Data}
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data processing of sensor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data processing of sensor. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\pard\plain \s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid {\tc\tcl5 \v bme280_get_sensor_data}
bme280_get_sensor_data\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int8_t bme280_get_sensor_data(uint8_t sensor_comp, {\cf17 struct} bme280_data *comp_data, {\cf17 struct} bme280_dev *dev);\par
}
\par
This API reads the pressure, temperature and humidity data from the sensor, compensates the data and store it in the {\b bme280_data} structure instance passed by the user.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i sensor_comp} \cell }{: Variable which selects which data to be read from the sensor.\cell }
{\row }
}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid * sensor_comp |   Macros\par
* ------------|-------------------\par
*     1       | BME280_PRESS\par
*     2       | BME280_TEMP\par
*     4       | BME280_HUM\par
*     7       | BME280_ALL\par
*}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i comp_data} \cell }{: Structure instance of {\b bme280_data}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i dev} \cell }{: Structure instance of {\b bme280_dev}.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Result of API execution status\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{-> Success. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i >} \cell }{0 -> Warning. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <} \cell }{0 -> Fail. \cell }
{\row }
}
}}
{\pard\plain \s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid {\tc\tcl5 \v bme280_compensate_data}
bme280_compensate_data\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int8_t bme280_compensate_data(uint8_t sensor_comp,\par
                            {\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
                            {\cf17 struct} bme280_data *comp_data,\par
                            {\cf17 struct} bme280_calib_data *calib_data);\par
}
\par
This API is used to compensate the pressure and/or temperature and/or humidity data according to the component selected by the user.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i sensor_comp} \cell }{: Used to select pressure and/or temperature and/or humidity. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i uncomp_data} \cell }{: Contains the uncompensated pressure, temperature and humidity data. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i comp_data} \cell }{: Contains the compensated pressure and/or temperature and/or humidity data. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i calib_data} \cell }{: Pointer to {\b bme280_calib_data}\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Result of API execution status.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{-> Success. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i >} \cell }{0 -> Warning. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <} \cell }{0 -> Fail. \cell }
{\row }
}
}}
\par \pard\plain 
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor Delay }\par \pard\plain 
{\tc\tcl3 \v Sensor Delay}
{\xe \v Sensor Delay}
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic API for measuring sensor delay. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic API for measuring sensor delay. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\pard\plain \s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid {\tc\tcl5 \v bme280_cal_meas_delay}
bme280_cal_meas_delay\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid uint32_t bme280_cal_meas_delay(uint32_t *max_delay, {\cf17 const} {\cf17 struct} bme280_settings *settings);\par
}
\par
This API is used to calculate the maximum delay in microseconds required for the temperature/pressure/humidity(whichever are enabled) measurement to complete. The delay depends upon the number of sensors enabled and their oversampling configuration.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i max_delay} \cell }{: Delay required in microseconds. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i settings} \cell }{: Contains the oversampling configurations.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Result of API execution status.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{-> Success. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i >} \cell }{0 -> Warning. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i <} \cell }{0 -> Fail. \cell }
{\row }
}
}}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GPIO Library <gpio.h> }\par \pard\plain 
{\tc\tcl2 \v GPIO Library <gpio.h>}
{\xe \v GPIO Library <gpio.h>}
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GPIO library for AVR-GCC. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_mode_output} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Configure one output pin. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_mode_input_pullup} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Configure one input pin and enable pull-up. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_write_low} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write one pin to low value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_write_high} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write one pin to high value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b gpio_read} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a value from input pin. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_mode_input_nopull} (volatile uint8_t *reg, uint8_t pin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_toggle} (volatile uint8_t *reg, uint8_t pin)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GPIO library for AVR-GCC. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf21 #include <gpio.h>} \par
}
\par
The library contains functions for controlling AVRs' gpio pin(s).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Based on AVR Libc Reference Manual. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Copyright\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(c) 2019-2024 Tomas Fryza, MIT license \par
}}}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v gpio_mode_input_nopull\:GPIO Library <gpio.h>}
{\xe \v GPIO Library <gpio.h>\:gpio_mode_input_nopull}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gpio_mode_input_nopull (volatile uint8_t * reg, uint8_t pin)}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b gpio.c}.}\par
}
{\xe \v gpio_mode_input_pullup\:GPIO Library <gpio.h>}
{\xe \v GPIO Library <gpio.h>\:gpio_mode_input_pullup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gpio_mode_input_pullup (volatile uint8_t * reg, uint8_t pin)}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Configure one input pin and enable pull-up. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i reg} \cell }{Address of Data Direction Register, such as &DDRB \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pin} \cell }{Pin designation in the interval 0 to 7 \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
none \par
}}}{
Definition at line {\b 34} of file {\b gpio.c}.}\par
}
{\xe \v gpio_mode_output\:GPIO Library <gpio.h>}
{\xe \v GPIO Library <gpio.h>\:gpio_mode_output}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gpio_mode_output (volatile uint8_t * reg, uint8_t pin)}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Configure one output pin. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i reg} \cell }{Address of Data Direction Register, such as &DDRB \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pin} \cell }{Pin designation in the interval 0 to 7 \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
none \par
}}}{
Definition at line {\b 21} of file {\b gpio.c}.}\par
}
{\xe \v gpio_read\:GPIO Library <gpio.h>}
{\xe \v GPIO Library <gpio.h>\:gpio_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t gpio_read (volatile uint8_t * reg, uint8_t pin)}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a value from input pin. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i reg} \cell }{Address of Pin Register, such as &PIND \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pin} \cell }{Pin designation in the interval 0 to 7 \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pin value \par
}}}{
Definition at line {\b 75} of file {\b gpio.c}.}\par
}
{\xe \v gpio_toggle\:GPIO Library <gpio.h>}
{\xe \v GPIO Library <gpio.h>\:gpio_toggle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gpio_toggle (volatile uint8_t * reg, uint8_t pin)}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b gpio.c}.}\par
}
{\xe \v gpio_write_high\:GPIO Library <gpio.h>}
{\xe \v GPIO Library <gpio.h>\:gpio_write_high}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gpio_write_high (volatile uint8_t * reg, uint8_t pin)}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write one pin to high value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i reg} \cell }{Address of Port Register, such as &PORTB \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pin} \cell }{Pin designation in the interval 0 to 7 \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
none \par
}}}{
Definition at line {\b 62} of file {\b gpio.c}.}\par
}
{\xe \v gpio_write_low\:GPIO Library <gpio.h>}
{\xe \v GPIO Library <gpio.h>\:gpio_write_low}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gpio_write_low (volatile uint8_t * reg, uint8_t pin)}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write one pin to low value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i reg} \cell }{Address of Port Register, such as &PORTB \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pin} \cell }{Pin designation in the interval 0 to 7 \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
none \par
}}}{
Definition at line {\b 49} of file {\b gpio.c}.}\par
}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TWI Library <twi.h> }\par \pard\plain 
{\tc\tcl2 \v TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>}
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
I2C/TWI library for AVR-GCC. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_writeto_mem_16b} (uint8_t addr, uint8_t memaddr, uint8_t dataUpperHalf, uint8_t dataLowerHalf)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write 16bit into peripheral. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Other definitions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b twi_init} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize TWI unit, enable internal pull-ups, and set SCL frequency. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b twi_start} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start communication on I2C/TWI bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_write} (uint8_t {\b data})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write one byte to the I2C/TWI bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_read} (uint8_t ack)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read one byte from the I2C/TWI bus and acknowledge it by ACK or NACK. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b twi_stop} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generates Stop condition on I2C/TWI bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_test_address} (uint8_t addr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test presence of one I2C device on the bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b twi_readfrom_mem_into} (uint8_t addr, uint8_t memaddr, volatile uint8_t *buf, uint8_t nbytes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read into buf from the peripheral, starting from the memory address. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_writeto_mem} (uint8_t addr, uint8_t memaddr, uint8_t {\b data})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write into peripheral. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_WRITE}\~ 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mode for writing to I2C/TWI device. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_READ}\~ 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mode for reading from I2C/TWI device. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_ACK}\~ 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ACK value for writing to I2C/TWI bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_NACK}\~ 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NACK value for writing to I2C/TWI bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DDR}(_x)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Address of Data Direction Register of port _x. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIN}(_x)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Address of input register of port _x. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Definition of frequencies\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b F_CPU}\~ 16000000\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CPU frequency in Hz required TWI_BIT_RATE_REG. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b F_SCL}\~ 100000\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
I2C/TWI bit rate. Must be greater than 31000. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_BIT_RATE_REG}\~ (({\b F_CPU}/{\b F_SCL} - 16) / 2)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TWI bit rate register value. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Definition of ports and pins\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_PORT}\~ PORTC\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Port of TWI unit. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_SDA_PIN}\~ 4\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SDA pin of TWI unit. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_SCL_PIN}\~ 5\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCL pin of TWI unit. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
I2C/TWI library for AVR-GCC. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf21 #include <twi.h>} \par
}
\par
This library defines functions for the TWI (I2C) communication between AVR and Slave device(s). Functions use internal TWI module of AVR.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Only Master transmitting and Master receiving modes are implemented. Based on Microchip Atmel ATmega16 and ATmega328P manuals. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Copyright\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(c) 2018-2025 Tomas Fryza, MIT license \par
}}}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DDR\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:DDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DDR( _x)}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (*(&_x - 1))\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Address of Data Direction Register of port _x. }}\par
{
Definition at line {\b 57} of file {\b twi.h}.}\par
}
{\xe \v F_CPU\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:F_CPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define F_CPU\~ 16000000}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CPU frequency in Hz required TWI_BIT_RATE_REG. }}\par
{
Definition at line {\b 36} of file {\b twi.h}.}\par
}
{\xe \v F_SCL\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:F_SCL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define F_SCL\~ 100000}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
I2C/TWI bit rate. Must be greater than 31000. }}\par
{
Definition at line {\b 38} of file {\b twi.h}.}\par
}
{\xe \v PIN\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:PIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIN( _x)}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (*(&_x - 2))\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Address of input register of port _x. }}\par
{
Definition at line {\b 58} of file {\b twi.h}.}\par
}
{\xe \v TWI_ACK\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:TWI_ACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TWI_ACK\~ 0}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ACK value for writing to I2C/TWI bus. }}\par
{
Definition at line {\b 55} of file {\b twi.h}.}\par
}
{\xe \v TWI_BIT_RATE_REG\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:TWI_BIT_RATE_REG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TWI_BIT_RATE_REG\~ (({\b F_CPU}/{\b F_SCL} - 16) / 2)}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TWI bit rate register value. }}\par
{
Definition at line {\b 39} of file {\b twi.h}.}\par
}
{\xe \v TWI_NACK\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:TWI_NACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TWI_NACK\~ 1}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NACK value for writing to I2C/TWI bus. }}\par
{
Definition at line {\b 56} of file {\b twi.h}.}\par
}
{\xe \v TWI_PORT\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:TWI_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TWI_PORT\~ PORTC}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Port of TWI unit. }}\par
{
Definition at line {\b 45} of file {\b twi.h}.}\par
}
{\xe \v TWI_READ\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:TWI_READ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TWI_READ\~ 1}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mode for reading from I2C/TWI device. }}\par
{
Definition at line {\b 54} of file {\b twi.h}.}\par
}
{\xe \v TWI_SCL_PIN\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:TWI_SCL_PIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TWI_SCL_PIN\~ 5}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCL pin of TWI unit. }}\par
{
Definition at line {\b 47} of file {\b twi.h}.}\par
}
{\xe \v TWI_SDA_PIN\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:TWI_SDA_PIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TWI_SDA_PIN\~ 4}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SDA pin of TWI unit. }}\par
{
Definition at line {\b 46} of file {\b twi.h}.}\par
}
{\xe \v TWI_WRITE\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:TWI_WRITE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TWI_WRITE\~ 0}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mode for writing to I2C/TWI device. }}\par
{
Definition at line {\b 53} of file {\b twi.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v twi_init\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:twi_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void twi_init (void )}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize TWI unit, enable internal pull-ups, and set SCL frequency. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Implementation notes:\par
}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9642\tab}\ilvl2\ls1 \li0\ri0\lin0\rin0\fi-360\tx1080\li1080\ri0\lin1080\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
AVR internal pull-up resistors at pins TWI_SDA_PIN and TWI_SCL_PIN are enabled\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9642\tab}\ilvl2\ls1 \li0\ri0\lin0\rin0\fi-360\tx1080\li1080\ri0\lin1080\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
TWI bit rate register value is calculated as follows fscl = fcpu/(16 + 2*TWBR) \par}
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
none \par
}}}{
Definition at line {\b 20} of file {\b twi.c}.}\par
}
{\xe \v twi_read\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:twi_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t twi_read (uint8_t ack)}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read one byte from the I2C/TWI bus and acknowledge it by ACK or NACK. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ack} \cell }{- ACK/NACK value to be transmitted \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Received data byte \par
}}}{
Definition at line {\b 82} of file {\b twi.c}.}\par
}
{\xe \v twi_readfrom_mem_into\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:twi_readfrom_mem_into}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void twi_readfrom_mem_into (uint8_t addr, uint8_t memaddr, volatile uint8_t * buf, uint8_t nbytes)}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read into buf from the peripheral, starting from the memory address. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i addr} \cell }{Slave address \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i memaddr} \cell }{Starting address \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Buffer to be read into \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nbytes} \cell }{Number of bytes \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
none \par
}}}{
Definition at line {\b 132} of file {\b twi.c}.}\par
}
{\xe \v twi_start\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:twi_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void twi_start (void )}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start communication on I2C/TWI bus. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
none \par
}}}{
Definition at line {\b 37} of file {\b twi.c}.}\par
}
{\xe \v twi_stop\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:twi_stop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void twi_stop (void )}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generates Stop condition on I2C/TWI bus. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
none \par
}}}{
Definition at line {\b 99} of file {\b twi.c}.}\par
}
{\xe \v twi_test_address\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:twi_test_address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t twi_test_address (uint8_t addr)}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test presence of one I2C device on the bus. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i addr} \cell }{Slave address \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
ACK/NACK received value \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{- ACK has been received \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 1} \cell }{- NACK has been received \cell }
{\row }
}
}{
Definition at line {\b 111} of file {\b twi.c}.}\par
}
{\xe \v twi_write\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:twi_write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t twi_write (uint8_t data)}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write one byte to the I2C/TWI bus. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{Byte to be transmitted \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
ACK/NACK received value \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{- ACK has been received \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 1} \cell }{- NACK has been received \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Function returns 0 if 0x18, 0x28, or 0x40 status code is detected\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9642\tab}\ilvl2\ls1 \li0\ri0\lin0\rin0\fi-360\tx1080\li1080\ri0\lin1080\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
0x18: SLA+W has been transmitted and ACK has been received\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9642\tab}\ilvl2\ls1 \li0\ri0\lin0\rin0\fi-360\tx1080\li1080\ri0\lin1080\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
0x28: Data byte has been transmitted and ACK has been received\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9642\tab}\ilvl2\ls1 \li0\ri0\lin0\rin0\fi-360\tx1080\li1080\ri0\lin1080\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
0x40: SLA+R has been transmitted and ACK has been received\par
}
}}}{
Definition at line {\b 51} of file {\b twi.c}.}\par
}
{\xe \v twi_writeto_mem\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:twi_writeto_mem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t twi_writeto_mem (uint8_t addr, uint8_t memaddr, uint8_t data)}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write into peripheral. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i addr} \cell }{Slave address \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i memaddr} \cell }{Memory address \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{Data to be written \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
none \par
}}}{
Definition at line {\b 160} of file {\b twi.c}.}\par
}
{\xe \v twi_writeto_mem_16b\:TWI Library <twi.h>}
{\xe \v TWI Library <twi.h>\:twi_writeto_mem_16b}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t twi_writeto_mem_16b (uint8_t addr, uint8_t memaddr, uint8_t dataUpperHalf, uint8_t dataLowerHalf)}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write 16bit into peripheral. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i addr} \cell }{Slave address \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i memaddr} \cell }{Memory address \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dataUpperHalf} \cell }{Data to be written \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dataLowerHalf} \cell }{Data to be written \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
none \par
}}}{
Definition at line {\b 181} of file {\b twi.c}.}\par
}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
UART Library <uart.h> }\par \pard\plain 
{\tc\tcl2 \v UART Library <uart.h>}
{\xe \v UART Library <uart.h>}
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interrupt UART library using the built-in UART with transmit and receive circular buffers. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_BAUD_SELECT}(baudRate,  xtalCpu)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
UART Baudrate Expression. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_BAUD_SELECT_DOUBLE_SPEED}(baudRate,  xtalCpu)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
UART Baudrate Expression for ATmega double speed mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_RX_BUFFER_SIZE}\~ 128\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of the circular receive buffer, must be power of 2. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_TX_BUFFER_SIZE}\~ 128\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of the circular transmit buffer, must be power of 2. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_FRAME_ERROR}\~ 0x1000\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Framing Error by UART. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_OVERRUN_ERROR}\~ 0x0800\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overrun condition by UART. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_PARITY_ERROR}\~ 0x0400\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parity Error by UART. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_BUFFER_OVERFLOW}\~ 0x0200\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
receive ringbuffer overflow }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_NO_DATA}\~ 0x0100\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
no receive data available }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b uart_puts_P}(__s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macro to automatically put a string constant into program memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b uart1_puts_P}(__s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macro to automatically put a string constant into program memory. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart_init} (unsigned int baudrate)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize UART and set baudrate. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b uart_getc} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get received byte from ringbuffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart_putc} (unsigned char {\b data})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put byte to ringbuffer for transmitting via UART. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart_puts} (const char *s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put string to ringbuffer for transmitting via UART. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart_puts_p} (const char *s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put string from program memory to ringbuffer for transmitting via UART. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart1_init} (unsigned int baudrate)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize USART1 (only available on selected ATmegas). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b uart1_getc} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get received byte of USART1 from ringbuffer. (only available on selected ATmega). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart1_putc} (unsigned char {\b data})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put byte to ringbuffer for transmitting via USART1 (only available on selected ATmega). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart1_puts} (const char *s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put string to ringbuffer for transmitting via USART1 (only available on selected ATmega). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart1_puts_p} (const char *s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put string from program memory to ringbuffer for transmitting via USART1 (only available on selected ATmega). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interrupt UART library using the built-in UART with transmit and receive circular buffers. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf21 #include <uart.h>} \par
}
\par
This library can be used to transmit and receive data through the built in UART.\par
An interrupt is generated when the UART has finished transmitting or receiving a byte. The interrupt handling routines use circular buffers for buffering received and transmitted data.\par
The UART_RX_BUFFER_SIZE and UART_TX_BUFFER_SIZE constants define the size of the circular buffers in bytes. Note that these constants must be a power of 2. You may need to adapt these constants to your target and your application by adding CDEFS += -DUART_RX_BUFFER_SIZE=nn -DUART_TX_BUFFER_SIZE=nn to your Makefile.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Based on Atmel Application Note AVR306 \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Peter Fleury {\f2 pfleury@gmx.ch} {\f2 http://tinyurl.com/peterfleury} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Copyright\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(C) 2015 Peter Fleury, GNU General Public License Version 3 \par
}}}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v uart1_puts_P\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:uart1_puts_P}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define uart1_puts_P( __s)}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid uart1_puts_p(PSTR(__s))\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macro to automatically put a string constant into program memory. }}\par
{
Definition at line {\b 201} of file {\b uart.h}.}\par
}
{\xe \v UART_BAUD_SELECT\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:UART_BAUD_SELECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UART_BAUD_SELECT( baudRate,  xtalCpu)}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (((xtalCpu) + 8UL * (baudRate)) / (16UL * (baudRate)) - 1UL)\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
UART Baudrate Expression. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xtalCpu} \cell }{system clock in Mhz, e.g. 4000000UL for 4Mhz \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i baudRate} \cell }{baudrate in bps, e.g. 1200, 2400, 9600 \cell }
{\row }
}
}{
Definition at line {\b 70} of file {\b uart.h}.}\par
}
{\xe \v UART_BAUD_SELECT_DOUBLE_SPEED\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:UART_BAUD_SELECT_DOUBLE_SPEED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UART_BAUD_SELECT_DOUBLE_SPEED( baudRate,  xtalCpu)}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( ((((xtalCpu) + 4UL * (baudRate)) / (8UL * (baudRate)) - 1UL)) | 0x8000)\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
UART Baudrate Expression for ATmega double speed mode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xtalCpu} \cell }{system clock in Mhz, e.g. 4000000UL for 4Mhz \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i baudRate} \cell }{baudrate in bps, e.g. 1200, 2400, 9600 \cell }
{\row }
}
}{
Definition at line {\b 76} of file {\b uart.h}.}\par
}
{\xe \v UART_BUFFER_OVERFLOW\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:UART_BUFFER_OVERFLOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UART_BUFFER_OVERFLOW\~ 0x0200}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
receive ringbuffer overflow }}\par
{
Definition at line {\b 107} of file {\b uart.h}.}\par
}
{\xe \v UART_FRAME_ERROR\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:UART_FRAME_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UART_FRAME_ERROR\~ 0x1000}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Framing Error by UART. }}\par
{
Definition at line {\b 104} of file {\b uart.h}.}\par
}
{\xe \v UART_NO_DATA\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:UART_NO_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UART_NO_DATA\~ 0x0100}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
no receive data available }}\par
{
Definition at line {\b 108} of file {\b uart.h}.}\par
}
{\xe \v UART_OVERRUN_ERROR\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:UART_OVERRUN_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UART_OVERRUN_ERROR\~ 0x0800}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overrun condition by UART. }}\par
{
Definition at line {\b 105} of file {\b uart.h}.}\par
}
{\xe \v UART_PARITY_ERROR\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:UART_PARITY_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UART_PARITY_ERROR\~ 0x0400}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parity Error by UART. }}\par
{
Definition at line {\b 106} of file {\b uart.h}.}\par
}
{\xe \v uart_puts_P\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:uart_puts_P}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define uart_puts_P( __s)}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid uart_puts_p(PSTR(__s))\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macro to automatically put a string constant into program memory. }}\par
{
Definition at line {\b 187} of file {\b uart.h}.}\par
}
{\xe \v UART_RX_BUFFER_SIZE\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:UART_RX_BUFFER_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UART_RX_BUFFER_SIZE\~ 128}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of the circular receive buffer, must be power of 2. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You may need to adapt this constant to your target and your application by adding CDEFS += -DUART_RX_BUFFER_SIZE=nn to your Makefile. \par
}{
Definition at line {\b 84} of file {\b uart.h}.}\par
}
{\xe \v UART_TX_BUFFER_SIZE\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:UART_TX_BUFFER_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UART_TX_BUFFER_SIZE\~ 128}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of the circular transmit buffer, must be power of 2. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You may need to adapt this constant to your target and your application by adding CDEFS += -DUART_TX_BUFFER_SIZE=nn to your Makefile. \par
}{
Definition at line {\b 93} of file {\b uart.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v uart1_getc\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:uart1_getc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int uart1_getc (void ){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get received byte of USART1 from ringbuffer. (only available on selected ATmega). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b uart_getc} \par
}}}}
{\xe \v uart1_init\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:uart1_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void uart1_init (unsigned int baudrate){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize USART1 (only available on selected ATmegas). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b uart_init} \par
}}}}
{\xe \v uart1_putc\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:uart1_putc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void uart1_putc (unsigned char data){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put byte to ringbuffer for transmitting via USART1 (only available on selected ATmega). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b uart_putc} \par
}}}}
{\xe \v uart1_puts\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:uart1_puts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void uart1_puts (const char * s){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put string to ringbuffer for transmitting via USART1 (only available on selected ATmega). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b uart_puts} \par
}}}}
{\xe \v uart1_puts_p\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:uart1_puts_p}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void uart1_puts_p (const char * s){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put string from program memory to ringbuffer for transmitting via USART1 (only available on selected ATmega). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b uart_puts_p} \par
}}}}
{\xe \v uart_getc\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:uart_getc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int uart_getc (void ){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get received byte from ringbuffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns in the lower byte the received character and in the higher byte the last receive error. UART_NO_DATA is returned when no data is available.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
lower byte: received byte from ringbuffer \par
higher byte: last receive status{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9642\tab}\ilvl2\ls1 \li0\ri0\lin0\rin0\fi-360\tx1080\li1080\ri0\lin1080\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b 0}  successfully received data from UART\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9642\tab}\ilvl2\ls1 \li0\ri0\lin0\rin0\fi-360\tx1080\li1080\ri0\lin1080\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b UART_NO_DATA}  \par
no receive data available\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9642\tab}\ilvl2\ls1 \li0\ri0\lin0\rin0\fi-360\tx1080\li1080\ri0\lin1080\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b UART_BUFFER_OVERFLOW}  \par
Receive ringbuffer overflow. We are not reading the receive buffer fast enough, one or more received character have been dropped\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9642\tab}\ilvl2\ls1 \li0\ri0\lin0\rin0\fi-360\tx1080\li1080\ri0\lin1080\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b UART_OVERRUN_ERROR}  \par
Overrun condition by UART. A character already present in the UART UDR register was not read by the interrupt handler before the next character arrived, one or more received characters have been dropped.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9642\tab}\ilvl2\ls1 \li0\ri0\lin0\rin0\fi-360\tx1080\li1080\ri0\lin1080\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b UART_FRAME_ERROR}  \par
Framing Error by UART \par}
}}}{
Definition at line {\b 494} of file {\b uart.c}.}\par
}
{\xe \v uart_init\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:uart_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void uart_init (unsigned int baudrate){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize UART and set baudrate. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i baudrate} \cell }{Specify baudrate using macro {\b UART_BAUD_SELECT()} \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
none \par
}}}{
Definition at line {\b 439} of file {\b uart.c}.}\par
}
{\xe \v uart_putc\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:uart_putc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void uart_putc (unsigned char data){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put byte to ringbuffer for transmitting via UART. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{byte to be transmitted \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
none \par
}}}{
Definition at line {\b 526} of file {\b uart.c}.}\par
}
{\xe \v uart_puts\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:uart_puts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void uart_puts (const char * s){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put string to ringbuffer for transmitting via UART. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The string is buffered by the uart library in a circular buffer and one character at a time is transmitted to the UART using interrupts. Blocks if it can not write the whole string into the circular buffer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i s} \cell }{string to be transmitted \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
none \par
}}}{
Definition at line {\b 551} of file {\b uart.c}.}\par
}
{\xe \v uart_puts_p\:UART Library <uart.h>}
{\xe \v UART Library <uart.h>\:uart_puts_p}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void uart_puts_p (const char * s){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put string from program memory to ringbuffer for transmitting via UART. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The string is buffered by the uart library in a circular buffer and one character at a time is transmitted to the UART using interrupts. Blocks if it can not write the whole string into the circular buffer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i s} \cell }{program memory string to be transmitted \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
none \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b uart_puts_P} \par
}}}{
Definition at line {\b 563} of file {\b uart.c}.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Directory Documentation{\tc \v Directory Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/bme280 Directory Reference\par \pard\plain 
{\tc\tcl2 \v lib/bme280 Directory Reference}
{\xe \v lib/bme280 Directory Reference}
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Files\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b bme280.c}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor driver for BME280 sensor. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b bme280.h}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor driver for BME280 sensor. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b bme280_defs.h}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/FAT32 Directory Reference\par \pard\plain 
{\tc\tcl2 \v lib/FAT32 Directory Reference}
{\xe \v lib/FAT32 Directory Reference}
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Files\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b FAT32.c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b FAT32.h}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/gas_index_algorithm Directory Reference\par \pard\plain 
{\tc\tcl2 \v lib/gas_index_algorithm Directory Reference}
{\xe \v lib/gas_index_algorithm Directory Reference}
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Files\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b sensirion_gas_index_algorithm.c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b sensirion_gas_index_algorithm.h}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/gpio Directory Reference\par \pard\plain 
{\tc\tcl2 \v lib/gpio Directory Reference}
{\xe \v lib/gpio Directory Reference}
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Files\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b gpio.c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b gpio.h}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include Directory Reference\par \pard\plain 
{\tc\tcl2 \v include Directory Reference}
{\xe \v include Directory Reference}
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Files\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b timer.h}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib Directory Reference\par \pard\plain 
{\tc\tcl2 \v lib Directory Reference}
{\xe \v lib Directory Reference}
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Directories\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
directory {\b bme280}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
directory {\b FAT32}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
directory {\b gas_index_algorithm}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
directory {\b gpio}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
directory {\b rtc}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
directory {\b sd}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
directory {\b sgp41}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
directory {\b SPI}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
directory {\b twi}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
directory {\b uart}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/rtc Directory Reference\par \pard\plain 
{\tc\tcl2 \v lib/rtc Directory Reference}
{\xe \v lib/rtc Directory Reference}
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Files\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b rtc.c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b rtc.h}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/sd Directory Reference\par \pard\plain 
{\tc\tcl2 \v lib/sd Directory Reference}
{\xe \v lib/sd Directory Reference}
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Files\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b SD_routines.c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b sd_routines.h}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/sgp41 Directory Reference\par \pard\plain 
{\tc\tcl2 \v lib/sgp41 Directory Reference}
{\xe \v lib/sgp41 Directory Reference}
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Files\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b SensirionI2CSgp41.c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b SensirionI2CSgp41.h}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/SPI Directory Reference\par \pard\plain 
{\tc\tcl2 \v lib/SPI Directory Reference}
{\xe \v lib/SPI Directory Reference}
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Files\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b SPI_routines.c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b SPI_routines.h}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src Directory Reference\par \pard\plain 
{\tc\tcl2 \v src Directory Reference}
{\xe \v src Directory Reference}
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Files\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b bme.c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b main.c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b sgp41.c}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/twi Directory Reference\par \pard\plain 
{\tc\tcl2 \v lib/twi Directory Reference}
{\xe \v lib/twi Directory Reference}
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Files\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b twi.c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b twi.h}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/uart Directory Reference\par \pard\plain 
{\tc\tcl2 \v lib/uart Directory Reference}
{\xe \v lib/uart Directory Reference}
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Files\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b uart.c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b uart.h}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file {\b uart_compat.h}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bme280_calib_data Struct Reference\par \pard\plain 
{\tc\tcl2 \v bme280_calib_data}
{\xe \v bme280_calib_data}
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration data. }}\par
{
{\f2 #include <bme280_defs.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b dig_t1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_t2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_t3}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b dig_p1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_p2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_p3}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_p4}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_p5}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_p6}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_p7}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_p8}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_p9}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b dig_h1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_h2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b dig_h3}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_h4}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b dig_h5}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b dig_h6}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b t_fine}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration data. \par
}{
Definition at line {\b 328} of file {\b bme280_defs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v dig_h1\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_h1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t bme280_calib_data::dig_h1}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the humidity sensor \par
}{
Definition at line {\b 367} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_h2\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_h2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t bme280_calib_data::dig_h2}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the humidity sensor \par
}{
Definition at line {\b 370} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_h3\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_h3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t bme280_calib_data::dig_h3}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the humidity sensor \par
}{
Definition at line {\b 373} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_h4\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_h4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t bme280_calib_data::dig_h4}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the humidity sensor \par
}{
Definition at line {\b 376} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_h5\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_h5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t bme280_calib_data::dig_h5}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the humidity sensor \par
}{
Definition at line {\b 379} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_h6\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_h6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_calib_data::dig_h6}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the humidity sensor \par
}{
Definition at line {\b 382} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_p1\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_p1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t bme280_calib_data::dig_p1}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the pressure sensor \par
}{
Definition at line {\b 340} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_p2\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_p2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t bme280_calib_data::dig_p2}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the pressure sensor \par
}{
Definition at line {\b 343} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_p3\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_p3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t bme280_calib_data::dig_p3}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the pressure sensor \par
}{
Definition at line {\b 346} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_p4\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_p4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t bme280_calib_data::dig_p4}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the pressure sensor \par
}{
Definition at line {\b 349} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_p5\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_p5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t bme280_calib_data::dig_p5}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the pressure sensor \par
}{
Definition at line {\b 352} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_p6\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_p6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t bme280_calib_data::dig_p6}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the pressure sensor \par
}{
Definition at line {\b 355} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_p7\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_p7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t bme280_calib_data::dig_p7}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the pressure sensor \par
}{
Definition at line {\b 358} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_p8\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_p8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t bme280_calib_data::dig_p8}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the pressure sensor \par
}{
Definition at line {\b 361} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_p9\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_p9}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t bme280_calib_data::dig_p9}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the pressure sensor \par
}{
Definition at line {\b 364} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_t1\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_t1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t bme280_calib_data::dig_t1}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the temperature sensor \par
}{
Definition at line {\b 331} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_t2\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_t2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t bme280_calib_data::dig_t2}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the temperature sensor \par
}{
Definition at line {\b 334} of file {\b bme280_defs.h}.}\par
}
{\xe \v dig_t3\:bme280_calib_data}
{\xe \v bme280_calib_data\:dig_t3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t bme280_calib_data::dig_t3}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration coefficient for the temperature sensor \par
}{
Definition at line {\b 337} of file {\b bme280_defs.h}.}\par
}
{\xe \v t_fine\:bme280_calib_data}
{\xe \v bme280_calib_data\:t_fine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t bme280_calib_data::t_fine}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Variable to store the intermediate temperature coefficient \par
}{
Definition at line {\b 385} of file {\b bme280_defs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/bme280/{\b bme280_defs.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bme280_data Struct Reference\par \pard\plain 
{\tc\tcl2 \v bme280_data}
{\xe \v bme280_data}
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280 sensor structure which comprises of temperature, pressure and humidity data }}\par
{
{\f2 #include <bme280_defs.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b pressure}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b temperature}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b humidity}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280 sensor structure which comprises of temperature, pressure and humidity data \par
}{
Definition at line {\b 393} of file {\b bme280_defs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v humidity\:bme280_data}
{\xe \v bme280_data\:humidity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double bme280_data::humidity}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compensated humidity \par
}{
Definition at line {\b 402} of file {\b bme280_defs.h}.}\par
}
{\xe \v pressure\:bme280_data}
{\xe \v bme280_data\:pressure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double bme280_data::pressure}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compensated pressure \par
}{
Definition at line {\b 396} of file {\b bme280_defs.h}.}\par
}
{\xe \v temperature\:bme280_data}
{\xe \v bme280_data\:temperature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double bme280_data::temperature}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compensated temperature \par
}{
Definition at line {\b 399} of file {\b bme280_defs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/bme280/{\b bme280_defs.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bme280_dev Struct Reference\par \pard\plain 
{\tc\tcl2 \v bme280_dev}
{\xe \v bme280_dev}
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280 device structure }}\par
{
{\f2 #include <bme280_defs.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b chip_id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b bme280_intf} {\b intf}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b intf_ptr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BME280_INTF_RET_TYPE} {\b intf_rslt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bme280_read_fptr_t} {\b read}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bme280_write_fptr_t} {\b write}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bme280_delay_us_fptr_t} {\b delay_us}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b bme280_calib_data} {\b calib_data}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280 device structure \par
}{
Definition at line {\b 459} of file {\b bme280_defs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v calib_data\:bme280_dev}
{\xe \v bme280_dev\:calib_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b bme280_calib_data} bme280_dev::calib_data}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Trim data \par
}{
Definition at line {\b 491} of file {\b bme280_defs.h}.}\par
}
{\xe \v chip_id\:bme280_dev}
{\xe \v bme280_dev\:chip_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t bme280_dev::chip_id}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Chip Id \par
}{
Definition at line {\b 462} of file {\b bme280_defs.h}.}\par
}
{\xe \v delay_us\:bme280_dev}
{\xe \v bme280_dev\:delay_us}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bme280_delay_us_fptr_t} bme280_dev::delay_us}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Delay function pointer \par
}{
Definition at line {\b 488} of file {\b bme280_defs.h}.}\par
}
{\xe \v intf\:bme280_dev}
{\xe \v bme280_dev\:intf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b bme280_intf} bme280_dev::intf}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface Selection For SPI, intf = BME280_SPI_INTF For I2C, intf = BME280_I2C_INTF \par
}{
Definition at line {\b 468} of file {\b bme280_defs.h}.}\par
}
{\xe \v intf_ptr\:bme280_dev}
{\xe \v bme280_dev\:intf_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* bme280_dev::intf_ptr}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The interface pointer is used to enable the user to link their interface descriptors for reference during the implementation of the read and write interfaces to the hardware. \par
}{
Definition at line {\b 476} of file {\b bme280_defs.h}.}\par
}
{\xe \v intf_rslt\:bme280_dev}
{\xe \v bme280_dev\:intf_rslt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BME280_INTF_RET_TYPE} bme280_dev::intf_rslt}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Variable to store result of read/write function \par
}{
Definition at line {\b 479} of file {\b bme280_defs.h}.}\par
}
{\xe \v read\:bme280_dev}
{\xe \v bme280_dev\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bme280_read_fptr_t} bme280_dev::read}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read function pointer \par
}{
Definition at line {\b 482} of file {\b bme280_defs.h}.}\par
}
{\xe \v write\:bme280_dev}
{\xe \v bme280_dev\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bme280_write_fptr_t} bme280_dev::write}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write function pointer \par
}{
Definition at line {\b 485} of file {\b bme280_defs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/bme280/{\b bme280_defs.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bme280_settings Struct Reference\par \pard\plain 
{\tc\tcl2 \v bme280_settings}
{\xe \v bme280_settings}
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280 sensor settings structure which comprises of mode, oversampling and filter settings. }}\par
{
{\f2 #include <bme280_defs.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b osr_p}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b osr_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b osr_h}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b filter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b standby_time}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280 sensor settings structure which comprises of mode, oversampling and filter settings. \par
}{
Definition at line {\b 438} of file {\b bme280_defs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v filter\:bme280_settings}
{\xe \v bme280_settings\:filter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t bme280_settings::filter}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Filter coefficient \par
}{
Definition at line {\b 450} of file {\b bme280_defs.h}.}\par
}
{\xe \v osr_h\:bme280_settings}
{\xe \v bme280_settings\:osr_h}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t bme280_settings::osr_h}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Humidity oversampling \par
}{
Definition at line {\b 447} of file {\b bme280_defs.h}.}\par
}
{\xe \v osr_p\:bme280_settings}
{\xe \v bme280_settings\:osr_p}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t bme280_settings::osr_p}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pressure oversampling \par
}{
Definition at line {\b 441} of file {\b bme280_defs.h}.}\par
}
{\xe \v osr_t\:bme280_settings}
{\xe \v bme280_settings\:osr_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t bme280_settings::osr_t}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Temperature oversampling \par
}{
Definition at line {\b 444} of file {\b bme280_defs.h}.}\par
}
{\xe \v standby_time\:bme280_settings}
{\xe \v bme280_settings\:standby_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t bme280_settings::standby_time}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Standby time \par
}{
Definition at line {\b 453} of file {\b bme280_defs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/bme280/{\b bme280_defs.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bme280_uncomp_data Struct Reference\par \pard\plain 
{\tc\tcl2 \v bme280_uncomp_data}
{\xe \v bme280_uncomp_data}
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280 sensor structure which comprises of uncompensated temperature, pressure and humidity data }}\par
{
{\f2 #include <bme280_defs.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b pressure}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b temperature}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b humidity}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280 sensor structure which comprises of uncompensated temperature, pressure and humidity data \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BME280_USE_FLOATING_POINT \par
}{
Definition at line {\b 422} of file {\b bme280_defs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v humidity\:bme280_uncomp_data}
{\xe \v bme280_uncomp_data\:humidity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t bme280_uncomp_data::humidity}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Un-compensated humidity \par
}{
Definition at line {\b 431} of file {\b bme280_defs.h}.}\par
}
{\xe \v pressure\:bme280_uncomp_data}
{\xe \v bme280_uncomp_data\:pressure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t bme280_uncomp_data::pressure}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Un-compensated pressure \par
}{
Definition at line {\b 425} of file {\b bme280_defs.h}.}\par
}
{\xe \v temperature\:bme280_uncomp_data}
{\xe \v bme280_uncomp_data\:temperature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t bme280_uncomp_data::temperature}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Un-compensated temperature \par
}{
Definition at line {\b 428} of file {\b bme280_defs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/bme280/{\b bme280_defs.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BS_Structure Struct Reference\par \pard\plain 
{\tc\tcl2 \v BS_Structure}
{\xe \v BS_Structure}
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
\par
{
{\f2 #include <FAT32.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b jumpBoot} [3]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b OEMName} [8]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b bytesPerSector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b sectorPerCluster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b reservedSectorCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b numberofFATs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b rootEntryCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b totalSectors_F16}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b mediaType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b FATsize_F16}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b sectorsPerTrack}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b numberofHeads}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b hiddenSectors}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b totalSectors_F32}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b FATsize_F32}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b extFlags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b FSversion}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b rootCluster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b FSinfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b BackupBootSector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b reserved} [12]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b driveNumber}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b reserved1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b bootSignature}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b volumeID}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b volumeLabel} [11]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b fileSystemType} [8]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b bootData} [420]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b bootEndSignature}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 35} of file {\b FAT32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v BackupBootSector\:BS_Structure}
{\xe \v BS_Structure\:BackupBootSector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BS_Structure::BackupBootSector}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b FAT32.h}.}\par
}
{\xe \v bootData\:BS_Structure}
{\xe \v BS_Structure\:bootData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char BS_Structure::bootData[420]}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b FAT32.h}.}\par
}
{\xe \v bootEndSignature\:BS_Structure}
{\xe \v BS_Structure\:bootEndSignature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BS_Structure::bootEndSignature}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b FAT32.h}.}\par
}
{\xe \v bootSignature\:BS_Structure}
{\xe \v BS_Structure\:bootSignature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char BS_Structure::bootSignature}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b FAT32.h}.}\par
}
{\xe \v bytesPerSector\:BS_Structure}
{\xe \v BS_Structure\:bytesPerSector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BS_Structure::bytesPerSector}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b FAT32.h}.}\par
}
{\xe \v driveNumber\:BS_Structure}
{\xe \v BS_Structure\:driveNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char BS_Structure::driveNumber}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b FAT32.h}.}\par
}
{\xe \v extFlags\:BS_Structure}
{\xe \v BS_Structure\:extFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BS_Structure::extFlags}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b FAT32.h}.}\par
}
{\xe \v FATsize_F16\:BS_Structure}
{\xe \v BS_Structure\:FATsize_F16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BS_Structure::FATsize_F16}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b FAT32.h}.}\par
}
{\xe \v FATsize_F32\:BS_Structure}
{\xe \v BS_Structure\:FATsize_F32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long BS_Structure::FATsize_F32}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b FAT32.h}.}\par
}
{\xe \v fileSystemType\:BS_Structure}
{\xe \v BS_Structure\:fileSystemType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char BS_Structure::fileSystemType[8]}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b FAT32.h}.}\par
}
{\xe \v FSinfo\:BS_Structure}
{\xe \v BS_Structure\:FSinfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BS_Structure::FSinfo}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b FAT32.h}.}\par
}
{\xe \v FSversion\:BS_Structure}
{\xe \v BS_Structure\:FSversion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BS_Structure::FSversion}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b FAT32.h}.}\par
}
{\xe \v hiddenSectors\:BS_Structure}
{\xe \v BS_Structure\:hiddenSectors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long BS_Structure::hiddenSectors}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b FAT32.h}.}\par
}
{\xe \v jumpBoot\:BS_Structure}
{\xe \v BS_Structure\:jumpBoot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char BS_Structure::jumpBoot[3]}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b FAT32.h}.}\par
}
{\xe \v mediaType\:BS_Structure}
{\xe \v BS_Structure\:mediaType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char BS_Structure::mediaType}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b FAT32.h}.}\par
}
{\xe \v numberofFATs\:BS_Structure}
{\xe \v BS_Structure\:numberofFATs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char BS_Structure::numberofFATs}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b FAT32.h}.}\par
}
{\xe \v numberofHeads\:BS_Structure}
{\xe \v BS_Structure\:numberofHeads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BS_Structure::numberofHeads}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b FAT32.h}.}\par
}
{\xe \v OEMName\:BS_Structure}
{\xe \v BS_Structure\:OEMName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char BS_Structure::OEMName[8]}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b FAT32.h}.}\par
}
{\xe \v reserved\:BS_Structure}
{\xe \v BS_Structure\:reserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char BS_Structure::reserved[12]}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b FAT32.h}.}\par
}
{\xe \v reserved1\:BS_Structure}
{\xe \v BS_Structure\:reserved1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char BS_Structure::reserved1}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b FAT32.h}.}\par
}
{\xe \v reservedSectorCount\:BS_Structure}
{\xe \v BS_Structure\:reservedSectorCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BS_Structure::reservedSectorCount}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b FAT32.h}.}\par
}
{\xe \v rootCluster\:BS_Structure}
{\xe \v BS_Structure\:rootCluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long BS_Structure::rootCluster}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b FAT32.h}.}\par
}
{\xe \v rootEntryCount\:BS_Structure}
{\xe \v BS_Structure\:rootEntryCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BS_Structure::rootEntryCount}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b FAT32.h}.}\par
}
{\xe \v sectorPerCluster\:BS_Structure}
{\xe \v BS_Structure\:sectorPerCluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char BS_Structure::sectorPerCluster}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b FAT32.h}.}\par
}
{\xe \v sectorsPerTrack\:BS_Structure}
{\xe \v BS_Structure\:sectorsPerTrack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BS_Structure::sectorsPerTrack}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b FAT32.h}.}\par
}
{\xe \v totalSectors_F16\:BS_Structure}
{\xe \v BS_Structure\:totalSectors_F16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BS_Structure::totalSectors_F16}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b FAT32.h}.}\par
}
{\xe \v totalSectors_F32\:BS_Structure}
{\xe \v BS_Structure\:totalSectors_F32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long BS_Structure::totalSectors_F32}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b FAT32.h}.}\par
}
{\xe \v volumeID\:BS_Structure}
{\xe \v BS_Structure\:volumeID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long BS_Structure::volumeID}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b FAT32.h}.}\par
}
{\xe \v volumeLabel\:BS_Structure}
{\xe \v BS_Structure\:volumeLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char BS_Structure::volumeLabel[11]}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b FAT32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/FAT32/{\b FAT32.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dir_Structure Struct Reference\par \pard\plain 
{\tc\tcl2 \v dir_Structure}
{\xe \v dir_Structure}
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
\par
{
{\f2 #include <FAT32.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b name} [11]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b attrib}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b NTreserved}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b timeTenth}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b createTime}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b createDate}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastAccessDate}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b firstClusterHI}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b writeTime}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b writeDate}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b firstClusterLO}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b fileSize}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 81} of file {\b FAT32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v attrib\:dir_Structure}
{\xe \v dir_Structure\:attrib}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char dir_Structure::attrib}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b FAT32.h}.}\par
}
{\xe \v createDate\:dir_Structure}
{\xe \v dir_Structure\:createDate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int dir_Structure::createDate}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b FAT32.h}.}\par
}
{\xe \v createTime\:dir_Structure}
{\xe \v dir_Structure\:createTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int dir_Structure::createTime}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b FAT32.h}.}\par
}
{\xe \v fileSize\:dir_Structure}
{\xe \v dir_Structure\:fileSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long dir_Structure::fileSize}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b FAT32.h}.}\par
}
{\xe \v firstClusterHI\:dir_Structure}
{\xe \v dir_Structure\:firstClusterHI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int dir_Structure::firstClusterHI}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b FAT32.h}.}\par
}
{\xe \v firstClusterLO\:dir_Structure}
{\xe \v dir_Structure\:firstClusterLO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int dir_Structure::firstClusterLO}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b FAT32.h}.}\par
}
{\xe \v lastAccessDate\:dir_Structure}
{\xe \v dir_Structure\:lastAccessDate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int dir_Structure::lastAccessDate}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b FAT32.h}.}\par
}
{\xe \v name\:dir_Structure}
{\xe \v dir_Structure\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char dir_Structure::name[11]}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b FAT32.h}.}\par
}
{\xe \v NTreserved\:dir_Structure}
{\xe \v dir_Structure\:NTreserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char dir_Structure::NTreserved}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b FAT32.h}.}\par
}
{\xe \v timeTenth\:dir_Structure}
{\xe \v dir_Structure\:timeTenth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char dir_Structure::timeTenth}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b FAT32.h}.}\par
}
{\xe \v writeDate\:dir_Structure}
{\xe \v dir_Structure\:writeDate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int dir_Structure::writeDate}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b FAT32.h}.}\par
}
{\xe \v writeTime\:dir_Structure}
{\xe \v dir_Structure\:writeTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int dir_Structure::writeTime}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b FAT32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/FAT32/{\b FAT32.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FSInfo_Structure Struct Reference\par \pard\plain 
{\tc\tcl2 \v FSInfo_Structure}
{\xe \v FSInfo_Structure}
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
\par
{
{\f2 #include <FAT32.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b leadSignature}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b reserved1} [480]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b structureSignature}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b freeClusterCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b nextFreeCluster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b reserved2} [12]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b trailSignature}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 69} of file {\b FAT32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v freeClusterCount\:FSInfo_Structure}
{\xe \v FSInfo_Structure\:freeClusterCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long FSInfo_Structure::freeClusterCount}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b FAT32.h}.}\par
}
{\xe \v leadSignature\:FSInfo_Structure}
{\xe \v FSInfo_Structure\:leadSignature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long FSInfo_Structure::leadSignature}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b FAT32.h}.}\par
}
{\xe \v nextFreeCluster\:FSInfo_Structure}
{\xe \v FSInfo_Structure\:nextFreeCluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long FSInfo_Structure::nextFreeCluster}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b FAT32.h}.}\par
}
{\xe \v reserved1\:FSInfo_Structure}
{\xe \v FSInfo_Structure\:reserved1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char FSInfo_Structure::reserved1[480]}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b FAT32.h}.}\par
}
{\xe \v reserved2\:FSInfo_Structure}
{\xe \v FSInfo_Structure\:reserved2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char FSInfo_Structure::reserved2[12]}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b FAT32.h}.}\par
}
{\xe \v structureSignature\:FSInfo_Structure}
{\xe \v FSInfo_Structure\:structureSignature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long FSInfo_Structure::structureSignature}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b FAT32.h}.}\par
}
{\xe \v trailSignature\:FSInfo_Structure}
{\xe \v FSInfo_Structure\:trailSignature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long FSInfo_Structure::trailSignature}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b FAT32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/FAT32/{\b FAT32.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GasIndexAlgorithmParams Struct Reference\par \pard\plain 
{\tc\tcl2 \v GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams}
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
\par
{
{\f2 #include <sensirion_gas_index_algorithm.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b mAlgorithm_Type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b mIndex_Offset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b mSraw_Minimum}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b mGating_Max_Duration_Minutes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b mInit_Duration_Mean}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b mInit_Duration_Variance}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b mGating_Threshold}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b mIndex_Gain}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b mTau_Mean_Hours}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b mTau_Variance_Hours}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b mSraw_Std_Initial}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b mUptime}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b mSraw}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b mGas_Index}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b m_Mean_Variance_Estimator___Initialized}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mean_Variance_Estimator___Mean}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mean_Variance_Estimator___Sraw_Offset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mean_Variance_Estimator___Std}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mean_Variance_Estimator___Gamma_Mean}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mean_Variance_Estimator___Gamma_Variance}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mean_Variance_Estimator___Gamma_Initial_Mean}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mean_Variance_Estimator___Gamma_Initial_Variance}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mean_Variance_Estimator__Gamma_Mean}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mean_Variance_Estimator__Gamma_Variance}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mean_Variance_Estimator___Uptime_Gamma}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mean_Variance_Estimator___Uptime_Gating}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mean_Variance_Estimator___Gating_Duration_Minutes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mean_Variance_Estimator___Sigmoid__K}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mean_Variance_Estimator___Sigmoid__X0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mox_Model__Sraw_Std}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Mox_Model__Sraw_Mean}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Sigmoid_Scaled__K}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Sigmoid_Scaled__X0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Sigmoid_Scaled__Offset_Default}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Adaptive_Lowpass__A1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Adaptive_Lowpass__A2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b m_Adaptive_Lowpass___Initialized}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Adaptive_Lowpass___X1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Adaptive_Lowpass___X2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fix16_t} {\b m_Adaptive_Lowpass___X3}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct to hold all parameters and states of the gas algorithm. \par
}{
Definition at line {\b 129} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Adaptive_Lowpass___Initialized\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Adaptive_Lowpass___Initialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} GasIndexAlgorithmParams::m_Adaptive_Lowpass___Initialized}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Adaptive_Lowpass___X1\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Adaptive_Lowpass___X1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Adaptive_Lowpass___X1}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Adaptive_Lowpass___X2\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Adaptive_Lowpass___X2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Adaptive_Lowpass___X2}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 168} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Adaptive_Lowpass___X3\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Adaptive_Lowpass___X3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Adaptive_Lowpass___X3}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Adaptive_Lowpass__A1\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Adaptive_Lowpass__A1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Adaptive_Lowpass__A1}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Adaptive_Lowpass__A2\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Adaptive_Lowpass__A2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Adaptive_Lowpass__A2}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator___Gamma_Initial_Mean\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator___Gamma_Initial_Mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mean_Variance_Estimator___Gamma_Initial_Mean}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 150} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator___Gamma_Initial_Variance\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator___Gamma_Initial_Variance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mean_Variance_Estimator___Gamma_Initial_Variance}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator___Gamma_Mean\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator___Gamma_Mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mean_Variance_Estimator___Gamma_Mean}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 148} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator___Gamma_Variance\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator___Gamma_Variance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mean_Variance_Estimator___Gamma_Variance}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator___Gating_Duration_Minutes\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator___Gating_Duration_Minutes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mean_Variance_Estimator___Gating_Duration_Minutes}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 156} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator___Initialized\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator___Initialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} GasIndexAlgorithmParams::m_Mean_Variance_Estimator___Initialized}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 144} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator___Mean\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator___Mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mean_Variance_Estimator___Mean}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 145} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator___Sigmoid__K\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator___Sigmoid__K}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mean_Variance_Estimator___Sigmoid__K}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator___Sigmoid__X0\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator___Sigmoid__X0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mean_Variance_Estimator___Sigmoid__X0}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator___Sraw_Offset\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator___Sraw_Offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mean_Variance_Estimator___Sraw_Offset}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator___Std\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator___Std}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mean_Variance_Estimator___Std}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator___Uptime_Gamma\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator___Uptime_Gamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mean_Variance_Estimator___Uptime_Gamma}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator___Uptime_Gating\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator___Uptime_Gating}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mean_Variance_Estimator___Uptime_Gating}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 155} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator__Gamma_Mean\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator__Gamma_Mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mean_Variance_Estimator__Gamma_Mean}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 152} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mean_Variance_Estimator__Gamma_Variance\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mean_Variance_Estimator__Gamma_Variance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mean_Variance_Estimator__Gamma_Variance}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mox_Model__Sraw_Mean\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mox_Model__Sraw_Mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mox_Model__Sraw_Mean}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Mox_Model__Sraw_Std\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Mox_Model__Sraw_Std}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Mox_Model__Sraw_Std}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Sigmoid_Scaled__K\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Sigmoid_Scaled__K}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Sigmoid_Scaled__K}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 161} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Sigmoid_Scaled__Offset_Default\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Sigmoid_Scaled__Offset_Default}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Sigmoid_Scaled__Offset_Default}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 163} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v m_Sigmoid_Scaled__X0\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:m_Sigmoid_Scaled__X0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::m_Sigmoid_Scaled__X0}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v mAlgorithm_Type\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:mAlgorithm_Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t GasIndexAlgorithmParams::mAlgorithm_Type}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v mGas_Index\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:mGas_Index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::mGas_Index}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v mGating_Max_Duration_Minutes\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:mGating_Max_Duration_Minutes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::mGating_Max_Duration_Minutes}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v mGating_Threshold\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:mGating_Threshold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::mGating_Threshold}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v mIndex_Gain\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:mIndex_Gain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::mIndex_Gain}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v mIndex_Offset\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:mIndex_Offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::mIndex_Offset}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v mInit_Duration_Mean\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:mInit_Duration_Mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::mInit_Duration_Mean}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v mInit_Duration_Variance\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:mInit_Duration_Variance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::mInit_Duration_Variance}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v mSraw\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:mSraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::mSraw}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 142} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v mSraw_Minimum\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:mSraw_Minimum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t GasIndexAlgorithmParams::mSraw_Minimum}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v mSraw_Std_Initial\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:mSraw_Std_Initial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::mSraw_Std_Initial}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 140} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v mTau_Mean_Hours\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:mTau_Mean_Hours}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::mTau_Mean_Hours}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v mTau_Variance_Hours\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:mTau_Variance_Hours}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::mTau_Variance_Hours}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v mUptime\:GasIndexAlgorithmParams}
{\xe \v GasIndexAlgorithmParams\:mUptime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fix16_t} GasIndexAlgorithmParams::mUptime}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/gas_index_algorithm/{\b sensirion_gas_index_algorithm.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MBRinfo_Structure Struct Reference\par \pard\plain 
{\tc\tcl2 \v MBRinfo_Structure}
{\xe \v MBRinfo_Structure}
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
\par
{
{\f2 #include <FAT32.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b nothing} [446]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b partitionData} [64]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b signature}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 16} of file {\b FAT32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v nothing\:MBRinfo_Structure}
{\xe \v MBRinfo_Structure\:nothing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MBRinfo_Structure::nothing[446]}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b FAT32.h}.}\par
}
{\xe \v partitionData\:MBRinfo_Structure}
{\xe \v MBRinfo_Structure\:partitionData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MBRinfo_Structure::partitionData[64]}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b FAT32.h}.}\par
}
{\xe \v signature\:MBRinfo_Structure}
{\xe \v MBRinfo_Structure\:signature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MBRinfo_Structure::signature}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b FAT32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/FAT32/{\b FAT32.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
partitionInfo_Structure Struct Reference\par \pard\plain 
{\tc\tcl2 \v partitionInfo_Structure}
{\xe \v partitionInfo_Structure}
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
\par
{
{\f2 #include <FAT32.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b status}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b headStart}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b cylSectStart}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b headEnd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b cylSectEnd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b firstSector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b sectorsTotal}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 23} of file {\b FAT32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cylSectEnd\:partitionInfo_Structure}
{\xe \v partitionInfo_Structure\:cylSectEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int partitionInfo_Structure::cylSectEnd}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b FAT32.h}.}\par
}
{\xe \v cylSectStart\:partitionInfo_Structure}
{\xe \v partitionInfo_Structure\:cylSectStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int partitionInfo_Structure::cylSectStart}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b FAT32.h}.}\par
}
{\xe \v firstSector\:partitionInfo_Structure}
{\xe \v partitionInfo_Structure\:firstSector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long partitionInfo_Structure::firstSector}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b FAT32.h}.}\par
}
{\xe \v headEnd\:partitionInfo_Structure}
{\xe \v partitionInfo_Structure\:headEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char partitionInfo_Structure::headEnd}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b FAT32.h}.}\par
}
{\xe \v headStart\:partitionInfo_Structure}
{\xe \v partitionInfo_Structure\:headStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char partitionInfo_Structure::headStart}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b FAT32.h}.}\par
}
{\xe \v sectorsTotal\:partitionInfo_Structure}
{\xe \v partitionInfo_Structure\:sectorsTotal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long partitionInfo_Structure::sectorsTotal}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b FAT32.h}.}\par
}
{\xe \v status\:partitionInfo_Structure}
{\xe \v partitionInfo_Structure\:status}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char partitionInfo_Structure::status}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b FAT32.h}.}\par
}
{\xe \v type\:partitionInfo_Structure}
{\xe \v partitionInfo_Structure\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char partitionInfo_Structure::type}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b FAT32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/FAT32/{\b FAT32.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/timer.h File Reference\par \pard\plain 
{\tc\tcl2 \v include/timer.h}
{\xe \v include/timer.h}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <avr/io.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Definitions for 16-bit Timer/Counter1\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
t_OVF = 1/F_CPU * prescaler * 2^n where n = 16, F_CPU = 16 MHz \par
}}}}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_stop}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stop timer, prescaler 000 --> STOP. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_ovf_4ms}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 4ms, prescaler 001 --> 1. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_ovf_33ms}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 33ms, prescaler 010 --> 8. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_ovf_262ms}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 262ms, prescaler 011 --> 64. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_ovf_1sec}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 1s, prescaler 100 --> 256. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_ovf_4sec}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 4s, prescaler // 101 --> 1024. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_ovf_enable}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable overflow interrupt, 1 --> enable. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim1_ovf_disable}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable overflow interrupt, 0 --> disable. }{
}\par
}\par}
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Definitions for 8-bit Timer/Counter0\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
t_OVF = 1/F_CPU * prescaler * 2^n where n = 8, F_CPU = 16 MHz \par
}}}}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_stop}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stop timer, prescaler 000 --> STOP. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_ovf_16us}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 16us, prescaler 001 --> 1. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_ovf_128us}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 128us, prescaler 010 --> 8. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_ovf_1024us}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 1024us, prescaler 011 --> 64. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_ovf_4096us}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 4096us, prescaler 100 --> 256. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_ovf_16384us}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 16384us, prescaler // 101 --> 1024. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_ovf_enable}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable overflow interrupt, 1 --> enable. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim0_ovf_disable}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable overflow interrupt, 0 --> disable. }{
}\par
}\par}
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Definitions for 8-bit Timer/Counter2\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
t_OVF = 1/F_CPU * prescaler * 2^n where n = 8, F_CPU = 16 MHz \par
}}}}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_stop}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stop timer, prescaler 000 --> STOP. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_16us}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 16us, prescaler 001 --> 1. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_128us}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 128us, prescaler 010 --> 8. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_512us}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 512us, prescaler 011 --> 32. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_1024us}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 1024us, prescaler 100 --> 64. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_2048us}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 2048us, prescaler 101 --> 128. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_4096us}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 4096us, prescaler 110 --> 256. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_16ms}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set overflow 16384us, prescaler 111 --> 1024. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_enable}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable overflow interrupt, 1 --> enable. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tim2_ovf_disable}()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable overflow interrupt, 0 --> disable. }{
}\par
}\par}
}
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
timer.h\par \pard\plain 
{\tc\tcl2 \v include/timer.h}
{\xe \v include/timer.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef TIMER_H}\par
00002 {\cf21 # define TIMER_H}\par
00003 \par
00004 {\cf20 /* }\par
00005 {\cf20  * Timer library for AVR-GCC.}\par
00006 {\cf20  * (c) 2019-2025 Tomas Fryza, MIT license}\par
00007 {\cf20  *}\par
00008 {\cf20  * Developed using PlatformIO and Atmel AVR platform.}\par
00009 {\cf20  * Tested on Arduino Uno board and ATmega328P, 16 MHz.}\par
00010 {\cf20  */}\par
00011 \par
00026 \par
00027 \par
00028 {\cf20 // -- Includes ---------------------------------------------}\par
00029 {\cf21 #include <avr/io.h>}\par
00030 \par
00031 \par
00032 {\cf20 // -- Defines ----------------------------------------------}\par
00038 {\cf21 #define tim1_stop() TCCR1B &= ~((1<<CS12) | (1<<CS11) | (1<<CS10));}\par
00039 \par
00041 {\cf21 #define tim1_ovf_4ms() TCCR1B &= ~((1<<CS12) | (1<<CS11)); TCCR1B |= (1<<CS10);}\par
00042 \par
00044 {\cf21 #define tim1_ovf_33ms() TCCR1B &= ~((1<<CS12) | (1<<CS10)); TCCR1B |= (1<<CS11);}\par
00045 \par
00047 {\cf21 #define tim1_ovf_262ms() TCCR1B &= ~(1<<CS12); TCCR1B |= (1<<CS11) | (1<<CS10);}\par
00048 \par
00050 {\cf21 #define tim1_ovf_1sec() TCCR1B &= ~((1<<CS11) | (1<<CS10)); TCCR1B |= (1<<CS12);}\par
00051 \par
00053 {\cf21 #define tim1_ovf_4sec() TCCR1B &= ~(1<<CS11); TCCR1B |= (1<<CS12) | (1<<CS10);}\par
00054 \par
00056 {\cf21 #define tim1_ovf_enable() TIMSK1 |= (1<<TOIE1);}\par
00057 \par
00059 {\cf21 #define tim1_ovf_disable() TIMSK1 &= ~(1<<TOIE1);}\par
00060 \par
00061 \par
00066 {\cf20 // WRITE YOUR CODE HERE}\par
00068 {\cf21 #define tim0_stop() TCCR0B &= ~((1<<CS02) | (1<<CS01) | (1<<CS00));}\par
00069 \par
00071 {\cf21 #define tim0_ovf_16us() TCCR1B &= ~((1<<CS02) | (1<<CS01)); TCCR0B |= (1<<CS00);}\par
00072 \par
00074 {\cf21 #define tim0_ovf_128us() TCCR0B &= ~((1<<CS02) | (1<<CS00)); TCCR0B |= (1<<CS01);}\par
00075 \par
00077 {\cf21 #define tim0_ovf_1024us() TCCR0B &= ~(1<<CS02); TCCR0B |= (1<<CS01) | (1<<CS00);}\par
00078 \par
00080 {\cf21 #define tim0_ovf_4096us() TCCR0B &= ~((1<<CS01) | (1<<CS00)); TCCR0B |= (1<<CS02);}\par
00081 \par
00083 {\cf21 #define tim0_ovf_16384us() TCCR0B &= ~(1<<CS01); TCCR0B |= (1<<CS02) | (1<<CS00);}\par
00084 \par
00086 {\cf21 #define tim0_ovf_enable() TIMSK0 |= (1<<TOIE0);}\par
00087 \par
00089 {\cf21 #define tim0_ovf_disable() TIMSK0 &= ~(1<<TOIE0);}\par
00090 \par
00095 {\cf20 // WRITE YOUR CODE HERE}\par
00097 {\cf21 #define tim2_stop() TCCR2B &= ~((1<<CS22) | (1<<CS21) | (1<<CS20));}\par
00098 \par
00100 {\cf21 #define tim2_ovf_16us()  TCCR2B &= ~((1<<CS22) | (1<<CS21)); TCCR2B |= (1<<CS20);}\par
00101 \par
00103 {\cf21 #define tim2_ovf_128us() TCCR2B &= ~((1<<CS22) | (1<<CS20)); TCCR2B |= (1<<CS21);}\par
00104 \par
00106 {\cf21 #define tim2_ovf_512us() TCCR2B &= ~(1<<CS22); TCCR2B |= (1<<CS21) | (1<<CS20);}\par
00107 \par
00109 {\cf21 #define tim2_ovf_1024us() TCCR2B &= ~((1<<CS21) | (1<<CS20)); TCCR2B |= (1<<CS22);}\par
00110 \par
00112 {\cf21 #define tim2_ovf_2048us() TCCR2B &= ~(1<<CS21); TCCR2B |= (1<<CS22) | (1<<CS20);}\par
00113 \par
00115 {\cf21 #define tim2_ovf_4096us() TCCR2B &= ~(1<<CS20); TCCR2B |= (1<<CS22) | (1<<CS21);}\par
00116 \par
00118 {\cf21 #define tim2_ovf_16ms() TCCR2B |= (1<<CS22) | (1<<CS21) | (1<<CS20);}\par
00119 \par
00121 {\cf21 #define tim2_ovf_enable()  TIMSK2 |= (1<<TOIE2);}\par
00122 \par
00124 {\cf21 #define tim2_ovf_disable() TIMSK2 &= ~(1<<TOIE2);}\par
00125 \par
00126 \par
00128 \par
00129 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/bme280/bme280.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/bme280/bme280.c}
{\xe \v lib/bme280/bme280.c}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor driver for BME280 sensor. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "bme280.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Internal macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVERSAMPLING_SETTINGS}\~ {\b UINT8_C}(0x07)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FILTER_STANDBY_SETTINGS}\~ {\b UINT8_C}(0x18)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_init} (struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API is the entry point. It reads the chip-id and calibration data from the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_get_regs} (uint8_t reg_addr, uint8_t *reg_data, uint32_t len, struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API reads the data from the given register address of the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_set_regs} (uint8_t *reg_addr, const uint8_t *reg_data, uint32_t len, struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API writes the given data to the register address of the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_set_sensor_settings} (uint8_t desired_settings, const struct {\b bme280_settings} *settings, struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API sets the oversampling, filter and standby duration (normal mode) settings in the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_get_sensor_settings} (struct {\b bme280_settings} *settings, struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API gets the oversampling, filter and standby duration (normal mode) settings from the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_set_sensor_mode} (uint8_t sensor_mode, struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API sets the power mode of the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_get_sensor_mode} (uint8_t *sensor_mode, struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API gets the power mode of the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_soft_reset} (struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API performs the soft reset of the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_get_sensor_data} (uint8_t sensor_comp, struct {\b bme280_data} *comp_data, struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API reads the pressure, temperature and humidity data from the sensor, compensates the data and store it in the {\b bme280_data} structure instance passed by the user. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_compensate_data} (uint8_t sensor_comp, const struct {\b bme280_uncomp_data} *uncomp_data, struct {\b bme280_data} *comp_data, struct {\b bme280_calib_data} *calib_data)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API is used to compensate the pressure and/or temperature and/or humidity data according to the component selected by the user. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_cal_meas_delay} (uint32_t *max_delay, const struct {\b bme280_settings} *settings)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API is used to calculate the maximum delay in milliseconds required for the temperature/pressure/humidity(whichever are enabled) measurement to complete. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor driver for BME280 sensor. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2020 Bosch Sensortec GmbH. All rights reserved.\par
BSD-3-Clause\par
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\par
{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\par}
\par
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Date\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
2020-12-17 \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Version\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
v3.5.1\par
}}}{
Definition in file {\b bme280.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v FILTER_STANDBY_SETTINGS\:bme280.c}
{\xe \v bme280.c\:FILTER_STANDBY_SETTINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FILTER_STANDBY_SETTINGS\~ {\b UINT8_C}(0x18)}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b bme280.c}.}\par
}
{\xe \v OVERSAMPLING_SETTINGS\:bme280.c}
{\xe \v bme280.c\:OVERSAMPLING_SETTINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVERSAMPLING_SETTINGS\~ {\b UINT8_C}(0x07)}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b bme280.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v bme280_cal_meas_delay\:bme280.c}
{\xe \v bme280.c\:bme280_cal_meas_delay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_cal_meas_delay (uint32_t * max_delay, const struct {\b bme280_settings} * settings)}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API is used to calculate the maximum delay in milliseconds required for the temperature/pressure/humidity(whichever are enabled) measurement to complete. }}\par
{
Definition at line {\b 799} of file {\b bme280.c}.}\par
}
{\xe \v bme280_compensate_data\:bme280.c}
{\xe \v bme280.c\:bme280_compensate_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_compensate_data (uint8_t sensor_comp, const struct {\b bme280_uncomp_data} * uncomp_data, struct {\b bme280_data} * comp_data, struct {\b bme280_calib_data} * calib_data)}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API is used to compensate the pressure and/or temperature and/or humidity data according to the component selected by the user. }}\par
{
Definition at line {\b 754} of file {\b bme280.c}.}\par
}
{\xe \v bme280_get_regs\:bme280.c}
{\xe \v bme280.c\:bme280_get_regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_get_regs (uint8_t reg_addr, uint8_t * reg_data, uint32_t len, struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API reads the data from the given register address of the sensor. }}\par
{
Definition at line {\b 449} of file {\b bme280.c}.}\par
}
{\xe \v bme280_get_sensor_data\:bme280.c}
{\xe \v bme280.c\:bme280_get_sensor_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_get_sensor_data (uint8_t sensor_comp, struct {\b bme280_data} * comp_data, struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API reads the pressure, temperature and humidity data from the sensor, compensates the data and store it in the {\b bme280_data} structure instance passed by the user. }}\par
{
Definition at line {\b 715} of file {\b bme280.c}.}\par
}
{\xe \v bme280_get_sensor_mode\:bme280.c}
{\xe \v bme280.c\:bme280_get_sensor_mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_get_sensor_mode (uint8_t * sensor_mode, struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API gets the power mode of the sensor. }}\par
{
Definition at line {\b 654} of file {\b bme280.c}.}\par
}
{\xe \v bme280_get_sensor_settings\:bme280.c}
{\xe \v bme280.c\:bme280_get_sensor_settings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_get_sensor_settings (struct {\b bme280_settings} * settings, struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API gets the oversampling, filter and standby duration (normal mode) settings from the sensor. }}\par
{
Definition at line {\b 602} of file {\b bme280.c}.}\par
}
{\xe \v bme280_init\:bme280.c}
{\xe \v bme280.c\:bme280_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_init (struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API is the entry point. It reads the chip-id and calibration data from the sensor. }}\par
{
Definition at line {\b 413} of file {\b bme280.c}.}\par
}
{\xe \v bme280_set_regs\:bme280.c}
{\xe \v bme280.c\:bme280_set_regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_set_regs (uint8_t * reg_addr, const uint8_t * reg_data, uint32_t len, struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API writes the given data to the register address of the sensor. }}\par
{
Definition at line {\b 485} of file {\b bme280.c}.}\par
}
{\xe \v bme280_set_sensor_mode\:bme280.c}
{\xe \v bme280.c\:bme280_set_sensor_mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_set_sensor_mode (uint8_t sensor_mode, struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API sets the power mode of the sensor. }}\par
{
Definition at line {\b 627} of file {\b bme280.c}.}\par
}
{\xe \v bme280_set_sensor_settings\:bme280.c}
{\xe \v bme280.c\:bme280_set_sensor_settings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_set_sensor_settings (uint8_t desired_settings, const struct {\b bme280_settings} * settings, struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API sets the oversampling, filter and standby duration (normal mode) settings in the sensor. }}\par
{
Definition at line {\b 555} of file {\b bme280.c}.}\par
}
{\xe \v bme280_soft_reset\:bme280.c}
{\xe \v bme280.c\:bme280_soft_reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_soft_reset (struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API performs the soft reset of the sensor. }}\par
{
Definition at line {\b 677} of file {\b bme280.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bme280.c\par \pard\plain 
{\tc\tcl2 \v lib/bme280/bme280.c}
{\xe \v lib/bme280/bme280.c}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00038 \par
00042 {\cf21 #include "bme280.h"}\par
00043 \par
00045 {\cf20 /* To identify osr settings selected by user */}\par
00046 {\cf21 #define OVERSAMPLING_SETTINGS    UINT8_C(0x07)}\par
00047 \par
00048 {\cf20 /* To identify filter and standby settings selected by user */}\par
00049 {\cf21 #define FILTER_STANDBY_SETTINGS  UINT8_C(0x18)}\par
00050 \par
00063 {\cf17 static} int8_t put_device_to_sleep({\cf17 struct} bme280_dev *dev);\par
00064 \par
00078 {\cf17 static} int8_t write_power_mode(uint8_t sensor_mode, {\cf17 struct} bme280_dev *dev);\par
00079 \par
00093 {\cf17 static} int8_t null_ptr_check({\cf17 const} {\cf17 struct} bme280_dev *dev);\par
00094 \par
00107 {\cf17 static} {\cf18 void} interleave_reg_addr({\cf17 const} uint8_t *reg_addr, uint8_t *temp_buff, {\cf17 const} uint8_t *reg_data, uint32_t len);\par
00108 \par
00122 {\cf17 static} int8_t get_calib_data({\cf17 struct} bme280_dev *dev);\par
00123 \par
00132 {\cf17 static} {\cf18 void} parse_temp_press_calib_data({\cf17 const} uint8_t *reg_data, {\cf17 struct} bme280_dev *dev);\par
00133 \par
00142 {\cf17 static} {\cf18 void} parse_humidity_calib_data({\cf17 const} uint8_t *reg_data, {\cf17 struct} bme280_dev *dev);\par
00143 \par
00158 {\cf17 static} uint8_t are_settings_changed(uint8_t sub_settings, uint8_t desired_settings);\par
00159 \par
00174 {\cf17 static} int8_t set_osr_humidity_settings({\cf17 const} {\cf17 struct} bme280_settings *settings, {\cf17 struct} bme280_dev *dev);\par
00175 \par
00193 {\cf17 static} int8_t set_osr_settings(uint8_t desired_settings, {\cf17 const} {\cf17 struct} bme280_settings *settings,\par
00194                                {\cf17 struct} bme280_dev *dev);\par
00195 \par
00213 {\cf17 static} int8_t set_osr_press_temp_settings(uint8_t desired_settings,\par
00214                                           {\cf17 const} {\cf17 struct} bme280_settings *settings,\par
00215                                           {\cf17 struct} bme280_dev *dev);\par
00216 \par
00227 {\cf17 static} {\cf18 void} fill_osr_press_settings(uint8_t *reg_data, {\cf17 const} {\cf17 struct} bme280_settings *settings);\par
00228 \par
00239 {\cf17 static} {\cf18 void} fill_osr_temp_settings(uint8_t *reg_data, {\cf17 const} {\cf17 struct} bme280_settings *settings);\par
00240 \par
00257 {\cf17 static} int8_t set_filter_standby_settings(uint8_t desired_settings,\par
00258                                           {\cf17 const} {\cf17 struct} bme280_settings *settings,\par
00259                                           {\cf17 struct} bme280_dev *dev);\par
00260 \par
00271 {\cf17 static} {\cf18 void} fill_filter_settings(uint8_t *reg_data, {\cf17 const} {\cf17 struct} bme280_settings *settings);\par
00272 \par
00283 {\cf17 static} {\cf18 void} fill_standby_settings(uint8_t *reg_data, {\cf17 const} {\cf17 struct} bme280_settings *settings);\par
00284 \par
00295 {\cf17 static} {\cf18 void} parse_device_settings({\cf17 const} uint8_t *reg_data, {\cf17 struct} bme280_settings *settings);\par
00296 \par
00304 {\cf17 static} {\cf18 void} parse_sensor_data({\cf17 const} uint8_t *reg_data, {\cf17 struct} bme280_uncomp_data *uncomp_data);\par
00305 \par
00321 {\cf17 static} int8_t reload_device_settings({\cf17 const} {\cf17 struct} bme280_settings *settings, {\cf17 struct} bme280_dev *dev);\par
00322 \par
00323 {\cf21 #ifdef BME280_DOUBLE_ENABLE}\par
00324 \par
00335 {\cf17 static} {\cf18 double} compensate_pressure({\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
00336                                   {\cf17 const} {\cf17 struct} bme280_calib_data *calib_data);\par
00337 \par
00348 {\cf17 static} {\cf18 double} compensate_humidity({\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
00349                                   {\cf17 const} {\cf17 struct} bme280_calib_data *calib_data);\par
00350 \par
00361 {\cf17 static} {\cf18 double} compensate_temperature({\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
00362                                      {\cf17 struct} bme280_calib_data *calib_data);\par
00363 \par
00364 {\cf21 #else}\par
00365 \par
00376 {\cf17 static} int32_t compensate_temperature({\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
00377                                       {\cf17 struct} bme280_calib_data *calib_data);\par
00378 \par
00389 {\cf17 static} uint32_t compensate_pressure({\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
00390                                     {\cf17 const} {\cf17 struct} bme280_calib_data *calib_data);\par
00391 \par
00402 {\cf17 static} uint32_t compensate_humidity({\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
00403                                     {\cf17 const} {\cf17 struct} bme280_calib_data *calib_data);\par
00404 \par
00405 {\cf21 #endif}\par
00406 \par
00407 {\cf20 /****************** Global Function Definitions *******************************/}\par
00408 \par
00413 int8_t bme280_init({\cf17 struct} bme280_dev *dev)\par
00414 \{\par
00415     int8_t rslt;\par
00416     uint8_t chip_id = 0;\par
00417 \par
00418     {\cf20 /* Read the chip-id of bme280 sensor */}\par
00419     rslt = bme280_get_regs(BME280_REG_CHIP_ID, &chip_id, 1, dev);\par
00420 \par
00421     {\cf20 /* Check for chip id validity */}\par
00422     {\cf19 if} (rslt == BME280_OK)\par
00423     \{\par
00424         {\cf19 if} (chip_id == BME280_CHIP_ID)\par
00425         \{\par
00426             dev->chip_id = chip_id;\par
00427 \par
00428             {\cf20 /* Reset the sensor */}\par
00429             rslt = bme280_soft_reset(dev);\par
00430 \par
00431             {\cf19 if} (rslt == BME280_OK)\par
00432             \{\par
00433                 {\cf20 /* Read the calibration data */}\par
00434                 rslt = get_calib_data(dev);\par
00435             \}\par
00436         \}\par
00437         {\cf19 else}\par
00438         \{\par
00439             rslt = BME280_E_DEV_NOT_FOUND;\par
00440         \}\par
00441     \}\par
00442 \par
00443     {\cf19 return} rslt;\par
00444 \}\par
00445 \par
00449 int8_t bme280_get_regs(uint8_t reg_addr, uint8_t *reg_data, uint32_t len, {\cf17 struct} bme280_dev *dev)\par
00450 \{\par
00451     int8_t rslt;\par
00452 \par
00453     {\cf20 /* Check for null pointer in the device structure */}\par
00454     rslt = null_ptr_check(dev);\par
00455 \par
00456     {\cf19 if} ((rslt == BME280_OK) && (reg_data != NULL))\par
00457     \{\par
00458         {\cf20 /* If interface selected is SPI */}\par
00459         {\cf19 if} (dev->intf != BME280_I2C_INTF)\par
00460         \{\par
00461             reg_addr = reg_addr | 0x80;\par
00462         \}\par
00463 \par
00464         {\cf20 /* Read the data */}\par
00465         dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);\par
00466 \par
00467         {\cf20 /* Check for communication error */}\par
00468         {\cf19 if} (dev->intf_rslt != BME280_INTF_RET_SUCCESS)\par
00469         \{\par
00470             rslt = BME280_E_COMM_FAIL;\par
00471         \}\par
00472     \}\par
00473     {\cf19 else}\par
00474     \{\par
00475         rslt = BME280_E_NULL_PTR;\par
00476     \}\par
00477 \par
00478     {\cf19 return} rslt;\par
00479 \}\par
00480 \par
00485 int8_t bme280_set_regs(uint8_t *reg_addr, {\cf17 const} uint8_t *reg_data, uint32_t len, {\cf17 struct} bme280_dev *dev)\par
00486 \{\par
00487     int8_t rslt;\par
00488     uint8_t temp_buff[20]; {\cf20 /* Typically not to write more than 10 registers */}\par
00489     uint32_t temp_len;\par
00490     uint32_t reg_addr_cnt;\par
00491 \par
00492     {\cf19 if} (len > BME280_MAX_LEN)\par
00493     \{\par
00494         len = BME280_MAX_LEN;\par
00495     \}\par
00496 \par
00497     {\cf20 /* Check for null pointer in the device structure */}\par
00498     rslt = null_ptr_check(dev);\par
00499 \par
00500     {\cf20 /* Check for arguments validity */}\par
00501     {\cf19 if} ((rslt == BME280_OK) && (reg_addr != NULL) && (reg_data != NULL))\par
00502     \{\par
00503         {\cf19 if} (len != 0)\par
00504         \{\par
00505             temp_buff[0] = reg_data[0];\par
00506 \par
00507             {\cf20 /* If interface selected is SPI */}\par
00508             {\cf19 if} (dev->intf != BME280_I2C_INTF)\par
00509             \{\par
00510                 {\cf19 for} (reg_addr_cnt = 0; reg_addr_cnt < len; reg_addr_cnt++)\par
00511                 \{\par
00512                     reg_addr[reg_addr_cnt] = reg_addr[reg_addr_cnt] & 0x7F;\par
00513                 \}\par
00514             \}\par
00515 \par
00516             {\cf20 /* Burst write mode */}\par
00517             {\cf19 if} (len > 1)\par
00518             \{\par
00519                 {\cf20 /* Interleave register address w.r.t data for}\par
00520 {\cf20                  * burst write}\par
00521 {\cf20                  */}\par
00522                 interleave_reg_addr(reg_addr, temp_buff, reg_data, len);\par
00523                 temp_len = ((len * 2) - 1);\par
00524             \}\par
00525             {\cf19 else}\par
00526             \{\par
00527                 temp_len = len;\par
00528             \}\par
00529 \par
00530             dev->intf_rslt = dev->write(reg_addr[0], temp_buff, temp_len, dev->intf_ptr);\par
00531 \par
00532             {\cf20 /* Check for communication error */}\par
00533             {\cf19 if} (dev->intf_rslt != BME280_INTF_RET_SUCCESS)\par
00534             \{\par
00535                 rslt = BME280_E_COMM_FAIL;\par
00536             \}\par
00537         \}\par
00538         {\cf19 else}\par
00539         \{\par
00540             rslt = BME280_E_INVALID_LEN;\par
00541         \}\par
00542     \}\par
00543     {\cf19 else}\par
00544     \{\par
00545         rslt = BME280_E_NULL_PTR;\par
00546     \}\par
00547 \par
00548     {\cf19 return} rslt;\par
00549 \}\par
00550 \par
00555 int8_t bme280_set_sensor_settings(uint8_t desired_settings,\par
00556                                   {\cf17 const} {\cf17 struct} bme280_settings *settings,\par
00557                                   {\cf17 struct} bme280_dev *dev)\par
00558 \{\par
00559     int8_t rslt;\par
00560     uint8_t sensor_mode;\par
00561 \par
00562     {\cf19 if} (settings != NULL)\par
00563     \{\par
00564         rslt = bme280_get_sensor_mode(&sensor_mode, dev);\par
00565 \par
00566         {\cf19 if} ((rslt == BME280_OK) && (sensor_mode != BME280_POWERMODE_SLEEP))\par
00567         \{\par
00568             rslt = put_device_to_sleep(dev);\par
00569         \}\par
00570 \par
00571         {\cf19 if} (rslt == BME280_OK)\par
00572         \{\par
00573             {\cf20 /* Check if user wants to change oversampling}\par
00574 {\cf20              * settings}\par
00575 {\cf20              */}\par
00576             {\cf19 if} (are_settings_changed(OVERSAMPLING_SETTINGS, desired_settings))\par
00577             \{\par
00578                 rslt = set_osr_settings(desired_settings, settings, dev);\par
00579             \}\par
00580 \par
00581             {\cf20 /* Check if user wants to change filter and/or}\par
00582 {\cf20              * standby settings}\par
00583 {\cf20              */}\par
00584             {\cf19 if} ((rslt == BME280_OK) && are_settings_changed(FILTER_STANDBY_SETTINGS, desired_settings))\par
00585             \{\par
00586                 rslt = set_filter_standby_settings(desired_settings, settings, dev);\par
00587             \}\par
00588         \}\par
00589     \}\par
00590     {\cf19 else}\par
00591     \{\par
00592         rslt = BME280_E_NULL_PTR;\par
00593     \}\par
00594 \par
00595     {\cf19 return} rslt;\par
00596 \}\par
00597 \par
00602 int8_t bme280_get_sensor_settings({\cf17 struct} bme280_settings *settings, {\cf17 struct} bme280_dev *dev)\par
00603 \{\par
00604     int8_t rslt;\par
00605     uint8_t reg_data[4];\par
00606 \par
00607     {\cf19 if} (settings != NULL)\par
00608     \{\par
00609         rslt = bme280_get_regs(BME280_REG_CTRL_HUM, reg_data, 4, dev);\par
00610 \par
00611         {\cf19 if} (rslt == BME280_OK)\par
00612         \{\par
00613             parse_device_settings(reg_data, settings);\par
00614         \}\par
00615     \}\par
00616     {\cf19 else}\par
00617     \{\par
00618         rslt = BME280_E_NULL_PTR;\par
00619     \}\par
00620 \par
00621     {\cf19 return} rslt;\par
00622 \}\par
00623 \par
00627 int8_t bme280_set_sensor_mode(uint8_t sensor_mode, {\cf17 struct} bme280_dev *dev)\par
00628 \{\par
00629     int8_t rslt;\par
00630     uint8_t last_set_mode;\par
00631 \par
00632     rslt = bme280_get_sensor_mode(&last_set_mode, dev);\par
00633 \par
00634     {\cf20 /* If the sensor is not in sleep mode put the device to sleep}\par
00635 {\cf20      * mode}\par
00636 {\cf20      */}\par
00637     {\cf19 if} ((rslt == BME280_OK) && (last_set_mode != BME280_POWERMODE_SLEEP))\par
00638     \{\par
00639         rslt = put_device_to_sleep(dev);\par
00640     \}\par
00641 \par
00642     {\cf20 /* Set the power mode */}\par
00643     {\cf19 if} (rslt == BME280_OK)\par
00644     \{\par
00645         rslt = write_power_mode(sensor_mode, dev);\par
00646     \}\par
00647 \par
00648     {\cf19 return} rslt;\par
00649 \}\par
00650 \par
00654 int8_t bme280_get_sensor_mode(uint8_t *sensor_mode, {\cf17 struct} bme280_dev *dev)\par
00655 \{\par
00656     int8_t rslt;\par
00657 \par
00658     {\cf19 if} (sensor_mode != NULL)\par
00659     \{\par
00660         {\cf20 /* Read the power mode register */}\par
00661         rslt = bme280_get_regs(BME280_REG_PWR_CTRL, sensor_mode, 1, dev);\par
00662 \par
00663         {\cf20 /* Assign the power mode to variable */}\par
00664         *sensor_mode = BME280_GET_BITS_POS_0(*sensor_mode, BME280_SENSOR_MODE);\par
00665     \}\par
00666     {\cf19 else}\par
00667     \{\par
00668         rslt = BME280_E_NULL_PTR;\par
00669     \}\par
00670 \par
00671     {\cf19 return} rslt;\par
00672 \}\par
00673 \par
00677 int8_t bme280_soft_reset({\cf17 struct} bme280_dev *dev)\par
00678 \{\par
00679     int8_t rslt;\par
00680     uint8_t reg_addr = BME280_REG_RESET;\par
00681     uint8_t status_reg = 0;\par
00682     uint8_t try_run = 5;\par
00683 \par
00684     {\cf20 /* 0xB6 is the soft reset command */}\par
00685     uint8_t soft_rst_cmd = BME280_SOFT_RESET_COMMAND;\par
00686 \par
00687     {\cf20 /* Write the soft reset command in the sensor */}\par
00688     rslt = bme280_set_regs(&reg_addr, &soft_rst_cmd, 1, dev);\par
00689 \par
00690     {\cf19 if} (rslt == BME280_OK)\par
00691     \{\par
00692         {\cf20 /* If NVM not copied yet, Wait for NVM to copy */}\par
00693         {\cf19 do}\par
00694         \{\par
00695             {\cf20 /* As per data sheet - Table 1, startup time is 2 ms. */}\par
00696             dev->delay_us(BME280_STARTUP_DELAY, dev->intf_ptr);\par
00697             rslt = bme280_get_regs(BME280_REG_STATUS, &status_reg, 1, dev);\par
00698 \par
00699         \} {\cf19 while} ((rslt == BME280_OK) && (try_run--) && (status_reg & BME280_STATUS_IM_UPDATE));\par
00700 \par
00701         {\cf19 if} (status_reg & BME280_STATUS_IM_UPDATE)\par
00702         \{\par
00703             rslt = BME280_E_NVM_COPY_FAILED;\par
00704         \}\par
00705     \}\par
00706 \par
00707     {\cf19 return} rslt;\par
00708 \}\par
00709 \par
00715 int8_t bme280_get_sensor_data(uint8_t sensor_comp, {\cf17 struct} bme280_data *comp_data, {\cf17 struct} bme280_dev *dev)\par
00716 \{\par
00717     int8_t rslt;\par
00718 \par
00719     {\cf20 /* Array to store the pressure, temperature and humidity data read from}\par
00720 {\cf20      * the sensor}\par
00721 {\cf20      */}\par
00722     uint8_t reg_data[BME280_LEN_P_T_H_DATA] = \{ 0 \};\par
00723     {\cf17 struct }bme280_uncomp_data uncomp_data = \{ 0 \};\par
00724 \par
00725     {\cf19 if} (comp_data != NULL)\par
00726     \{\par
00727         {\cf20 /* Read the pressure and temperature data from the sensor */}\par
00728         rslt = bme280_get_regs(BME280_REG_DATA, reg_data, BME280_LEN_P_T_H_DATA, dev);\par
00729 \par
00730         {\cf19 if} (rslt == BME280_OK)\par
00731         \{\par
00732             {\cf20 /* Parse the read data from the sensor */}\par
00733             parse_sensor_data(reg_data, &uncomp_data);\par
00734 \par
00735             {\cf20 /* Compensate the pressure and/or temperature and/or}\par
00736 {\cf20              * humidity data from the sensor}\par
00737 {\cf20              */}\par
00738             rslt = bme280_compensate_data(sensor_comp, &uncomp_data, comp_data, &dev->calib_data);\par
00739         \}\par
00740     \}\par
00741     {\cf19 else}\par
00742     \{\par
00743         rslt = BME280_E_NULL_PTR;\par
00744     \}\par
00745 \par
00746     {\cf19 return} rslt;\par
00747 \}\par
00748 \par
00754 int8_t bme280_compensate_data(uint8_t sensor_comp,\par
00755                               {\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
00756                               {\cf17 struct} bme280_data *comp_data,\par
00757                               {\cf17 struct} bme280_calib_data *calib_data)\par
00758 \{\par
00759     int8_t rslt = BME280_OK;\par
00760 \par
00761     {\cf19 if} ((uncomp_data != NULL) && (comp_data != NULL) && (calib_data != NULL))\par
00762     \{\par
00763         {\cf20 /* Initialize to zero */}\par
00764         comp_data->temperature = 0;\par
00765         comp_data->pressure = 0;\par
00766         comp_data->humidity = 0;\par
00767 \par
00768         {\cf20 /* If pressure or temperature component is selected */}\par
00769         {\cf19 if} (sensor_comp & (BME280_PRESS | BME280_TEMP | BME280_HUM))\par
00770         \{\par
00771             {\cf20 /* Compensate the temperature data */}\par
00772             comp_data->temperature = compensate_temperature(uncomp_data, calib_data);\par
00773         \}\par
00774 \par
00775         {\cf19 if} (sensor_comp & BME280_PRESS)\par
00776         \{\par
00777             {\cf20 /* Compensate the pressure data */}\par
00778             comp_data->pressure = compensate_pressure(uncomp_data, calib_data);\par
00779         \}\par
00780 \par
00781         {\cf19 if} (sensor_comp & BME280_HUM)\par
00782         \{\par
00783             {\cf20 /* Compensate the humidity data */}\par
00784             comp_data->humidity = compensate_humidity(uncomp_data, calib_data);\par
00785         \}\par
00786     \}\par
00787     {\cf19 else}\par
00788     \{\par
00789         rslt = BME280_E_NULL_PTR;\par
00790     \}\par
00791 \par
00792     {\cf19 return} rslt;\par
00793 \}\par
00794 \par
00799 int8_t bme280_cal_meas_delay(uint32_t *max_delay, {\cf17 const} {\cf17 struct} bme280_settings *settings)\par
00800 \{\par
00801     int8_t rslt = BME280_OK;\par
00802     uint8_t temp_osr;\par
00803     uint8_t pres_osr;\par
00804     uint8_t hum_osr;\par
00805 \par
00806     {\cf20 /* Array to map OSR config register value to actual OSR */}\par
00807     uint8_t osr_sett_to_act_osr[] = \{ 0, 1, 2, 4, 8, 16 \};\par
00808 \par
00809     {\cf19 if} ((settings != NULL) && (max_delay != NULL))\par
00810     \{\par
00811         {\cf20 /* Mapping osr settings to the actual osr values e.g. 0b101 -> osr X16 */}\par
00812         {\cf19 if} (settings->osr_t <= BME280_OVERSAMPLING_16X)\par
00813         \{\par
00814             temp_osr = osr_sett_to_act_osr[settings->osr_t];\par
00815         \}\par
00816         {\cf19 else}\par
00817         \{\par
00818             temp_osr = BME280_OVERSAMPLING_MAX;\par
00819         \}\par
00820 \par
00821         {\cf19 if} (settings->osr_p <= BME280_OVERSAMPLING_16X)\par
00822         \{\par
00823             pres_osr = osr_sett_to_act_osr[settings->osr_p];\par
00824         \}\par
00825         {\cf19 else}\par
00826         \{\par
00827             pres_osr = BME280_OVERSAMPLING_MAX;\par
00828         \}\par
00829 \par
00830         {\cf19 if} (settings->osr_h <= BME280_OVERSAMPLING_16X)\par
00831         \{\par
00832             hum_osr = osr_sett_to_act_osr[settings->osr_h];\par
00833         \}\par
00834         {\cf19 else}\par
00835         \{\par
00836             hum_osr = BME280_OVERSAMPLING_MAX;\par
00837         \}\par
00838 \par
00839         (*max_delay) =\par
00840             (uint32_t)((BME280_MEAS_OFFSET + (BME280_MEAS_DUR * temp_osr) +\par
00841                         ((BME280_MEAS_DUR * pres_osr) + BME280_PRES_HUM_MEAS_OFFSET) +\par
00842                         ((BME280_MEAS_DUR * hum_osr) + BME280_PRES_HUM_MEAS_OFFSET)));\par
00843     \}\par
00844     {\cf19 else}\par
00845     \{\par
00846         rslt = BME280_E_NULL_PTR;\par
00847     \}\par
00848 \par
00849     {\cf19 return} rslt;\par
00850 \}\par
00851 \par
00852 {\cf20 /****************************************************************************/}\par
00854 \par
00859 {\cf17 static} int8_t set_osr_settings(uint8_t desired_settings, {\cf17 const} {\cf17 struct} bme280_settings *settings, {\cf17 struct} bme280_dev *dev)\par
00860 \{\par
00861     int8_t rslt = BME280_W_INVALID_OSR_MACRO;\par
00862 \par
00863     {\cf19 if} (desired_settings & BME280_SEL_OSR_HUM)\par
00864     \{\par
00865         rslt = set_osr_humidity_settings(settings, dev);\par
00866     \}\par
00867 \par
00868     {\cf19 if} (desired_settings & (BME280_SEL_OSR_PRESS | BME280_SEL_OSR_TEMP))\par
00869     \{\par
00870         rslt = set_osr_press_temp_settings(desired_settings, settings, dev);\par
00871     \}\par
00872 \par
00873     {\cf19 return} rslt;\par
00874 \}\par
00875 \par
00879 {\cf17 static} int8_t set_osr_humidity_settings({\cf17 const} {\cf17 struct} bme280_settings *settings, {\cf17 struct} bme280_dev *dev)\par
00880 \{\par
00881     int8_t rslt;\par
00882     uint8_t ctrl_hum;\par
00883     uint8_t ctrl_meas;\par
00884     uint8_t reg_addr = BME280_REG_CTRL_HUM;\par
00885 \par
00886     ctrl_hum = settings->osr_h & BME280_CTRL_HUM_MSK;\par
00887 \par
00888     {\cf20 /* Write the humidity control value in the register */}\par
00889     rslt = bme280_set_regs(&reg_addr, &ctrl_hum, 1, dev);\par
00890 \par
00891     {\cf20 /* Humidity related changes will be only effective after a}\par
00892 {\cf20      * write operation to ctrl_meas register}\par
00893 {\cf20      */}\par
00894     {\cf19 if} (rslt == BME280_OK)\par
00895     \{\par
00896         reg_addr = BME280_REG_CTRL_MEAS;\par
00897         rslt = bme280_get_regs(reg_addr, &ctrl_meas, 1, dev);\par
00898 \par
00899         {\cf19 if} (rslt == BME280_OK)\par
00900         \{\par
00901             rslt = bme280_set_regs(&reg_addr, &ctrl_meas, 1, dev);\par
00902         \}\par
00903     \}\par
00904 \par
00905     {\cf19 return} rslt;\par
00906 \}\par
00907 \par
00912 {\cf17 static} int8_t set_osr_press_temp_settings(uint8_t desired_settings,\par
00913                                           {\cf17 const} {\cf17 struct} bme280_settings *settings,\par
00914                                           {\cf17 struct} bme280_dev *dev)\par
00915 \{\par
00916     int8_t rslt;\par
00917     uint8_t reg_addr = BME280_REG_CTRL_MEAS;\par
00918     uint8_t reg_data;\par
00919 \par
00920     rslt = bme280_get_regs(reg_addr, &reg_data, 1, dev);\par
00921 \par
00922     {\cf19 if} (rslt == BME280_OK)\par
00923     \{\par
00924         {\cf19 if} (desired_settings & BME280_SEL_OSR_PRESS)\par
00925         \{\par
00926             fill_osr_press_settings(&reg_data, settings);\par
00927         \}\par
00928 \par
00929         {\cf19 if} (desired_settings & BME280_SEL_OSR_TEMP)\par
00930         \{\par
00931             fill_osr_temp_settings(&reg_data, settings);\par
00932         \}\par
00933 \par
00934         {\cf20 /* Write the oversampling settings in the register */}\par
00935         rslt = bme280_set_regs(&reg_addr, &reg_data, 1, dev);\par
00936     \}\par
00937 \par
00938     {\cf19 return} rslt;\par
00939 \}\par
00940 \par
00945 {\cf17 static} int8_t set_filter_standby_settings(uint8_t desired_settings,\par
00946                                           {\cf17 const} {\cf17 struct} bme280_settings *settings,\par
00947                                           {\cf17 struct} bme280_dev *dev)\par
00948 \{\par
00949     int8_t rslt;\par
00950     uint8_t reg_addr = BME280_REG_CONFIG;\par
00951     uint8_t reg_data;\par
00952 \par
00953     rslt = bme280_get_regs(reg_addr, &reg_data, 1, dev);\par
00954 \par
00955     {\cf19 if} (rslt == BME280_OK)\par
00956     \{\par
00957         {\cf19 if} (desired_settings & BME280_SEL_FILTER)\par
00958         \{\par
00959             fill_filter_settings(&reg_data, settings);\par
00960         \}\par
00961 \par
00962         {\cf19 if} (desired_settings & BME280_SEL_STANDBY)\par
00963         \{\par
00964             fill_standby_settings(&reg_data, settings);\par
00965         \}\par
00966 \par
00967         {\cf20 /* Write the oversampling settings in the register */}\par
00968         rslt = bme280_set_regs(&reg_addr, &reg_data, 1, dev);\par
00969     \}\par
00970 \par
00971     {\cf19 return} rslt;\par
00972 \}\par
00973 \par
00978 {\cf17 static} {\cf18 void} fill_filter_settings(uint8_t *reg_data, {\cf17 const} {\cf17 struct} bme280_settings *settings)\par
00979 \{\par
00980     *reg_data = BME280_SET_BITS(*reg_data, BME280_FILTER, settings->filter);\par
00981 \}\par
00982 \par
00987 {\cf17 static} {\cf18 void} fill_standby_settings(uint8_t *reg_data, {\cf17 const} {\cf17 struct} bme280_settings *settings)\par
00988 \{\par
00989     *reg_data = BME280_SET_BITS(*reg_data, BME280_STANDBY, settings->standby_time);\par
00990 \}\par
00991 \par
00996 {\cf17 static} {\cf18 void} fill_osr_press_settings(uint8_t *reg_data, {\cf17 const} {\cf17 struct} bme280_settings *settings)\par
00997 \{\par
00998     *reg_data = BME280_SET_BITS(*reg_data, BME280_CTRL_PRESS, settings->osr_p);\par
00999 \}\par
01000 \par
01005 {\cf17 static} {\cf18 void} fill_osr_temp_settings(uint8_t *reg_data, {\cf17 const} {\cf17 struct} bme280_settings *settings)\par
01006 \{\par
01007     *reg_data = BME280_SET_BITS(*reg_data, BME280_CTRL_TEMP, settings->osr_t);\par
01008 \}\par
01009 \par
01015 {\cf17 static} {\cf18 void} parse_device_settings({\cf17 const} uint8_t *reg_data, {\cf17 struct} bme280_settings *settings)\par
01016 \{\par
01017     settings->osr_h = BME280_GET_BITS_POS_0(reg_data[0], BME280_CTRL_HUM);\par
01018     settings->osr_p = BME280_GET_BITS(reg_data[2], BME280_CTRL_PRESS);\par
01019     settings->osr_t = BME280_GET_BITS(reg_data[2], BME280_CTRL_TEMP);\par
01020     settings->filter = BME280_GET_BITS(reg_data[3], BME280_FILTER);\par
01021     settings->standby_time = BME280_GET_BITS(reg_data[3], BME280_STANDBY);\par
01022 \}\par
01023 \par
01028 {\cf17 static} {\cf18 void} parse_sensor_data({\cf17 const} uint8_t *reg_data, {\cf17 struct} bme280_uncomp_data *uncomp_data)\par
01029 \{\par
01030     {\cf20 /* Variables to store the sensor data */}\par
01031     uint32_t data_xlsb;\par
01032     uint32_t data_lsb;\par
01033     uint32_t data_msb;\par
01034 \par
01035     {\cf20 /* Store the parsed register values for pressure data */}\par
01036     data_msb = (uint32_t)reg_data[0] << BME280_12_BIT_SHIFT;\par
01037     data_lsb = (uint32_t)reg_data[1] << BME280_4_BIT_SHIFT;\par
01038     data_xlsb = (uint32_t)reg_data[2] >> BME280_4_BIT_SHIFT;\par
01039     uncomp_data->pressure = data_msb | data_lsb | data_xlsb;\par
01040 \par
01041     {\cf20 /* Store the parsed register values for temperature data */}\par
01042     data_msb = (uint32_t)reg_data[3] << BME280_12_BIT_SHIFT;\par
01043     data_lsb = (uint32_t)reg_data[4] << BME280_4_BIT_SHIFT;\par
01044     data_xlsb = (uint32_t)reg_data[5] >> BME280_4_BIT_SHIFT;\par
01045     uncomp_data->temperature = data_msb | data_lsb | data_xlsb;\par
01046 \par
01047     {\cf20 /* Store the parsed register values for humidity data */}\par
01048     data_msb = (uint32_t)reg_data[6] << BME280_8_BIT_SHIFT;\par
01049     data_lsb = (uint32_t)reg_data[7];\par
01050     uncomp_data->humidity = data_msb | data_lsb;\par
01051 \}\par
01052 \par
01056 {\cf17 static} int8_t write_power_mode(uint8_t sensor_mode, {\cf17 struct} bme280_dev *dev)\par
01057 \{\par
01058     int8_t rslt;\par
01059     uint8_t reg_addr = BME280_REG_PWR_CTRL;\par
01060 \par
01061     {\cf20 /* Variable to store the value read from power mode register */}\par
01062     uint8_t sensor_mode_reg_val;\par
01063 \par
01064     {\cf20 /* Read the power mode register */}\par
01065     rslt = bme280_get_regs(reg_addr, &sensor_mode_reg_val, 1, dev);\par
01066 \par
01067     {\cf20 /* Set the power mode */}\par
01068     {\cf19 if} (rslt == BME280_OK)\par
01069     \{\par
01070         sensor_mode_reg_val = BME280_SET_BITS_POS_0(sensor_mode_reg_val, BME280_SENSOR_MODE, sensor_mode);\par
01071 \par
01072         {\cf20 /* Write the power mode in the register */}\par
01073         rslt = bme280_set_regs(&reg_addr, &sensor_mode_reg_val, 1, dev);\par
01074     \}\par
01075 \par
01076     {\cf19 return} rslt;\par
01077 \}\par
01078 \par
01082 {\cf17 static} int8_t put_device_to_sleep({\cf17 struct} bme280_dev *dev)\par
01083 \{\par
01084     int8_t rslt;\par
01085     uint8_t reg_data[4];\par
01086     {\cf17 struct }bme280_settings settings;\par
01087 \par
01088     rslt = bme280_get_regs(BME280_REG_CTRL_HUM, reg_data, 4, dev);\par
01089 \par
01090     {\cf19 if} (rslt == BME280_OK)\par
01091     \{\par
01092         parse_device_settings(reg_data, &settings);\par
01093         rslt = bme280_soft_reset(dev);\par
01094 \par
01095         {\cf19 if} (rslt == BME280_OK)\par
01096         \{\par
01097             rslt = reload_device_settings(&settings, dev);\par
01098         \}\par
01099     \}\par
01100 \par
01101     {\cf19 return} rslt;\par
01102 \}\par
01103 \par
01108 {\cf17 static} int8_t reload_device_settings({\cf17 const} {\cf17 struct} bme280_settings *settings, {\cf17 struct} bme280_dev *dev)\par
01109 \{\par
01110     int8_t rslt;\par
01111 \par
01112     rslt = set_osr_settings(BME280_SEL_ALL_SETTINGS, settings, dev);\par
01113 \par
01114     {\cf19 if} (rslt == BME280_OK)\par
01115     \{\par
01116         rslt = set_filter_standby_settings(BME280_SEL_ALL_SETTINGS, settings, dev);\par
01117     \}\par
01118 \par
01119     {\cf19 return} rslt;\par
01120 \}\par
01121 \par
01122 {\cf21 #ifdef BME280_DOUBLE_ENABLE}\par
01123 \par
01128 {\cf17 static} {\cf18 double} compensate_temperature({\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data, {\cf17 struct} bme280_calib_data *calib_data)\par
01129 \{\par
01130     {\cf18 double} var1;\par
01131     {\cf18 double} var2;\par
01132     {\cf18 double} temperature;\par
01133     {\cf18 double} temperature_min = -40;\par
01134     {\cf18 double} temperature_max = 85;\par
01135 \par
01136     var1 = (((double)uncomp_data->temperature) / 16384.0 - ((double)calib_data->dig_t1) / 1024.0);\par
01137     var1 = var1 * ((double)calib_data->dig_t2);\par
01138     var2 = (((double)uncomp_data->temperature) / 131072.0 - ((double)calib_data->dig_t1) / 8192.0);\par
01139     var2 = (var2 * var2) * (({\cf18 double})calib_data->dig_t3);\par
01140     calib_data->t_fine = (int32_t)(var1 + var2);\par
01141     temperature = (var1 + var2) / 5120.0;\par
01142 \par
01143     {\cf19 if} (temperature < temperature_min)\par
01144     \{\par
01145         temperature = temperature_min;\par
01146     \}\par
01147     {\cf19 else} {\cf19 if} (temperature > temperature_max)\par
01148     \{\par
01149         temperature = temperature_max;\par
01150     \}\par
01151 \par
01152     {\cf19 return} temperature;\par
01153 \}\par
01154 \par
01159 {\cf17 static} {\cf18 double} compensate_pressure({\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
01160                                   {\cf17 const} {\cf17 struct} bme280_calib_data *calib_data)\par
01161 \{\par
01162     {\cf18 double} var1;\par
01163     {\cf18 double} var2;\par
01164     {\cf18 double} var3;\par
01165     {\cf18 double} pressure;\par
01166     {\cf18 double} pressure_min = 30000.0;\par
01167     {\cf18 double} pressure_max = 110000.0;\par
01168 \par
01169     var1 = ((double)calib_data->t_fine / 2.0) - 64000.0;\par
01170     var2 = var1 * var1 * ((double)calib_data->dig_p6) / 32768.0;\par
01171     var2 = var2 + var1 * ((double)calib_data->dig_p5) * 2.0;\par
01172     var2 = (var2 / 4.0) + ((({\cf18 double})calib_data->dig_p4) * 65536.0);\par
01173     var3 = ((double)calib_data->dig_p3) * var1 * var1 / 524288.0;\par
01174     var1 = (var3 + ((double)calib_data->dig_p2) * var1) / 524288.0;\par
01175     var1 = (1.0 + var1 / 32768.0) * (({\cf18 double})calib_data->dig_p1);\par
01176 \par
01177     {\cf20 /* Avoid exception caused by division by zero */}\par
01178     {\cf19 if} (var1 > (0.0))\par
01179     \{\par
01180         pressure = 1048576.0 - (double) uncomp_data->pressure;\par
01181         pressure = (pressure - (var2 / 4096.0)) * 6250.0 / var1;\par
01182         var1 = ((double)calib_data->dig_p9) * pressure * pressure / 2147483648.0;\par
01183         var2 = pressure * ((double)calib_data->dig_p8) / 32768.0;\par
01184         pressure = pressure + (var1 + var2 + ((double)calib_data->dig_p7)) / 16.0;\par
01185 \par
01186         {\cf19 if} (pressure < pressure_min)\par
01187         \{\par
01188             pressure = pressure_min;\par
01189         \}\par
01190         {\cf19 else} {\cf19 if} (pressure > pressure_max)\par
01191         \{\par
01192             pressure = pressure_max;\par
01193         \}\par
01194     \}\par
01195     {\cf19 else} {\cf20 /* Invalid case */}\par
01196     \{\par
01197         pressure = pressure_min;\par
01198     \}\par
01199 \par
01200     {\cf19 return} pressure;\par
01201 \}\par
01202 \par
01207 {\cf17 static} {\cf18 double} compensate_humidity({\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
01208                                   {\cf17 const} {\cf17 struct} bme280_calib_data *calib_data)\par
01209 \{\par
01210     {\cf18 double} humidity;\par
01211     {\cf18 double} humidity_min = 0.0;\par
01212     {\cf18 double} humidity_max = 100.0;\par
01213     {\cf18 double} var1;\par
01214     {\cf18 double} var2;\par
01215     {\cf18 double} var3;\par
01216     {\cf18 double} var4;\par
01217     {\cf18 double} var5;\par
01218     {\cf18 double} var6;\par
01219 \par
01220     var1 = ((double)calib_data->t_fine) - 76800.0;\par
01221     var2 = (((double)calib_data->dig_h4) * 64.0 + (((double)calib_data->dig_h5) / 16384.0) * var1);\par
01222     var3 = uncomp_data->humidity - var2;\par
01223     var4 = ((double)calib_data->dig_h2) / 65536.0;\par
01224     var5 = (1.0 + (((double)calib_data->dig_h3) / 67108864.0) * var1);\par
01225     var6 = 1.0 + (((double)calib_data->dig_h6) / 67108864.0) * var1 * var5;\par
01226     var6 = var3 * var4 * (var5 * var6);\par
01227     humidity = var6 * (1.0 - ((double)calib_data->dig_h1) * var6 / 524288.0);\par
01228 \par
01229     {\cf19 if} (humidity > humidity_max)\par
01230     \{\par
01231         humidity = humidity_max;\par
01232     \}\par
01233     {\cf19 else} {\cf19 if} (humidity < humidity_min)\par
01234     \{\par
01235         humidity = humidity_min;\par
01236     \}\par
01237 \par
01238     {\cf19 return} humidity;\par
01239 \}\par
01240 \par
01241 {\cf21 #else}\par
01242 \par
01247 {\cf17 static} int32_t compensate_temperature({\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
01248                                       {\cf17 struct} bme280_calib_data *calib_data)\par
01249 \{\par
01250     int32_t var1;\par
01251     int32_t var2;\par
01252     int32_t temperature;\par
01253     int32_t temperature_min = -4000;\par
01254     int32_t temperature_max = 8500;\par
01255 \par
01256     var1 = (int32_t)((uncomp_data->temperature / 8) - ((int32_t)calib_data->dig_t1 * 2));\par
01257     var1 = (var1 * ((int32_t)calib_data->dig_t2)) / 2048;\par
01258     var2 = (int32_t)((uncomp_data->temperature / 16) - ((int32_t)calib_data->dig_t1));\par
01259     var2 = (((var2 * var2) / 4096) * ((int32_t)calib_data->dig_t3)) / 16384;\par
01260     calib_data->t_fine = var1 + var2;\par
01261     temperature = (calib_data->t_fine * 5 + 128) / 256;\par
01262 \par
01263     {\cf19 if} (temperature < temperature_min)\par
01264     \{\par
01265         temperature = temperature_min;\par
01266     \}\par
01267     {\cf19 else} {\cf19 if} (temperature > temperature_max)\par
01268     \{\par
01269         temperature = temperature_max;\par
01270     \}\par
01271 \par
01272     {\cf19 return} temperature;\par
01273 \}\par
01274 {\cf21 #ifndef BME280_32BIT_ENABLE }{\cf20 /* 64 bit compensation for pressure data */}{\cf21 }\par
01275 \par
01281 {\cf17 static} uint32_t compensate_pressure({\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
01282                                     {\cf17 const} {\cf17 struct} bme280_calib_data *calib_data)\par
01283 \{\par
01284     int64_t var1;\par
01285     int64_t var2;\par
01286     int64_t var3;\par
01287     int64_t var4;\par
01288     uint32_t pressure;\par
01289     uint32_t pressure_min = 3000000;\par
01290     uint32_t pressure_max = 11000000;\par
01291 \par
01292     var1 = ((int64_t)calib_data->t_fine) - 128000;\par
01293     var2 = var1 * var1 * (int64_t)calib_data->dig_p6;\par
01294     var2 = var2 + ((var1 * (int64_t)calib_data->dig_p5) * 131072);\par
01295     var2 = var2 + (((int64_t)calib_data->dig_p4) * 34359738368);\par
01296     var1 = ((var1 * var1 * (int64_t)calib_data->dig_p3) / 256) + ((var1 * ((int64_t)calib_data->dig_p2) * 4096));\par
01297     var3 = ((int64_t)1) * 140737488355328;\par
01298     var1 = (var3 + var1) * ((int64_t)calib_data->dig_p1) / 8589934592;\par
01299 \par
01300     {\cf20 /* To avoid divide by zero exception */}\par
01301     {\cf19 if} (var1 != 0)\par
01302     \{\par
01303         var4 = 1048576 - uncomp_data->pressure;\par
01304         var4 = (((var4 * INT64_C(2147483648)) - var2) * 3125) / var1;\par
01305         var1 = (((int64_t)calib_data->dig_p9) * (var4 / 8192) * (var4 / 8192)) / 33554432;\par
01306         var2 = (((int64_t)calib_data->dig_p8) * var4) / 524288;\par
01307         var4 = ((var4 + var1 + var2) / 256) + (((int64_t)calib_data->dig_p7) * 16);\par
01308         pressure = (uint32_t)(((var4 / 2) * 100) / 128);\par
01309 \par
01310         {\cf19 if} (pressure < pressure_min)\par
01311         \{\par
01312             pressure = pressure_min;\par
01313         \}\par
01314         {\cf19 else} {\cf19 if} (pressure > pressure_max)\par
01315         \{\par
01316             pressure = pressure_max;\par
01317         \}\par
01318     \}\par
01319     {\cf19 else}\par
01320     \{\par
01321         pressure = pressure_min;\par
01322     \}\par
01323 \par
01324     {\cf19 return} pressure;\par
01325 \}\par
01326 {\cf21 #else }{\cf20 /* 32 bit compensation for pressure data */}{\cf21 }\par
01327 \par
01332 {\cf17 static} uint32_t compensate_pressure({\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
01333                                     {\cf17 const} {\cf17 struct} bme280_calib_data *calib_data)\par
01334 \{\par
01335     int32_t var1;\par
01336     int32_t var2;\par
01337     int32_t var3;\par
01338     int32_t var4;\par
01339     uint32_t var5;\par
01340     uint32_t pressure;\par
01341     uint32_t pressure_min = 30000;\par
01342     uint32_t pressure_max = 110000;\par
01343 \par
01344     var1 = (((int32_t)calib_data->t_fine) / 2) - (int32_t)64000;\par
01345     var2 = (((var1 / 4) * (var1 / 4)) / 2048) * ((int32_t)calib_data->dig_p6);\par
01346     var2 = var2 + ((var1 * ((int32_t)calib_data->dig_p5)) * 2);\par
01347     var2 = (var2 / 4) + (((int32_t)calib_data->dig_p4) * 65536);\par
01348     var3 = (calib_data->dig_p3 * (((var1 / 4) * (var1 / 4)) / 8192)) / 8;\par
01349     var4 = (((int32_t)calib_data->dig_p2) * var1) / 2;\par
01350     var1 = (var3 + var4) / 262144;\par
01351     var1 = (((32768 + var1)) * ((int32_t)calib_data->dig_p1)) / 32768;\par
01352 \par
01353     {\cf20 /* Avoid exception caused by division by zero */}\par
01354     {\cf19 if} (var1)\par
01355     \{\par
01356         var5 = (uint32_t)((uint32_t)1048576) - uncomp_data->pressure;\par
01357         pressure = ((uint32_t)(var5 - (uint32_t)(var2 / 4096))) * 3125;\par
01358 \par
01359         {\cf19 if} (pressure < 0x80000000)\par
01360         \{\par
01361             pressure = (pressure << 1) / ((uint32_t)var1);\par
01362         \}\par
01363         {\cf19 else}\par
01364         \{\par
01365             pressure = (pressure / (uint32_t)var1) * 2;\par
01366         \}\par
01367 \par
01368         var1 = (((int32_t)calib_data->dig_p9) * ((int32_t)(((pressure / 8) * (pressure / 8)) / 8192))) / 4096;\par
01369         var2 = (((int32_t)(pressure / 4)) * ((int32_t)calib_data->dig_p8)) / 8192;\par
01370         pressure = (uint32_t)((int32_t)pressure + ((var1 + var2 + calib_data->dig_p7) / 16));\par
01371 \par
01372         {\cf19 if} (pressure < pressure_min)\par
01373         \{\par
01374             pressure = pressure_min;\par
01375         \}\par
01376         {\cf19 else} {\cf19 if} (pressure > pressure_max)\par
01377         \{\par
01378             pressure = pressure_max;\par
01379         \}\par
01380     \}\par
01381     {\cf19 else}\par
01382     \{\par
01383         pressure = pressure_min;\par
01384     \}\par
01385 \par
01386     {\cf19 return} pressure;\par
01387 \}\par
01388 {\cf21 #endif}\par
01389 \par
01394 {\cf17 static} uint32_t compensate_humidity({\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
01395                                     {\cf17 const} {\cf17 struct} bme280_calib_data *calib_data)\par
01396 \{\par
01397     int32_t var1;\par
01398     int32_t var2;\par
01399     int32_t var3;\par
01400     int32_t var4;\par
01401     int32_t var5;\par
01402     uint32_t humidity;\par
01403     uint32_t humidity_max = 102400;\par
01404 \par
01405     var1 = calib_data->t_fine - ((int32_t)76800);\par
01406     var2 = (int32_t)(uncomp_data->humidity * 16384);\par
01407     var3 = (int32_t)(((int32_t)calib_data->dig_h4) * 1048576);\par
01408     var4 = ((int32_t)calib_data->dig_h5) * var1;\par
01409     var5 = (((var2 - var3) - var4) + (int32_t)16384) / 32768;\par
01410     var2 = (var1 * ((int32_t)calib_data->dig_h6)) / 1024;\par
01411     var3 = (var1 * ((int32_t)calib_data->dig_h3)) / 2048;\par
01412     var4 = ((var2 * (var3 + (int32_t)32768)) / 1024) + (int32_t)2097152;\par
01413     var2 = ((var4 * ((int32_t)calib_data->dig_h2)) + 8192) / 16384;\par
01414     var3 = var5 * var2;\par
01415     var4 = ((var3 / 32768) * (var3 / 32768)) / 128;\par
01416     var5 = var3 - ((var4 * ((int32_t)calib_data->dig_h1)) / 16);\par
01417     var5 = (var5 < 0 ? 0 : var5);\par
01418     var5 = (var5 > 419430400 ? 419430400 : var5);\par
01419     humidity = (uint32_t)(var5 / 4096);\par
01420 \par
01421     {\cf19 if} (humidity > humidity_max)\par
01422     \{\par
01423         humidity = humidity_max;\par
01424     \}\par
01425 \par
01426     {\cf19 return} humidity;\par
01427 \}\par
01428 {\cf21 #endif}\par
01429 \par
01434 {\cf17 static} int8_t get_calib_data({\cf17 struct} bme280_dev *dev)\par
01435 \{\par
01436     int8_t rslt;\par
01437     uint8_t reg_addr = BME280_REG_TEMP_PRESS_CALIB_DATA;\par
01438 \par
01439     {\cf20 /* Array to store calibration data */}\par
01440     uint8_t calib_data[BME280_LEN_TEMP_PRESS_CALIB_DATA] = \{ 0 \};\par
01441 \par
01442     {\cf20 /* Read the calibration data from the sensor */}\par
01443     rslt = bme280_get_regs(reg_addr, calib_data, BME280_LEN_TEMP_PRESS_CALIB_DATA, dev);\par
01444 \par
01445     {\cf19 if} (rslt == BME280_OK)\par
01446     \{\par
01447         {\cf20 /* Parse temperature and pressure calibration data and store}\par
01448 {\cf20          * it in device structure}\par
01449 {\cf20          */}\par
01450         parse_temp_press_calib_data(calib_data, dev);\par
01451         reg_addr = BME280_REG_HUMIDITY_CALIB_DATA;\par
01452 \par
01453         {\cf20 /* Read the humidity calibration data from the sensor */}\par
01454         rslt = bme280_get_regs(reg_addr, calib_data, BME280_LEN_HUMIDITY_CALIB_DATA, dev);\par
01455 \par
01456         {\cf19 if} (rslt == BME280_OK)\par
01457         \{\par
01458             {\cf20 /* Parse humidity calibration data and store it in}\par
01459 {\cf20              * device structure}\par
01460 {\cf20              */}\par
01461             parse_humidity_calib_data(calib_data, dev);\par
01462         \}\par
01463     \}\par
01464 \par
01465     {\cf19 return} rslt;\par
01466 \}\par
01467 \par
01472 {\cf17 static} {\cf18 void} interleave_reg_addr({\cf17 const} uint8_t *reg_addr, uint8_t *temp_buff, {\cf17 const} uint8_t *reg_data, uint32_t len)\par
01473 \{\par
01474     uint32_t index;\par
01475 \par
01476     {\cf19 for} (index = 1; index < len; index++)\par
01477     \{\par
01478         temp_buff[(index * 2) - 1] = reg_addr[index];\par
01479         temp_buff[index * 2] = reg_data[index];\par
01480     \}\par
01481 \}\par
01482 \par
01487 {\cf17 static} {\cf18 void} parse_temp_press_calib_data({\cf17 const} uint8_t *reg_data, {\cf17 struct} bme280_dev *dev)\par
01488 \{\par
01489     {\cf17 struct }bme280_calib_data *calib_data = &dev->calib_data;\par
01490 \par
01491     calib_data->dig_t1 = BME280_CONCAT_BYTES(reg_data[1], reg_data[0]);\par
01492     calib_data->dig_t2 = (int16_t)BME280_CONCAT_BYTES(reg_data[3], reg_data[2]);\par
01493     calib_data->dig_t3 = (int16_t)BME280_CONCAT_BYTES(reg_data[5], reg_data[4]);\par
01494     calib_data->dig_p1 = BME280_CONCAT_BYTES(reg_data[7], reg_data[6]);\par
01495     calib_data->dig_p2 = (int16_t)BME280_CONCAT_BYTES(reg_data[9], reg_data[8]);\par
01496     calib_data->dig_p3 = (int16_t)BME280_CONCAT_BYTES(reg_data[11], reg_data[10]);\par
01497     calib_data->dig_p4 = (int16_t)BME280_CONCAT_BYTES(reg_data[13], reg_data[12]);\par
01498     calib_data->dig_p5 = (int16_t)BME280_CONCAT_BYTES(reg_data[15], reg_data[14]);\par
01499     calib_data->dig_p6 = (int16_t)BME280_CONCAT_BYTES(reg_data[17], reg_data[16]);\par
01500     calib_data->dig_p7 = (int16_t)BME280_CONCAT_BYTES(reg_data[19], reg_data[18]);\par
01501     calib_data->dig_p8 = (int16_t)BME280_CONCAT_BYTES(reg_data[21], reg_data[20]);\par
01502     calib_data->dig_p9 = (int16_t)BME280_CONCAT_BYTES(reg_data[23], reg_data[22]);\par
01503     calib_data->dig_h1 = reg_data[25];\par
01504 \}\par
01505 \par
01510 {\cf17 static} {\cf18 void} parse_humidity_calib_data({\cf17 const} uint8_t *reg_data, {\cf17 struct} bme280_dev *dev)\par
01511 \{\par
01512     {\cf17 struct }bme280_calib_data *calib_data = &dev->calib_data;\par
01513     int16_t dig_h4_lsb;\par
01514     int16_t dig_h4_msb;\par
01515     int16_t dig_h5_lsb;\par
01516     int16_t dig_h5_msb;\par
01517 \par
01518     calib_data->dig_h2 = (int16_t)BME280_CONCAT_BYTES(reg_data[1], reg_data[0]);\par
01519     calib_data->dig_h3 = reg_data[2];\par
01520     dig_h4_msb = (int16_t)(int8_t)reg_data[3] * 16;\par
01521     dig_h4_lsb = (int16_t)(reg_data[4] & 0x0F);\par
01522     calib_data->dig_h4 = dig_h4_msb | dig_h4_lsb;\par
01523     dig_h5_msb = (int16_t)(int8_t)reg_data[5] * 16;\par
01524     dig_h5_lsb = (int16_t)(reg_data[4] >> 4);\par
01525     calib_data->dig_h5 = dig_h5_msb | dig_h5_lsb;\par
01526     calib_data->dig_h6 = (int8_t)reg_data[6];\par
01527 \}\par
01528 \par
01533 {\cf17 static} uint8_t are_settings_changed(uint8_t sub_settings, uint8_t desired_settings)\par
01534 \{\par
01535     uint8_t settings_changed = FALSE;\par
01536 \par
01537     {\cf19 if} (sub_settings & desired_settings)\par
01538     \{\par
01539         {\cf20 /* User wants to modify this particular settings */}\par
01540         settings_changed = TRUE;\par
01541     \}\par
01542     {\cf19 else}\par
01543     \{\par
01544         {\cf20 /* User don't want to modify this particular settings */}\par
01545         settings_changed = FALSE;\par
01546     \}\par
01547 \par
01548     {\cf19 return} settings_changed;\par
01549 \}\par
01550 \par
01555 {\cf17 static} int8_t null_ptr_check({\cf17 const} {\cf17 struct} bme280_dev *dev)\par
01556 \{\par
01557     int8_t rslt;\par
01558 \par
01559     {\cf19 if} ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))\par
01560     \{\par
01561         {\cf20 /* Device structure pointer is not valid */}\par
01562         rslt = BME280_E_NULL_PTR;\par
01563     \}\par
01564     {\cf19 else}\par
01565     \{\par
01566         {\cf20 /* Device structure is fine */}\par
01567         rslt = BME280_OK;\par
01568     \}\par
01569 \par
01570     {\cf19 return} rslt;\par
01571 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/bme280/bme280.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/bme280/bme280.h}
{\xe \v lib/bme280/bme280.h}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor driver for BME280 sensor. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "bme280_defs.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_init} (struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API is the entry point. It reads the chip-id and calibration data from the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_set_regs} (uint8_t *reg_addr, const uint8_t *reg_data, uint32_t len, struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API writes the given data to the register address of the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_get_regs} (uint8_t reg_addr, uint8_t *reg_data, uint32_t len, struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API reads the data from the given register address of the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_set_sensor_settings} (uint8_t desired_settings, const struct {\b bme280_settings} *settings, struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API sets the oversampling, filter and standby duration (normal mode) settings in the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_get_sensor_settings} (struct {\b bme280_settings} *settings, struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API gets the oversampling, filter and standby duration (normal mode) settings from the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_set_sensor_mode} (uint8_t sensor_mode, struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API sets the power mode of the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_get_sensor_mode} (uint8_t *sensor_mode, struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API gets the power mode of the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_soft_reset} (struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API performs the soft reset of the sensor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_get_sensor_data} (uint8_t sensor_comp, struct {\b bme280_data} *comp_data, struct {\b bme280_dev} *dev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API reads the pressure, temperature and humidity data from the sensor, compensates the data and store it in the {\b bme280_data} structure instance passed by the user. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_compensate_data} (uint8_t sensor_comp, const struct {\b bme280_uncomp_data} *uncomp_data, struct {\b bme280_data} *comp_data, struct {\b bme280_calib_data} *calib_data)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API is used to compensate the pressure and/or temperature and/or humidity data according to the component selected by the user. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b bme280_cal_meas_delay} (uint32_t *max_delay, const struct {\b bme280_settings} *settings)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API is used to calculate the maximum delay in milliseconds required for the temperature/pressure/humidity(whichever are enabled) measurement to complete. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sensor driver for BME280 sensor. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2020 Bosch Sensortec GmbH. All rights reserved.\par
BSD-3-Clause\par
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\par
{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\par}
\par
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Date\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
2020-12-17 \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Version\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
v3.5.1\par
}}}{
Definition in file {\b bme280.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v bme280_cal_meas_delay\:bme280.h}
{\xe \v bme280.h\:bme280_cal_meas_delay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_cal_meas_delay (uint32_t * max_delay, const struct {\b bme280_settings} * settings)}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API is used to calculate the maximum delay in milliseconds required for the temperature/pressure/humidity(whichever are enabled) measurement to complete. }}\par
{
Definition at line {\b 799} of file {\b bme280.c}.}\par
}
{\xe \v bme280_compensate_data\:bme280.h}
{\xe \v bme280.h\:bme280_compensate_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_compensate_data (uint8_t sensor_comp, const struct {\b bme280_uncomp_data} * uncomp_data, struct {\b bme280_data} * comp_data, struct {\b bme280_calib_data} * calib_data)}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API is used to compensate the pressure and/or temperature and/or humidity data according to the component selected by the user. }}\par
{
Definition at line {\b 754} of file {\b bme280.c}.}\par
}
{\xe \v bme280_get_regs\:bme280.h}
{\xe \v bme280.h\:bme280_get_regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_get_regs (uint8_t reg_addr, uint8_t * reg_data, uint32_t len, struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API reads the data from the given register address of the sensor. }}\par
{
Definition at line {\b 449} of file {\b bme280.c}.}\par
}
{\xe \v bme280_get_sensor_data\:bme280.h}
{\xe \v bme280.h\:bme280_get_sensor_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_get_sensor_data (uint8_t sensor_comp, struct {\b bme280_data} * comp_data, struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API reads the pressure, temperature and humidity data from the sensor, compensates the data and store it in the {\b bme280_data} structure instance passed by the user. }}\par
{
Definition at line {\b 715} of file {\b bme280.c}.}\par
}
{\xe \v bme280_get_sensor_mode\:bme280.h}
{\xe \v bme280.h\:bme280_get_sensor_mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_get_sensor_mode (uint8_t * sensor_mode, struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API gets the power mode of the sensor. }}\par
{
Definition at line {\b 654} of file {\b bme280.c}.}\par
}
{\xe \v bme280_get_sensor_settings\:bme280.h}
{\xe \v bme280.h\:bme280_get_sensor_settings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_get_sensor_settings (struct {\b bme280_settings} * settings, struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API gets the oversampling, filter and standby duration (normal mode) settings from the sensor. }}\par
{
Definition at line {\b 602} of file {\b bme280.c}.}\par
}
{\xe \v bme280_init\:bme280.h}
{\xe \v bme280.h\:bme280_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_init (struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API is the entry point. It reads the chip-id and calibration data from the sensor. }}\par
{
Definition at line {\b 413} of file {\b bme280.c}.}\par
}
{\xe \v bme280_set_regs\:bme280.h}
{\xe \v bme280.h\:bme280_set_regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_set_regs (uint8_t * reg_addr, const uint8_t * reg_data, uint32_t len, struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API writes the given data to the register address of the sensor. }}\par
{
Definition at line {\b 485} of file {\b bme280.c}.}\par
}
{\xe \v bme280_set_sensor_mode\:bme280.h}
{\xe \v bme280.h\:bme280_set_sensor_mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_set_sensor_mode (uint8_t sensor_mode, struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API sets the power mode of the sensor. }}\par
{
Definition at line {\b 627} of file {\b bme280.c}.}\par
}
{\xe \v bme280_set_sensor_settings\:bme280.h}
{\xe \v bme280.h\:bme280_set_sensor_settings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_set_sensor_settings (uint8_t desired_settings, const struct {\b bme280_settings} * settings, struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API sets the oversampling, filter and standby duration (normal mode) settings in the sensor. }}\par
{
Definition at line {\b 555} of file {\b bme280.c}.}\par
}
{\xe \v bme280_soft_reset\:bme280.h}
{\xe \v bme280.h\:bme280_soft_reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t bme280_soft_reset (struct {\b bme280_dev} * dev)}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This API performs the soft reset of the sensor. }}\par
{
Definition at line {\b 677} of file {\b bme280.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bme280.h\par \pard\plain 
{\tc\tcl2 \v lib/bme280/bme280.h}
{\xe \v lib/bme280/bme280.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00038 \par
00042 \par
00048 \par
00049 {\cf21 #ifndef _BME280_H}\par
00050 {\cf21 #define _BME280_H}\par
00051 \par
00053 {\cf21 #ifdef __cplusplus}\par
00054 {\cf17 extern} {\cf22 "C"} \{\par
00055 {\cf21 #endif}\par
00056 \par
00057 {\cf20 /* Header includes */}\par
00058 {\cf21 #include "bme280_defs.h"}\par
00059 \par
00065 \par
00085 int8_t bme280_init({\cf17 struct} bme280_dev *dev);\par
00086 \par
00092 \par
00114 int8_t bme280_set_regs(uint8_t *reg_addr, {\cf17 const} uint8_t *reg_data, uint32_t len, {\cf17 struct} bme280_dev *dev);\par
00115 \par
00136 int8_t bme280_get_regs(uint8_t reg_addr, uint8_t *reg_data, uint32_t len, {\cf17 struct} bme280_dev *dev);\par
00137 \par
00143 \par
00179 int8_t bme280_set_sensor_settings(uint8_t desired_settings,\par
00180                                   {\cf17 const} {\cf17 struct} bme280_settings *settings,\par
00181                                   {\cf17 struct} bme280_dev *dev);\par
00182 \par
00202 int8_t bme280_get_sensor_settings({\cf17 struct} bme280_settings *settings, {\cf17 struct} bme280_dev *dev);\par
00203 \par
00209 \par
00236 int8_t bme280_set_sensor_mode(uint8_t sensor_mode, {\cf17 struct} bme280_dev *dev);\par
00237 \par
00264 int8_t bme280_get_sensor_mode(uint8_t *sensor_mode, {\cf17 struct} bme280_dev *dev);\par
00265 \par
00271 \par
00289 int8_t bme280_soft_reset({\cf17 struct} bme280_dev *dev);\par
00290 \par
00296 \par
00329 int8_t bme280_get_sensor_data(uint8_t sensor_comp, {\cf17 struct} bme280_data *comp_data, {\cf17 struct} bme280_dev *dev);\par
00330 \par
00359 int8_t bme280_compensate_data(uint8_t sensor_comp,\par
00360                               {\cf17 const} {\cf17 struct} bme280_uncomp_data *uncomp_data,\par
00361                               {\cf17 struct} bme280_data *comp_data,\par
00362                               {\cf17 struct} bme280_calib_data *calib_data);\par
00363 \par
00369 \par
00391 int8_t bme280_cal_meas_delay(uint32_t *max_delay, {\cf17 const} {\cf17 struct} bme280_settings *settings);\par
00392 \par
00393 {\cf21 #ifdef __cplusplus}\par
00394 \}\par
00395 {\cf21 #endif }{\cf20 /* End of CPP guard */}{\cf21 }\par
00396 {\cf21 #endif }{\cf20 /* _BME280_H */}{\cf21 }{\cf21 }\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/bme280/bme280_defs.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/bme280/bme280_defs.h}
{\xe \v lib/bme280/bme280_defs.h}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b bme280_calib_data}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calibration data. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b bme280_data}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280 sensor structure which comprises of temperature, pressure and humidity data }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b bme280_uncomp_data}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280 sensor structure which comprises of uncompensated temperature, pressure and humidity data }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b bme280_settings}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280 sensor settings structure which comprises of mode, oversampling and filter settings. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b bme280_dev}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bme280 device structure }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Common macros\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INT8_C}(x)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UINT8_C}(x)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INT16_C}(x)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UINT16_C}(x)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INT32_C}(x)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UINT32_C}(x)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INT64_C}(x)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UINT64_C}(x)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid C standard macros\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NULL}\~ ((void *) 0)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Compiler switch macros Definitions\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_DOUBLE_ENABLE}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid General Macro Definitions\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TRUE}\~ {\b UINT8_C}(1)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FALSE}\~ {\b UINT8_C}(0)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_INTF_RET_TYPE}\~ int8_t\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_INTF_RET_SUCCESS}\~ {\b INT8_C}(0)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid API success code\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_OK}\~ {\b INT8_C}(0)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid API error codes\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_E_NULL_PTR}\~ {\b INT8_C}(-1)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_E_COMM_FAIL}\~ {\b INT8_C}(-2)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_E_INVALID_LEN}\~ {\b INT8_C}(-3)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_E_DEV_NOT_FOUND}\~ {\b INT8_C}(-4)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_E_SLEEP_MODE_FAIL}\~ {\b INT8_C}(-5)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_E_NVM_COPY_FAILED}\~ {\b INT8_C}(-6)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid API warning codes\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_W_INVALID_OSR_MACRO}\~ {\b INT8_C}(1)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid BME280 chip identifier\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CHIP_ID}\~ {\b UINT8_C}(0x60)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid I2C addresses\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_I2C_ADDR_PRIM}\~ {\b UINT8_C}(0x76)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_I2C_ADDR_SEC}\~ {\b UINT8_C}(0x77)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Register Address\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_REG_CHIP_ID}\~ {\b UINT8_C}(0xD0)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_REG_RESET}\~ {\b UINT8_C}(0xE0)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_REG_TEMP_PRESS_CALIB_DATA}\~ {\b UINT8_C}(0x88)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_REG_HUMIDITY_CALIB_DATA}\~ {\b UINT8_C}(0xE1)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_REG_CTRL_HUM}\~ {\b UINT8_C}(0xF2)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_REG_STATUS}\~ {\b UINT8_C}(0xF3)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_REG_PWR_CTRL}\~ {\b UINT8_C}(0xF4)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_REG_CTRL_MEAS}\~ {\b UINT8_C}(0xF4)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_REG_CONFIG}\~ {\b UINT8_C}(0xF5)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_REG_DATA}\~ {\b UINT8_C}(0xF7)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Macros related to size\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_LEN_TEMP_PRESS_CALIB_DATA}\~ {\b UINT8_C}(26)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_LEN_HUMIDITY_CALIB_DATA}\~ {\b UINT8_C}(7)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_LEN_P_T_H_DATA}\~ {\b UINT8_C}(8)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Sensor power modes\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_POWERMODE_SLEEP}\~ {\b UINT8_C}(0x00)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_POWERMODE_FORCED}\~ {\b UINT8_C}(0x01)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_POWERMODE_NORMAL}\~ {\b UINT8_C}(0x03)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_SENSOR_MODE_MSK}\~ {\b UINT8_C}(0x03)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_SENSOR_MODE_POS}\~ {\b UINT8_C}(0x00)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Soft reset command\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_SOFT_RESET_COMMAND}\~ {\b UINT8_C}(0xB6)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STATUS_IM_UPDATE}\~ {\b UINT8_C}(0x01)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STATUS_MEAS_DONE}\~ {\b UINT8_C}(0x08)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Sensor component selection macros\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These values are internal for API implementation. Don't relate this to data sheet. \par
}}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_PRESS}\~ {\b UINT8_C}(1)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_TEMP}\~ {\b UINT8_C}(1 << 1)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_HUM}\~ {\b UINT8_C}(1 << 2)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_ALL}\~ {\b UINT8_C}(0x07)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Settings selection macros\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_SEL_OSR_PRESS}\~ {\b UINT8_C}(1)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_SEL_OSR_TEMP}\~ {\b UINT8_C}(1 << 1)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_SEL_OSR_HUM}\~ {\b UINT8_C}(1 << 2)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_SEL_FILTER}\~ {\b UINT8_C}(1 << 3)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_SEL_STANDBY}\~ {\b UINT8_C}(1 << 4)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_SEL_ALL_SETTINGS}\~ {\b UINT8_C}(0x1F)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Oversampling macros\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_NO_OVERSAMPLING}\~ {\b UINT8_C}(0x00)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_OVERSAMPLING_1X}\~ {\b UINT8_C}(0x01)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_OVERSAMPLING_2X}\~ {\b UINT8_C}(0x02)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_OVERSAMPLING_4X}\~ {\b UINT8_C}(0x03)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_OVERSAMPLING_8X}\~ {\b UINT8_C}(0x04)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_OVERSAMPLING_16X}\~ {\b UINT8_C}(0x05)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_OVERSAMPLING_MAX}\~ {\b UINT8_C}(16)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CTRL_HUM_MSK}\~ {\b UINT8_C}(0x07)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CTRL_HUM_POS}\~ {\b UINT8_C}(0x00)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CTRL_PRESS_MSK}\~ {\b UINT8_C}(0x1C)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CTRL_PRESS_POS}\~ {\b UINT8_C}(0x02)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CTRL_TEMP_MSK}\~ {\b UINT8_C}(0xE0)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CTRL_TEMP_POS}\~ {\b UINT8_C}(0x05)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Measurement delay calculation macros\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_MEAS_OFFSET}\~ {\b UINT16_C}(1250)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_MEAS_DUR}\~ {\b UINT16_C}(2300)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_PRES_HUM_MEAS_OFFSET}\~ {\b UINT16_C}(575)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_MEAS_SCALING_FACTOR}\~ {\b UINT16_C}(1000)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STARTUP_DELAY}\~ {\b UINT16_C}(2000)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Length macros\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_MAX_LEN}\~ {\b UINT8_C}(10)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Standby duration selection macros\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STANDBY_TIME_0_5_MS}\~ (0x00)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STANDBY_TIME_62_5_MS}\~ (0x01)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STANDBY_TIME_125_MS}\~ (0x02)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STANDBY_TIME_250_MS}\~ (0x03)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STANDBY_TIME_500_MS}\~ (0x04)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STANDBY_TIME_1000_MS}\~ (0x05)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STANDBY_TIME_10_MS}\~ (0x06)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STANDBY_TIME_20_MS}\~ (0x07)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STANDBY_MSK}\~ {\b UINT8_C}(0xE0)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_STANDBY_POS}\~ {\b UINT8_C}(0x05)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Bit shift macros\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_12_BIT_SHIFT}\~ {\b UINT8_C}(12)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_8_BIT_SHIFT}\~ {\b UINT8_C}(8)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_4_BIT_SHIFT}\~ {\b UINT8_C}(4)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Filter coefficient selection macros\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_FILTER_COEFF_OFF}\~ (0x00)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_FILTER_COEFF_2}\~ (0x01)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_FILTER_COEFF_4}\~ (0x02)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_FILTER_COEFF_8}\~ (0x03)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_FILTER_COEFF_16}\~ (0x04)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_FILTER_MSK}\~ {\b UINT8_C}(0x1C)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_FILTER_POS}\~ {\b UINT8_C}(0x02)\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Macro to combine two 8 bit data's to form a 16 bit data\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_CONCAT_BYTES}(msb,  lsb)\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Function Pointers\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b BME280_INTF_RET_TYPE}(* {\b bme280_read_fptr_t}) (uint8_t reg_addr, uint8_t *reg_data, uint32_t len, void *intf_ptr)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bus communication function pointer which should be mapped to the platform specific read functions of the user. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b BME280_INTF_RET_TYPE}(* {\b bme280_write_fptr_t}) (uint8_t reg_addr, const uint8_t *reg_data, uint32_t len, void *intf_ptr)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bus communication function pointer which should be mapped to the platform specific write functions of the user. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b bme280_delay_us_fptr_t}) (uint32_t period, void *intf_ptr)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Delay function pointer which should be mapped to delay function of the user. }{
}\par
}\par}
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro to SET and GET BITS of a register\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_SET_BITS}(reg_data,  bitname,  {\b data})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_SET_BITS_POS_0}(reg_data,  bitname,  {\b data})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_GET_BITS}(reg_data,  bitname)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BME280_GET_BITS_POS_0}(reg_data,  bitname)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b bme280_intf} \{ {\b BME280_SPI_INTF}
, {\b BME280_I2C_INTF}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface selection Enums. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2020 Bosch Sensortec GmbH. All rights reserved.\par
BSD-3-Clause\par
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\par
{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\par}
\par
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Date\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
2020-12-17 \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Version\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
v3.5.1 \par
}}}{
Definition in file {\b bme280_defs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BME280_12_BIT_SHIFT\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_12_BIT_SHIFT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_12_BIT_SHIFT\~ {\b UINT8_C}(12)}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 230} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_4_BIT_SHIFT\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_4_BIT_SHIFT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_4_BIT_SHIFT\~ {\b UINT8_C}(4)}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 232} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_8_BIT_SHIFT\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_8_BIT_SHIFT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_8_BIT_SHIFT\~ {\b UINT8_C}(8)}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 231} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_ALL\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_ALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_ALL\~ {\b UINT8_C}(0x07)}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 180} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_CHIP_ID\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_CHIP_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CHIP_ID\~ {\b UINT8_C}(0x60)}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_CONCAT_BYTES\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_CONCAT_BYTES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CONCAT_BYTES( msb,  lsb)}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (((uint16_t)msb << 8) | (uint16_t)lsb)\par
}
{
Definition at line {\b 245} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_CTRL_HUM_MSK\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_CTRL_HUM_MSK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CTRL_HUM_MSK\~ {\b UINT8_C}(0x07)}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_CTRL_HUM_POS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_CTRL_HUM_POS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CTRL_HUM_POS\~ {\b UINT8_C}(0x00)}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_CTRL_PRESS_MSK\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_CTRL_PRESS_MSK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CTRL_PRESS_MSK\~ {\b UINT8_C}(0x1C)}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 201} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_CTRL_PRESS_POS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_CTRL_PRESS_POS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CTRL_PRESS_POS\~ {\b UINT8_C}(0x02)}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_CTRL_TEMP_MSK\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_CTRL_TEMP_MSK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CTRL_TEMP_MSK\~ {\b UINT8_C}(0xE0)}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 203} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_CTRL_TEMP_POS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_CTRL_TEMP_POS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_CTRL_TEMP_POS\~ {\b UINT8_C}(0x05)}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 204} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_DOUBLE_ENABLE\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_DOUBLE_ENABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_DOUBLE_ENABLE}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_E_COMM_FAIL\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_E_COMM_FAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_E_COMM_FAIL\~ {\b INT8_C}(-2)}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_E_DEV_NOT_FOUND\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_E_DEV_NOT_FOUND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_E_DEV_NOT_FOUND\~ {\b INT8_C}(-4)}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_E_INVALID_LEN\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_E_INVALID_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_E_INVALID_LEN\~ {\b INT8_C}(-3)}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_E_NULL_PTR\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_E_NULL_PTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_E_NULL_PTR\~ {\b INT8_C}(-1)}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_E_NVM_COPY_FAILED\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_E_NVM_COPY_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_E_NVM_COPY_FAILED\~ {\b INT8_C}(-6)}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_E_SLEEP_MODE_FAIL\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_E_SLEEP_MODE_FAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_E_SLEEP_MODE_FAIL\~ {\b INT8_C}(-5)}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_FILTER_COEFF_16\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_FILTER_COEFF_16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_FILTER_COEFF_16\~ (0x04)}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 239} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_FILTER_COEFF_2\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_FILTER_COEFF_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_FILTER_COEFF_2\~ (0x01)}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 236} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_FILTER_COEFF_4\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_FILTER_COEFF_4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_FILTER_COEFF_4\~ (0x02)}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 237} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_FILTER_COEFF_8\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_FILTER_COEFF_8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_FILTER_COEFF_8\~ (0x03)}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 238} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_FILTER_COEFF_OFF\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_FILTER_COEFF_OFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_FILTER_COEFF_OFF\~ (0x00)}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 235} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_FILTER_MSK\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_FILTER_MSK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_FILTER_MSK\~ {\b UINT8_C}(0x1C)}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 241} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_FILTER_POS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_FILTER_POS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_FILTER_POS\~ {\b UINT8_C}(0x02)}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 242} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_GET_BITS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_GET_BITS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_GET_BITS( reg_data,  bitname)}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                    ((reg_data & (bitname##_MSK)) >> \\\par
                                                   (bitname##_POS))\par
}
{
Definition at line {\b 256} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_GET_BITS_POS_0\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_GET_BITS_POS_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_GET_BITS_POS_0( reg_data,  bitname)}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (reg_data & (bitname##_MSK))\par
}
{
Definition at line {\b 258} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_HUM\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_HUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_HUM\~ {\b UINT8_C}(1 << 2)}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 179} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_I2C_ADDR_PRIM\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_I2C_ADDR_PRIM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_I2C_ADDR_PRIM\~ {\b UINT8_C}(0x76)}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_I2C_ADDR_SEC\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_I2C_ADDR_SEC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_I2C_ADDR_SEC\~ {\b UINT8_C}(0x77)}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 140} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_INTF_RET_SUCCESS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_INTF_RET_SUCCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_INTF_RET_SUCCESS\~ {\b INT8_C}(0)}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The last error code from read/write interface is stored in the device structure as intf_rslt. \par
}{
Definition at line {\b 118} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_INTF_RET_TYPE\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_INTF_RET_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_INTF_RET_TYPE\~ int8_t}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BME280_INTF_RET_TYPE is the read/write interface return type which can be overwritten by the build system. \par
}{
Definition at line {\b 111} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_LEN_HUMIDITY_CALIB_DATA\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_LEN_HUMIDITY_CALIB_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_LEN_HUMIDITY_CALIB_DATA\~ {\b UINT8_C}(7)}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 156} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_LEN_P_T_H_DATA\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_LEN_P_T_H_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_LEN_P_T_H_DATA\~ {\b UINT8_C}(8)}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_LEN_TEMP_PRESS_CALIB_DATA\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_LEN_TEMP_PRESS_CALIB_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_LEN_TEMP_PRESS_CALIB_DATA\~ {\b UINT8_C}(26)}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 155} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_MAX_LEN\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_MAX_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_MAX_LEN\~ {\b UINT8_C}(10)}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 214} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_MEAS_DUR\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_MEAS_DUR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_MEAS_DUR\~ {\b UINT16_C}(2300)}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 208} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_MEAS_OFFSET\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_MEAS_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_MEAS_OFFSET\~ {\b UINT16_C}(1250)}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 207} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_MEAS_SCALING_FACTOR\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_MEAS_SCALING_FACTOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_MEAS_SCALING_FACTOR\~ {\b UINT16_C}(1000)}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 210} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_NO_OVERSAMPLING\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_NO_OVERSAMPLING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_NO_OVERSAMPLING\~ {\b UINT8_C}(0x00)}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 191} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_OK\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_OK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_OK\~ {\b INT8_C}(0)}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_OVERSAMPLING_16X\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_OVERSAMPLING_16X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_OVERSAMPLING_16X\~ {\b UINT8_C}(0x05)}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 196} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_OVERSAMPLING_1X\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_OVERSAMPLING_1X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_OVERSAMPLING_1X\~ {\b UINT8_C}(0x01)}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 192} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_OVERSAMPLING_2X\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_OVERSAMPLING_2X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_OVERSAMPLING_2X\~ {\b UINT8_C}(0x02)}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 193} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_OVERSAMPLING_4X\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_OVERSAMPLING_4X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_OVERSAMPLING_4X\~ {\b UINT8_C}(0x03)}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_OVERSAMPLING_8X\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_OVERSAMPLING_8X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_OVERSAMPLING_8X\~ {\b UINT8_C}(0x04)}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 195} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_OVERSAMPLING_MAX\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_OVERSAMPLING_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_OVERSAMPLING_MAX\~ {\b UINT8_C}(16)}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 197} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_POWERMODE_FORCED\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_POWERMODE_FORCED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_POWERMODE_FORCED\~ {\b UINT8_C}(0x01)}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 161} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_POWERMODE_NORMAL\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_POWERMODE_NORMAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_POWERMODE_NORMAL\~ {\b UINT8_C}(0x03)}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_POWERMODE_SLEEP\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_POWERMODE_SLEEP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_POWERMODE_SLEEP\~ {\b UINT8_C}(0x00)}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_PRES_HUM_MEAS_OFFSET\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_PRES_HUM_MEAS_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_PRES_HUM_MEAS_OFFSET\~ {\b UINT16_C}(575)}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 209} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_PRESS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_PRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_PRESS\~ {\b UINT8_C}(1)}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 177} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_REG_CHIP_ID\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_REG_CHIP_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_REG_CHIP_ID\~ {\b UINT8_C}(0xD0)}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_REG_CONFIG\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_REG_CONFIG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_REG_CONFIG\~ {\b UINT8_C}(0xF5)}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_REG_CTRL_HUM\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_REG_CTRL_HUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_REG_CTRL_HUM\~ {\b UINT8_C}(0xF2)}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_REG_CTRL_MEAS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_REG_CTRL_MEAS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_REG_CTRL_MEAS\~ {\b UINT8_C}(0xF4)}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 150} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_REG_DATA\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_REG_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_REG_DATA\~ {\b UINT8_C}(0xF7)}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 152} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_REG_HUMIDITY_CALIB_DATA\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_REG_HUMIDITY_CALIB_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_REG_HUMIDITY_CALIB_DATA\~ {\b UINT8_C}(0xE1)}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_REG_PWR_CTRL\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_REG_PWR_CTRL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_REG_PWR_CTRL\~ {\b UINT8_C}(0xF4)}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_REG_RESET\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_REG_RESET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_REG_RESET\~ {\b UINT8_C}(0xE0)}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 144} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_REG_STATUS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_REG_STATUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_REG_STATUS\~ {\b UINT8_C}(0xF3)}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 148} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_REG_TEMP_PRESS_CALIB_DATA\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_REG_TEMP_PRESS_CALIB_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_REG_TEMP_PRESS_CALIB_DATA\~ {\b UINT8_C}(0x88)}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 145} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_SEL_ALL_SETTINGS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_SEL_ALL_SETTINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_SEL_ALL_SETTINGS\~ {\b UINT8_C}(0x1F)}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 188} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_SEL_FILTER\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_SEL_FILTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_SEL_FILTER\~ {\b UINT8_C}(1 << 3)}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_SEL_OSR_HUM\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_SEL_OSR_HUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_SEL_OSR_HUM\~ {\b UINT8_C}(1 << 2)}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 185} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_SEL_OSR_PRESS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_SEL_OSR_PRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_SEL_OSR_PRESS\~ {\b UINT8_C}(1)}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 183} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_SEL_OSR_TEMP\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_SEL_OSR_TEMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_SEL_OSR_TEMP\~ {\b UINT8_C}(1 << 1)}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 184} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_SEL_STANDBY\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_SEL_STANDBY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_SEL_STANDBY\~ {\b UINT8_C}(1 << 4)}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 187} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_SENSOR_MODE_MSK\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_SENSOR_MODE_MSK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_SENSOR_MODE_MSK\~ {\b UINT8_C}(0x03)}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_SENSOR_MODE_POS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_SENSOR_MODE_POS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_SENSOR_MODE_POS\~ {\b UINT8_C}(0x00)}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_SET_BITS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_SET_BITS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_SET_BITS( reg_data,  bitname,  {\b data})}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     ((reg_data & ~(bitname##_MSK)) | \\\par
     ((data << bitname##_POS) & bitname##_MSK))\par
}
{
Definition at line {\b 248} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_SET_BITS_POS_0\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_SET_BITS_POS_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_SET_BITS_POS_0( reg_data,  bitname,  {\b data})}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     ((reg_data & ~(bitname##_MSK)) | \\\par
     (data & bitname##_MSK))\par
}
{
Definition at line {\b 252} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_SOFT_RESET_COMMAND\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_SOFT_RESET_COMMAND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_SOFT_RESET_COMMAND\~ {\b UINT8_C}(0xB6)}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 168} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_STANDBY_MSK\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_STANDBY_MSK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STANDBY_MSK\~ {\b UINT8_C}(0xE0)}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 226} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_STANDBY_POS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_STANDBY_POS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STANDBY_POS\~ {\b UINT8_C}(0x05)}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 227} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_STANDBY_TIME_0_5_MS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_STANDBY_TIME_0_5_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STANDBY_TIME_0_5_MS\~ (0x00)}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 217} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_STANDBY_TIME_1000_MS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_STANDBY_TIME_1000_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STANDBY_TIME_1000_MS\~ (0x05)}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 222} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_STANDBY_TIME_10_MS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_STANDBY_TIME_10_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STANDBY_TIME_10_MS\~ (0x06)}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 223} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_STANDBY_TIME_125_MS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_STANDBY_TIME_125_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STANDBY_TIME_125_MS\~ (0x02)}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 219} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_STANDBY_TIME_20_MS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_STANDBY_TIME_20_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STANDBY_TIME_20_MS\~ (0x07)}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 224} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_STANDBY_TIME_250_MS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_STANDBY_TIME_250_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STANDBY_TIME_250_MS\~ (0x03)}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 220} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_STANDBY_TIME_500_MS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_STANDBY_TIME_500_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STANDBY_TIME_500_MS\~ (0x04)}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 221} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_STANDBY_TIME_62_5_MS\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_STANDBY_TIME_62_5_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STANDBY_TIME_62_5_MS\~ (0x01)}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 218} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_STARTUP_DELAY\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_STARTUP_DELAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STARTUP_DELAY\~ {\b UINT16_C}(2000)}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 211} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_STATUS_IM_UPDATE\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_STATUS_IM_UPDATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STATUS_IM_UPDATE\~ {\b UINT8_C}(0x01)}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 170} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_STATUS_MEAS_DONE\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_STATUS_MEAS_DONE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_STATUS_MEAS_DONE\~ {\b UINT8_C}(0x08)}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 171} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_TEMP\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_TEMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_TEMP\~ {\b UINT8_C}(1 << 1)}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b bme280_defs.h}.}\par
}
{\xe \v BME280_W_INVALID_OSR_MACRO\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_W_INVALID_OSR_MACRO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BME280_W_INVALID_OSR_MACRO\~ {\b INT8_C}(1)}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b bme280_defs.h}.}\par
}
{\xe \v FALSE\:bme280_defs.h}
{\xe \v bme280_defs.h\:FALSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FALSE\~ {\b UINT8_C}(0)}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b bme280_defs.h}.}\par
}
{\xe \v INT16_C\:bme280_defs.h}
{\xe \v bme280_defs.h\:INT16_C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INT16_C( x)}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid S16_C(x)\par
}
{
Definition at line {\b 62} of file {\b bme280_defs.h}.}\par
}
{\xe \v INT32_C\:bme280_defs.h}
{\xe \v bme280_defs.h\:INT32_C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INT32_C( x)}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid S32_C(x)\par
}
{
Definition at line {\b 67} of file {\b bme280_defs.h}.}\par
}
{\xe \v INT64_C\:bme280_defs.h}
{\xe \v bme280_defs.h\:INT64_C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INT64_C( x)}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid S64_C(x)\par
}
{
Definition at line {\b 72} of file {\b bme280_defs.h}.}\par
}
{\xe \v INT8_C\:bme280_defs.h}
{\xe \v bme280_defs.h\:INT8_C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INT8_C( x)}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid S8_C(x)\par
}
{
Definition at line {\b 57} of file {\b bme280_defs.h}.}\par
}
{\xe \v NULL\:bme280_defs.h}
{\xe \v bme280_defs.h\:NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NULL\~ ((void *) 0)}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b bme280_defs.h}.}\par
}
{\xe \v TRUE\:bme280_defs.h}
{\xe \v bme280_defs.h\:TRUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TRUE\~ {\b UINT8_C}(1)}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b bme280_defs.h}.}\par
}
{\xe \v UINT16_C\:bme280_defs.h}
{\xe \v bme280_defs.h\:UINT16_C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UINT16_C( x)}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid U16_C(x)\par
}
{
Definition at line {\b 63} of file {\b bme280_defs.h}.}\par
}
{\xe \v UINT32_C\:bme280_defs.h}
{\xe \v bme280_defs.h\:UINT32_C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UINT32_C( x)}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid U32_C(x)\par
}
{
Definition at line {\b 68} of file {\b bme280_defs.h}.}\par
}
{\xe \v UINT64_C\:bme280_defs.h}
{\xe \v bme280_defs.h\:UINT64_C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UINT64_C( x)}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid U64_C(x)\par
}
{
Definition at line {\b 73} of file {\b bme280_defs.h}.}\par
}
{\xe \v UINT8_C\:bme280_defs.h}
{\xe \v bme280_defs.h\:UINT8_C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UINT8_C( x)}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid U8_C(x)\par
}
{
Definition at line {\b 58} of file {\b bme280_defs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v bme280_delay_us_fptr_t\:bme280_defs.h}
{\xe \v bme280_defs.h\:bme280_delay_us_fptr_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* bme280_delay_us_fptr_t) (uint32_t period, void *intf_ptr)}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Delay function pointer which should be mapped to delay function of the user. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i period} \cell }{: Delay in microseconds. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i intf_ptr} \cell }{: Void pointer that can enable the linking of descriptors for interface related call backs \cell }
{\row }
}
}{
Definition at line {\b 319} of file {\b bme280_defs.h}.}\par
}
{\xe \v bme280_read_fptr_t\:bme280_defs.h}
{\xe \v bme280_defs.h\:bme280_read_fptr_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b BME280_INTF_RET_TYPE}(* bme280_read_fptr_t) (uint8_t reg_addr, uint8_t *reg_data, uint32_t len, void *intf_ptr)}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bus communication function pointer which should be mapped to the platform specific read functions of the user. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i reg_addr} \cell }{: Register address from which data is read. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i reg_data} \cell }{: Pointer to data buffer where read data is stored. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i len} \cell }{: Number of bytes of data to be read. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i intf_ptr} \cell }{: Void pointer that can enable the linking of descriptors for interface related call backs.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{-> Success. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Non} \cell }{zero value -> Fail. \cell }
{\row }
}
}{
Definition at line {\b 290} of file {\b bme280_defs.h}.}\par
}
{\xe \v bme280_write_fptr_t\:bme280_defs.h}
{\xe \v bme280_defs.h\:bme280_write_fptr_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b BME280_INTF_RET_TYPE}(* bme280_write_fptr_t) (uint8_t reg_addr, const uint8_t *reg_data, uint32_t len, void *intf_ptr)}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bus communication function pointer which should be mapped to the platform specific write functions of the user. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i reg_addr} \cell }{: Register address to which the data is written. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i reg_data} \cell }{: Pointer to data buffer in which data to be written is stored. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i len} \cell }{: Number of bytes of data to be written. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i intf_ptr} \cell }{: Void pointer that can enable the linking of descriptors for interface related call backs\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i 0} \cell }{-> Success. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Non} \cell }{zero value -> Fail. \cell }
{\row }
}
}{
Definition at line {\b 307} of file {\b bme280_defs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v bme280_intf\:bme280_defs.h}
{\xe \v bme280_defs.h\:bme280_intf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b bme280_intf}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface selection Enums. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v BME280_SPI_INTF\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_SPI_INTF}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BME280_SPI_INTF{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SPI interface \par
}\cell }{\row }
{\xe \v BME280_I2C_INTF\:bme280_defs.h}
{\xe \v bme280_defs.h\:BME280_I2C_INTF}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BME280_I2C_INTF{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
I2C interface \par
}\cell }{\row }
}
{
Definition at line {\b 265} of file {\b bme280_defs.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bme280_defs.h\par \pard\plain 
{\tc\tcl2 \v lib/bme280/bme280_defs.h}
{\xe \v lib/bme280/bme280_defs.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00038 \par
00039 {\cf21 #ifndef _BME280_DEFS_H}\par
00040 {\cf21 #define _BME280_DEFS_H}\par
00041 \par
00042 {\cf20 /********************************************************/}\par
00043 {\cf20 /* header includes */}\par
00044 {\cf21 #ifdef __KERNEL__}\par
00045 {\cf21 #include <linux/types.h>}\par
00046 {\cf21 #include <linux/kernel.h>}\par
00047 {\cf21 #else}\par
00048 {\cf21 #include <stdint.h>}\par
00049 {\cf21 #include <stddef.h>}\par
00050 {\cf21 #endif}\par
00051 \par
00052 {\cf20 /********************************************************/}\par
00054 {\cf20 /********************************************************/}\par
00055 \par
00056 {\cf21 #if !defined(UINT8_C) && !defined(INT8_C)}\par
00057 {\cf21 #define INT8_C(x)    S8_C(x)}\par
00058 {\cf21 #define UINT8_C(x)   U8_C(x)}\par
00059 {\cf21 #endif}\par
00060 \par
00061 {\cf21 #if !defined(UINT16_C) && !defined(INT16_C)}\par
00062 {\cf21 #define INT16_C(x)   S16_C(x)}\par
00063 {\cf21 #define UINT16_C(x)  U16_C(x)}\par
00064 {\cf21 #endif}\par
00065 \par
00066 {\cf21 #if !defined(INT32_C) && !defined(UINT32_C)}\par
00067 {\cf21 #define INT32_C(x)   S32_C(x)}\par
00068 {\cf21 #define UINT32_C(x)  U32_C(x)}\par
00069 {\cf21 #endif}\par
00070 \par
00071 {\cf21 #if !defined(INT64_C) && !defined(UINT64_C)}\par
00072 {\cf21 #define INT64_C(x)   S64_C(x)}\par
00073 {\cf21 #define UINT64_C(x)  U64_C(x)}\par
00074 {\cf21 #endif}\par
00075 \par
00078 {\cf21 #ifndef NULL}\par
00079 {\cf21 #ifdef __cplusplus}\par
00080 {\cf21 #define NULL         0}\par
00081 {\cf21 #else}\par
00082 {\cf21 #define NULL         ((void *) 0)}\par
00083 {\cf21 #endif}\par
00084 {\cf21 #endif}\par
00085 \par
00086 {\cf20 /******************************************************************************/}\par
00088 {\cf20 /******************************************************************************/}\par
00089 {\cf21 #ifndef BME280_64BIT_ENABLE }{\cf20 /*< Check if 64-bit integer (using BME280_64BIT_ENABLE) is enabled */}{\cf21 }\par
00090 {\cf21 #ifndef BME280_32BIT_ENABLE }{\cf20 /*< Check if 32-bit integer (using BME280_32BIT_ENABLE) is enabled */}{\cf21 }\par
00091 {\cf21 #ifndef BME280_DOUBLE_ENABLE }{\cf20 /*< If any of the integer data types not enabled then enable BME280_DOUBLE_ENABLE */}{\cf21 }\par
00092 {\cf21 #define BME280_DOUBLE_ENABLE}\par
00093 {\cf21 #endif}\par
00094 {\cf21 #endif}\par
00095 {\cf21 #endif}\par
00096 \par
00097 {\cf20 /******************************************************************************/}\par
00099 {\cf20 /******************************************************************************/}\par
00100 {\cf21 #ifndef TRUE}\par
00101 {\cf21 #define TRUE                                      UINT8_C(1)}\par
00102 {\cf21 #endif}\par
00103 {\cf21 #ifndef FALSE}\par
00104 {\cf21 #define FALSE                                     UINT8_C(0)}\par
00105 {\cf21 #endif}\par
00106 \par
00110 {\cf21 #ifndef BME280_INTF_RET_TYPE}\par
00111 {\cf21 #define BME280_INTF_RET_TYPE                      int8_t}\par
00112 {\cf21 #endif}\par
00113 \par
00117 {\cf21 #ifndef BME280_INTF_RET_SUCCESS}\par
00118 {\cf21 #define BME280_INTF_RET_SUCCESS                   INT8_C(0)}\par
00119 {\cf21 #endif}\par
00120 \par
00122 {\cf21 #define BME280_OK                                 INT8_C(0)}\par
00123 \par
00125 {\cf21 #define BME280_E_NULL_PTR                         INT8_C(-1)}\par
00126 {\cf21 #define BME280_E_COMM_FAIL                        INT8_C(-2)}\par
00127 {\cf21 #define BME280_E_INVALID_LEN                      INT8_C(-3)}\par
00128 {\cf21 #define BME280_E_DEV_NOT_FOUND                    INT8_C(-4)}\par
00129 {\cf21 #define BME280_E_SLEEP_MODE_FAIL                  INT8_C(-5)}\par
00130 {\cf21 #define BME280_E_NVM_COPY_FAILED                  INT8_C(-6)}\par
00131 \par
00133 {\cf21 #define BME280_W_INVALID_OSR_MACRO                INT8_C(1)}\par
00134 \par
00136 {\cf21 #define BME280_CHIP_ID                            UINT8_C(0x60)}\par
00137 \par
00139 {\cf21 #define BME280_I2C_ADDR_PRIM                      UINT8_C(0x76)}\par
00140 {\cf21 #define BME280_I2C_ADDR_SEC                       UINT8_C(0x77)}\par
00141 \par
00143 {\cf21 #define BME280_REG_CHIP_ID                        UINT8_C(0xD0)}\par
00144 {\cf21 #define BME280_REG_RESET                          UINT8_C(0xE0)}\par
00145 {\cf21 #define BME280_REG_TEMP_PRESS_CALIB_DATA          UINT8_C(0x88)}\par
00146 {\cf21 #define BME280_REG_HUMIDITY_CALIB_DATA            UINT8_C(0xE1)}\par
00147 {\cf21 #define BME280_REG_CTRL_HUM                       UINT8_C(0xF2)}\par
00148 {\cf21 #define BME280_REG_STATUS                         UINT8_C(0xF3)}\par
00149 {\cf21 #define BME280_REG_PWR_CTRL                       UINT8_C(0xF4)}\par
00150 {\cf21 #define BME280_REG_CTRL_MEAS                      UINT8_C(0xF4)}\par
00151 {\cf21 #define BME280_REG_CONFIG                         UINT8_C(0xF5)}\par
00152 {\cf21 #define BME280_REG_DATA                           UINT8_C(0xF7)}\par
00153 \par
00155 {\cf21 #define BME280_LEN_TEMP_PRESS_CALIB_DATA          UINT8_C(26)}\par
00156 {\cf21 #define BME280_LEN_HUMIDITY_CALIB_DATA            UINT8_C(7)}\par
00157 {\cf21 #define BME280_LEN_P_T_H_DATA                     UINT8_C(8)}\par
00158 \par
00160 {\cf21 #define BME280_POWERMODE_SLEEP                    UINT8_C(0x00)}\par
00161 {\cf21 #define BME280_POWERMODE_FORCED                   UINT8_C(0x01)}\par
00162 {\cf21 #define BME280_POWERMODE_NORMAL                   UINT8_C(0x03)}\par
00163 \par
00164 {\cf21 #define BME280_SENSOR_MODE_MSK                    UINT8_C(0x03)}\par
00165 {\cf21 #define BME280_SENSOR_MODE_POS                    UINT8_C(0x00)}\par
00166 \par
00168 {\cf21 #define BME280_SOFT_RESET_COMMAND                 UINT8_C(0xB6)}\par
00169 \par
00170 {\cf21 #define BME280_STATUS_IM_UPDATE                   UINT8_C(0x01)}\par
00171 {\cf21 #define BME280_STATUS_MEAS_DONE                   UINT8_C(0x08)}\par
00172 \par
00177 {\cf21 #define BME280_PRESS                              UINT8_C(1)}\par
00178 {\cf21 #define BME280_TEMP                               UINT8_C(1 << 1)}\par
00179 {\cf21 #define BME280_HUM                                UINT8_C(1 << 2)}\par
00180 {\cf21 #define BME280_ALL                                UINT8_C(0x07)}\par
00181 \par
00183 {\cf21 #define BME280_SEL_OSR_PRESS                      UINT8_C(1)}\par
00184 {\cf21 #define BME280_SEL_OSR_TEMP                       UINT8_C(1 << 1)}\par
00185 {\cf21 #define BME280_SEL_OSR_HUM                        UINT8_C(1 << 2)}\par
00186 {\cf21 #define BME280_SEL_FILTER                         UINT8_C(1 << 3)}\par
00187 {\cf21 #define BME280_SEL_STANDBY                        UINT8_C(1 << 4)}\par
00188 {\cf21 #define BME280_SEL_ALL_SETTINGS                   UINT8_C(0x1F)}\par
00189 \par
00191 {\cf21 #define BME280_NO_OVERSAMPLING                    UINT8_C(0x00)}\par
00192 {\cf21 #define BME280_OVERSAMPLING_1X                    UINT8_C(0x01)}\par
00193 {\cf21 #define BME280_OVERSAMPLING_2X                    UINT8_C(0x02)}\par
00194 {\cf21 #define BME280_OVERSAMPLING_4X                    UINT8_C(0x03)}\par
00195 {\cf21 #define BME280_OVERSAMPLING_8X                    UINT8_C(0x04)}\par
00196 {\cf21 #define BME280_OVERSAMPLING_16X                   UINT8_C(0x05)}\par
00197 {\cf21 #define BME280_OVERSAMPLING_MAX                   UINT8_C(16)}\par
00198 \par
00199 {\cf21 #define BME280_CTRL_HUM_MSK                       UINT8_C(0x07)}\par
00200 {\cf21 #define BME280_CTRL_HUM_POS                       UINT8_C(0x00)}\par
00201 {\cf21 #define BME280_CTRL_PRESS_MSK                     UINT8_C(0x1C)}\par
00202 {\cf21 #define BME280_CTRL_PRESS_POS                     UINT8_C(0x02)}\par
00203 {\cf21 #define BME280_CTRL_TEMP_MSK                      UINT8_C(0xE0)}\par
00204 {\cf21 #define BME280_CTRL_TEMP_POS                      UINT8_C(0x05)}\par
00205 \par
00207 {\cf21 #define BME280_MEAS_OFFSET                        UINT16_C(1250)}\par
00208 {\cf21 #define BME280_MEAS_DUR                           UINT16_C(2300)}\par
00209 {\cf21 #define BME280_PRES_HUM_MEAS_OFFSET               UINT16_C(575)}\par
00210 {\cf21 #define BME280_MEAS_SCALING_FACTOR                UINT16_C(1000)}\par
00211 {\cf21 #define BME280_STARTUP_DELAY                      UINT16_C(2000)}\par
00212 \par
00214 {\cf21 #define BME280_MAX_LEN                            UINT8_C(10)}\par
00215 \par
00217 {\cf21 #define BME280_STANDBY_TIME_0_5_MS                (0x00)}\par
00218 {\cf21 #define BME280_STANDBY_TIME_62_5_MS               (0x01)}\par
00219 {\cf21 #define BME280_STANDBY_TIME_125_MS                (0x02)}\par
00220 {\cf21 #define BME280_STANDBY_TIME_250_MS                (0x03)}\par
00221 {\cf21 #define BME280_STANDBY_TIME_500_MS                (0x04)}\par
00222 {\cf21 #define BME280_STANDBY_TIME_1000_MS               (0x05)}\par
00223 {\cf21 #define BME280_STANDBY_TIME_10_MS                 (0x06)}\par
00224 {\cf21 #define BME280_STANDBY_TIME_20_MS                 (0x07)}\par
00225 \par
00226 {\cf21 #define BME280_STANDBY_MSK                        UINT8_C(0xE0)}\par
00227 {\cf21 #define BME280_STANDBY_POS                        UINT8_C(0x05)}\par
00228 \par
00230 {\cf21 #define BME280_12_BIT_SHIFT                       UINT8_C(12)}\par
00231 {\cf21 #define BME280_8_BIT_SHIFT                        UINT8_C(8)}\par
00232 {\cf21 #define BME280_4_BIT_SHIFT                        UINT8_C(4)}\par
00233 \par
00235 {\cf21 #define BME280_FILTER_COEFF_OFF                   (0x00)}\par
00236 {\cf21 #define BME280_FILTER_COEFF_2                     (0x01)}\par
00237 {\cf21 #define BME280_FILTER_COEFF_4                     (0x02)}\par
00238 {\cf21 #define BME280_FILTER_COEFF_8                     (0x03)}\par
00239 {\cf21 #define BME280_FILTER_COEFF_16                    (0x04)}\par
00240 \par
00241 {\cf21 #define BME280_FILTER_MSK                         UINT8_C(0x1C)}\par
00242 {\cf21 #define BME280_FILTER_POS                         UINT8_C(0x02)}\par
00243 \par
00245 {\cf21 #define BME280_CONCAT_BYTES(msb, lsb)             (((uint16_t)msb << 8) | (uint16_t)lsb)}\par
00246 \par
00248 {\cf21 #define BME280_SET_BITS(reg_data, bitname, data) \\}\par
00249 {\cf21     ((reg_data & ~(bitname##_MSK)) | \\}\par
00250 {\cf21      ((data << bitname##_POS) & bitname##_MSK))}\par
00251 \par
00252 {\cf21 #define BME280_SET_BITS_POS_0(reg_data, bitname, data) \\}\par
00253 {\cf21     ((reg_data & ~(bitname##_MSK)) | \\}\par
00254 {\cf21      (data & bitname##_MSK))}\par
00255 \par
00256 {\cf21 #define BME280_GET_BITS(reg_data, bitname)        ((reg_data & (bitname##_MSK)) >> \\}\par
00257 {\cf21                                                    (bitname##_POS))}\par
00258 {\cf21 #define BME280_GET_BITS_POS_0(reg_data, bitname)  (reg_data & (bitname##_MSK))}\par
00259 \par
00260 {\cf20 /********************************************************/}\par
00261 \par
00265 {\cf17 enum} bme280_intf \{\par
00267     BME280_SPI_INTF,\par
00269     BME280_I2C_INTF\par
00270 \};\par
00271 \par
00272 {\cf20 /******************************************************************************/}\par
00274 {\cf20 /******************************************************************************/}\par
00275 \par
00290 {\cf17 typedef} BME280_INTF_RET_TYPE (*bme280_read_fptr_t)(uint8_t reg_addr, uint8_t *reg_data, uint32_t len, {\cf18 void} *intf_ptr);\par
00291 \par
00307 {\cf17 typedef} BME280_INTF_RET_TYPE (*bme280_write_fptr_t)(uint8_t reg_addr, {\cf17 const} uint8_t *reg_data, uint32_t len,\par
00308                                                     {\cf18 void} *intf_ptr);\par
00309 \par
00319 {\cf17 typedef} void (*bme280_delay_us_fptr_t)(uint32_t period, {\cf18 void} *intf_ptr);\par
00320 \par
00321 {\cf20 /******************************************************************************/}\par
00323 {\cf20 /******************************************************************************/}\par
00324 \par
00328 {\cf17 struct }bme280_calib_data\par
00329 \{\par
00331     uint16_t dig_t1;\par
00332 \par
00334     int16_t dig_t2;\par
00335 \par
00337     int16_t dig_t3;\par
00338 \par
00340     uint16_t dig_p1;\par
00341 \par
00343     int16_t dig_p2;\par
00344 \par
00346     int16_t dig_p3;\par
00347 \par
00349     int16_t dig_p4;\par
00350 \par
00352     int16_t dig_p5;\par
00353 \par
00355     int16_t dig_p6;\par
00356 \par
00358     int16_t dig_p7;\par
00359 \par
00361     int16_t dig_p8;\par
00362 \par
00364     int16_t dig_p9;\par
00365 \par
00367     uint8_t dig_h1;\par
00368 \par
00370     int16_t dig_h2;\par
00371 \par
00373     uint8_t dig_h3;\par
00374 \par
00376     int16_t dig_h4;\par
00377 \par
00379     int16_t dig_h5;\par
00380 \par
00382     int8_t dig_h6;\par
00383 \par
00385     int32_t t_fine;\par
00386 \};\par
00387 \par
00392 {\cf21 #ifdef BME280_DOUBLE_ENABLE}\par
00393 {\cf17 struct }bme280_data\par
00394 \{\par
00396     {\cf18 double} pressure;\par
00397 \par
00399     {\cf18 double} temperature;\par
00400 \par
00402     {\cf18 double} humidity;\par
00403 \};\par
00404 {\cf21 #else}\par
00405 {\cf17 struct }bme280_data\par
00406 \{\par
00408     uint32_t pressure;\par
00409 \par
00411     int32_t temperature;\par
00412 \par
00414     uint32_t humidity;\par
00415 \};\par
00416 {\cf21 #endif }{\cf21 }\par
00417 \par
00422 {\cf17 struct }bme280_uncomp_data\par
00423 \{\par
00425     uint32_t pressure;\par
00426 \par
00428     uint32_t temperature;\par
00429 \par
00431     uint32_t humidity;\par
00432 \};\par
00433 \par
00438 {\cf17 struct }bme280_settings\par
00439 \{\par
00441     uint8_t osr_p;\par
00442 \par
00444     uint8_t osr_t;\par
00445 \par
00447     uint8_t osr_h;\par
00448 \par
00450     uint8_t filter;\par
00451 \par
00453     uint8_t standby_time;\par
00454 \};\par
00455 \par
00459 {\cf17 struct }bme280_dev\par
00460 \{\par
00462     uint8_t chip_id;\par
00463 \par
00468     {\cf17 enum} bme280_intf intf;\par
00469 \par
00476     {\cf18 void} *intf_ptr;\par
00477 \par
00479     BME280_INTF_RET_TYPE intf_rslt;\par
00480 \par
00482     bme280_read_fptr_t read;\par
00483 \par
00485     bme280_write_fptr_t write;\par
00486 \par
00488     bme280_delay_us_fptr_t delay_us;\par
00489 \par
00491     {\cf17 struct }bme280_calib_data calib_data;\par
00492 \};\par
00493 \par
00494 {\cf21 #endif }{\cf20 /* _BME280_DEFS_H */}{\cf21 }\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/FAT32/FAT32.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/FAT32/FAT32.c}
{\xe \v lib/FAT32/FAT32.c}
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <avr/io.h>}\par
{\f2 #include <avr/pgmspace.h>}\par
{\f2 #include "FAT32.h"}\par
{\f2 #include "uart.h"}\par
{\f2 #include "sd_routines.h"}\par
{\f2 #include "rtc.h"}\par
{\f2 #include "uart_compat.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b getBootSectorData} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b getFirstSector} (unsigned long clusterNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b getSetNextCluster} (unsigned long clusterNumber, unsigned char get_set, unsigned long clusterEntry)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b getSetFreeCluster} (unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dir_Structure} * {\b findFiles} (unsigned char flag, unsigned char *fileName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b readFile} (unsigned char flag, unsigned char *fileName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b convertFileName} (unsigned char *fileName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b writeFile} (unsigned char *fileName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b searchNextFreeCluster} (unsigned long startCluster)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b displayMemory} (unsigned char flag, unsigned long memory)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b deleteFile} (unsigned char *fileName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b freeMemoryUpdate} (unsigned char flag, unsigned long size)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v convertFileName\:FAT32.c}
{\xe \v FAT32.c\:convertFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char convertFileName (unsigned char * fileName)}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 383} of file {\b FAT32.c}.}\par
}
{\xe \v deleteFile\:FAT32.c}
{\xe \v FAT32.c\:deleteFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void deleteFile (unsigned char * fileName)}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 726} of file {\b FAT32.c}.}\par
}
{\xe \v displayMemory\:FAT32.c}
{\xe \v FAT32.c\:displayMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void displayMemory (unsigned char flag, unsigned long memory)}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 702} of file {\b FAT32.c}.}\par
}
{\xe \v findFiles\:FAT32.c}
{\xe \v FAT32.c\:findFiles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b dir_Structure} * findFiles (unsigned char flag, unsigned char * fileName)}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b FAT32.c}.}\par
}
{\xe \v freeMemoryUpdate\:FAT32.c}
{\xe \v FAT32.c\:freeMemoryUpdate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void freeMemoryUpdate (unsigned char flag, unsigned long size)}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 743} of file {\b FAT32.c}.}\par
}
{\xe \v getBootSectorData\:FAT32.c}
{\xe \v FAT32.c\:getBootSectorData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char getBootSectorData (void )}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b FAT32.c}.}\par
}
{\xe \v getFirstSector\:FAT32.c}
{\xe \v FAT32.c\:getFirstSector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getFirstSector (unsigned long clusterNumber)}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b FAT32.c}.}\par
}
{\xe \v getSetFreeCluster\:FAT32.c}
{\xe \v FAT32.c\:getSetFreeCluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getSetFreeCluster (unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b FAT32.c}.}\par
}
{\xe \v getSetNextCluster\:FAT32.c}
{\xe \v FAT32.c\:getSetNextCluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getSetNextCluster (unsigned long clusterNumber, unsigned char get_set, unsigned long clusterEntry)}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b FAT32.c}.}\par
}
{\xe \v readFile\:FAT32.c}
{\xe \v FAT32.c\:readFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char readFile (unsigned char flag, unsigned char * fileName)}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 319} of file {\b FAT32.c}.}\par
}
{\xe \v searchNextFreeCluster\:FAT32.c}
{\xe \v FAT32.c\:searchNextFreeCluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long searchNextFreeCluster (unsigned long startCluster)}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 674} of file {\b FAT32.c}.}\par
}
{\xe \v writeFile\:FAT32.c}
{\xe \v FAT32.c\:writeFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char writeFile (unsigned char * fileName)}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 442} of file {\b FAT32.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FAT32.c\par \pard\plain 
{\tc\tcl2 \v lib/FAT32/FAT32.c}
{\xe \v lib/FAT32/FAT32.c}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //************************************************************}\par
00002 {\cf20 // **** ROUTINES FOR FAT32 IMPLEMATATION OF SD CARD ****}\par
00003 {\cf20 //************************************************************}\par
00004 {\cf20 //Controller        : ATmega32 (Clock: 8 Mhz-internal)}\par
00005 {\cf20 //Compiler          : AVR-GCC (winAVR with AVRStudio-4)}\par
00006 {\cf20 //Project Version   : DL_1.0}\par
00007 {\cf20 //Author            : CC Dharmani, Chennai (India)}\par
00008 {\cf20 //                    www.dharmanitech.com}\par
00009 {\cf20 //Date              : 10 May 2011}\par
00010 {\cf20 //************************************************************}\par
00011 \par
00012 {\cf21 #include <avr/io.h>}\par
00013 {\cf21 #include <avr/pgmspace.h>}\par
00014 {\cf21 #include "FAT32.h"}\par
00015 {\cf20 // #include "UART_routines.h"}\par
00016 {\cf21 #include "uart.h"}\par
00017 {\cf21 #include "sd_routines.h"}\par
00018 {\cf21 #include "rtc.h"}\par
00019 {\cf21 #include "uart_compat.h"}\par
00020 {\cf20 // #include "RTC_routines.h"  }\par
00021 \par
00022 {\cf20 //***************************************************************************}\par
00023 {\cf20 //Function: to read data from boot sector of SD card, to determine important}\par
00024 {\cf20 //parameters like bytesPerSector, sectorsPerCluster etc.}\par
00025 {\cf20 //Arguments: none}\par
00026 {\cf20 //return: none}\par
00027 {\cf20 //***************************************************************************}\par
00028 {\cf18 unsigned} {\cf18 char} getBootSectorData ({\cf18 void})\par
00029 \{\par
00030 {\cf17 struct }BS_Structure *bpb; {\cf20 //mapping the buffer onto the structure}\par
00031 {\cf17 struct }MBRinfo_Structure *mbr;\par
00032 {\cf17 struct }partitionInfo_Structure *partition;\par
00033 {\cf18 unsigned} {\cf18 long} dataSectors;\par
00034 \par
00035 unusedSectors = 0;\par
00036 \par
00037 SD_readSingleBlock(0);\par
00038 bpb = ({\cf17 struct }BS_Structure *)buffer;\par
00039 \par
00040 {\cf19 if}(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   {\cf20 //check if it is boot sector}\par
00041 \{\par
00042   mbr = ({\cf17 struct }MBRinfo_Structure *) buffer;       {\cf20 //if it is not boot sector, it must be MBR}\par
00043   \par
00044   {\cf19 if}(mbr->signature != 0xaa55) {\cf19 return} 1;       {\cf20 //if it is not even MBR then it's not FAT32}\par
00045     \par
00046   partition = ({\cf17 struct }partitionInfo_Structure *)(mbr->partitionData);{\cf20 //first partition}\par
00047   unusedSectors = partition->firstSector; {\cf20 //the unused sectors, hidden to the FAT}\par
00048   \par
00049   SD_readSingleBlock(partition->firstSector);{\cf20 //read the bpb sector}\par
00050   bpb = ({\cf17 struct }BS_Structure *)buffer;\par
00051   {\cf19 if}(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) {\cf19 return} 1; \par
00052 \}\par
00053 \par
00054 bytesPerSector = bpb->bytesPerSector;\par
00055 {\cf20 //transmitHex(INT, bytesPerSector); transmitByte(' ');}\par
00056 sectorPerCluster = bpb->sectorPerCluster;\par
00057 {\cf20 //transmitHex(INT, sectorPerCluster); transmitByte(' ');}\par
00058 reservedSectorCount = bpb->reservedSectorCount;\par
00059 rootCluster = bpb->rootCluster;{\cf20 // + (sector / sectorPerCluster) +1;}\par
00060 firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);\par
00061 \par
00062 dataSectors = bpb->totalSectors_F32\par
00063               - bpb->reservedSectorCount\par
00064               - ( bpb->numberofFATs * bpb->FATsize_F32);\par
00065 totalClusters = dataSectors / sectorPerCluster;\par
00066 {\cf20 //transmitHex(LONG, totalClusters); transmitByte(' ');}\par
00067 \par
00068 {\cf19 if}((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  {\cf20 //check if FSinfo free clusters count is valid}\par
00069      freeClusterCountUpdated = 0;\par
00070 {\cf19 else}\par
00071      freeClusterCountUpdated = 1;\par
00072 {\cf19 return} 0;\par
00073 \}\par
00074 \par
00075 {\cf20 //***************************************************************************}\par
00076 {\cf20 //Function: to calculate first sector address of any given cluster}\par
00077 {\cf20 //Arguments: cluster number for which first sector is to be found}\par
00078 {\cf20 //return: first sector address}\par
00079 {\cf20 //***************************************************************************}\par
00080 {\cf18 unsigned} {\cf18 long} getFirstSector({\cf18 unsigned} {\cf18 long} clusterNumber)\par
00081 \{\par
00082   {\cf19 return} (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);\par
00083 \}\par
00084 \par
00085 {\cf20 //***************************************************************************}\par
00086 {\cf20 //Function: get cluster entry value from FAT to find out the next cluster in the chain}\par
00087 {\cf20 //or set new cluster entry in FAT}\par
00088 {\cf20 //Arguments: 1. current cluster number, 2. get_set (=GET, if next cluster is to be found or = SET,}\par
00089 {\cf20 //if next cluster is to be set 3. next cluster number, if argument#2 = SET, else 0}\par
00090 {\cf20 //return: next cluster number, if if argument#2 = GET, else 0}\par
00091 {\cf20 //****************************************************************************}\par
00092 {\cf18 unsigned} {\cf18 long} getSetNextCluster ({\cf18 unsigned} {\cf18 long} clusterNumber,\par
00093                                  {\cf18 unsigned} {\cf18 char} get_set,\par
00094                                  {\cf18 unsigned} {\cf18 long} clusterEntry)\par
00095 \{\par
00096 {\cf18 unsigned} {\cf18 int} FATEntryOffset;\par
00097 {\cf18 unsigned} {\cf18 long} *FATEntryValue;\par
00098 {\cf18 unsigned} {\cf18 long} FATEntrySector;\par
00099 {\cf18 unsigned} {\cf18 char} retry = 0;\par
00100 \par
00101 {\cf20 //get sector number of the cluster entry in the FAT}\par
00102 FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;\par
00103 \par
00104 {\cf20 //get the offset address in that sector number}\par
00105 FATEntryOffset = ({\cf18 unsigned} int) ((clusterNumber * 4) % bytesPerSector);\par
00106 \par
00107 {\cf20 //read the sector into a buffer}\par
00108 {\cf19 while}(retry <10)\par
00109 \{ {\cf19 if}(!SD_readSingleBlock(FATEntrySector)) {\cf19 break}; retry++;\}\par
00110 \par
00111 {\cf20 //get the cluster address from the buffer}\par
00112 FATEntryValue = ({\cf18 unsigned} {\cf18 long} *) &buffer[FATEntryOffset];\par
00113 \par
00114 {\cf19 if}(get_set == GET)\par
00115   {\cf19 return} ((*FATEntryValue) & 0x0fffffff);\par
00116 \par
00117 \par
00118 *FATEntryValue = clusterEntry;   {\cf20 //for setting new value in cluster entry in FAT}\par
00119 \par
00120 SD_writeSingleBlock(FATEntrySector);\par
00121 \par
00122 {\cf19 return} (0);\par
00123 \}\par
00124 \par
00125 {\cf20 //********************************************************************************************}\par
00126 {\cf20 //Function: to get or set next free cluster or total free clusters in FSinfo sector of SD card}\par
00127 {\cf20 //Arguments: 1.flag:TOTAL_FREE or NEXT_FREE, }\par
00128 {\cf20 //           2.flag: GET or SET }\par
00129 {\cf20 //           3.new FS entry, when argument2 is SET; or 0, when argument2 is GET}\par
00130 {\cf20 //return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET}\par
00131 {\cf20 //        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET}\par
00132 {\cf20 //        0xffffffff, if any error or if arg2 is SET}\par
00133 {\cf20 //********************************************************************************************}\par
00134 {\cf18 unsigned} {\cf18 long} getSetFreeCluster({\cf18 unsigned} {\cf18 char} totOrNext, {\cf18 unsigned} {\cf18 char} get_set, {\cf18 unsigned} {\cf18 long} FSEntry)\par
00135 \{\par
00136 {\cf17 struct }FSInfo_Structure *FS = ({\cf17 struct }FSInfo_Structure *) &buffer;\par
00137 {\cf18 unsigned} {\cf18 char} error;\par
00138 SD_readSingleBlock(unusedSectors + 1);\par
00139 \par
00140 {\cf19 if}((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))\par
00141   {\cf19 return} 0xffffffff;\par
00142 \par
00143  {\cf19 if}(get_set == GET)\par
00144  \{\par
00145    {\cf19 if}(totOrNext == TOTAL_FREE)\par
00146       {\cf19 return}(FS->freeClusterCount);\par
00147    {\cf19 else} {\cf20 // when totOrNext = NEXT_FREE}\par
00148       {\cf19 return}(FS->nextFreeCluster);\par
00149  \}\par
00150  {\cf19 else}\par
00151  \{\par
00152    {\cf19 if}(totOrNext == TOTAL_FREE)\par
00153       FS->freeClusterCount = FSEntry;\par
00154    {\cf19 else} {\cf20 // when totOrNext = NEXT_FREE}\par
00155       FS->nextFreeCluster = FSEntry;\par
00156  \par
00157    error = SD_writeSingleBlock(unusedSectors + 1);  {\cf20 //update FSinfo}\par
00158  \}\par
00159  {\cf19 return} 0xffffffff;\par
00160 \}\par
00161 \par
00162 {\cf20 //***************************************************************************}\par
00163 {\cf20 //Function: to get DIR/FILE list or a single file address (cluster number) or to delete a specified file}\par
00164 {\cf20 //Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)}\par
00165 {\cf20 //return: first cluster of the file, if flag = GET_FILE}\par
00166 {\cf20 //        print file/dir list of the root directory, if flag = GET_LIST}\par
00167 {\cf20 //        Delete the file mentioned in arg#2, if flag = DELETE}\par
00168 {\cf20 //****************************************************************************}\par
00169 {\cf17 struct }dir_Structure* findFiles ({\cf18 unsigned} {\cf18 char} flag, {\cf18 unsigned} {\cf18 char} *fileName)\par
00170 \{\par
00171 {\cf20 // uart_puts_P("findFiles: Started\\r\\n");}\par
00172 {\cf18 unsigned} {\cf18 long} cluster, sector, firstSector, firstCluster, nextCluster;\par
00173 {\cf17 struct }dir_Structure *dir;\par
00174 {\cf18 unsigned} {\cf18 int} i;\par
00175 {\cf18 unsigned} {\cf18 char} j;\par
00176 {\cf18 unsigned} {\cf18 char} loopCount = 0;  {\cf20 // \'E2\'86\'90 Pridajte timeout counter}\par
00177 \par
00178 cluster = rootCluster; {\cf20 //root cluster}\par
00179 uart_puts_P({\cf22 "findFiles: Root cluster = "});\par
00180 transmitHex(LONG, cluster);\par
00181 uart_puts_P({\cf22 "\\r\\n"});\par
00182 \par
00183 {\cf19 while}(1)\par
00184 \{\par
00185    loopCount++;\par
00186    {\cf19 if}(loopCount > 100) \{  {\cf20 // \'E2\'86\'90 Pridajte timeout}\par
00187        uart_puts_P({\cf22 "findFiles: Loop timeout!\\r\\n"});\par
00188        {\cf19 return} 0;\par
00189    \}\par
00190    \par
00191    uart_puts_P({\cf22 "findFiles: Reading cluster "});\par
00192    transmitHex(LONG, cluster);\par
00193    uart_puts_P({\cf22 "\\r\\n"});\par
00194    \par
00195    firstSector = getFirstSector (cluster);\par
00196    \par
00197    {\cf19 for}(sector = 0; sector < sectorPerCluster; sector++)\par
00198    \{\par
00199      uart_puts_P({\cf22 "findFiles: Reading sector\\r\\n"});\par
00200      SD_readSingleBlock (firstSector + sector);\par
00201      uart_puts_P({\cf22 "findFiles: Sector read\\r\\n"});\par
00202 \par
00203      {\cf19 for}(i=0; i<bytesPerSector; i+=32)\par
00204      \{\par
00205         dir = ({\cf17 struct }dir_Structure *) &buffer[i];\par
00206 \par
00207         {\cf19 if}(dir->name[0] == EMPTY) {\cf20 //indicates end of the file list}\par
00208         \{\par
00209           uart_puts_P({\cf22 "findFiles: Empty entry found\\r\\n"});\par
00210           {\cf19 if}(flag == DELETE)\par
00211               uart_puts_P({\cf22 "File does not exist!"});\par
00212           {\cf19 return} 0;   \par
00213         \}\par
00214         {\cf19 if}((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))\par
00215         \{\par
00216           {\cf19 if}((flag == GET_FILE) || (flag == DELETE))\par
00217           \{\par
00218             {\cf19 for}(j=0; j<11; j++)\par
00219             {\cf19 if}(dir->name[j] != fileName[j]) {\cf19 break};\par
00220             {\cf19 if}(j == 11)\par
00221             \{\par
00222               {\cf19 if}(flag == GET_FILE)\par
00223                     \{\par
00224                 appendFileSector = firstSector + sector;\par
00225               appendFileLocation = i;\par
00226               appendStartCluster = ((({\cf18 unsigned} long) dir->firstClusterHI) << 16) | dir->firstClusterLO;\par
00227               fileSize = dir->fileSize;\par
00228                 {\cf19 return} (dir);\par
00229               \} \par
00230               {\cf19 else}    {\cf20 //when flag = DELETE}\par
00231               \{\par
00232                 TX_NEWLINE;\par
00233               uart_puts_P(({\cf22 "Deleting.."}));\par
00234               TX_NEWLINE;\par
00235               TX_NEWLINE;\par
00236               firstCluster = ((({\cf18 unsigned} long) dir->firstClusterHI) << 16) | dir->firstClusterLO;\par
00237                       \par
00238               {\cf20 //mark file as 'deleted' in FAT table}\par
00239               dir->name[0] = DELETED;    \par
00240               SD_writeSingleBlock (firstSector+sector);\par
00241                     \par
00242               freeMemoryUpdate (ADD, dir->fileSize);\par
00243 \par
00244               {\cf20 //update next free cluster entry in FSinfo sector}\par
00245               cluster = getSetFreeCluster (NEXT_FREE, GET, 0); \par
00246               {\cf19 if}(firstCluster < cluster)\par
00247                   getSetFreeCluster (NEXT_FREE, SET, firstCluster);\par
00248 \par
00249               {\cf20 //mark all the clusters allocated to the file as 'free'}\par
00250                 {\cf19 while}(1)  \par
00251                 \{\par
00252                     nextCluster = getSetNextCluster (firstCluster, GET, 0);\par
00253                 getSetNextCluster (firstCluster, SET, 0);\par
00254                 {\cf19 if}(nextCluster > 0x0ffffff6) \par
00255                   \{uart_puts_P({\cf22 "File deleted!"});{\cf19 return} 0;\}\par
00256                 firstCluster = nextCluster;\par
00257                 \} \par
00258               \}\par
00259             \}\par
00260         \}\par
00261         {\cf19 else}  {\cf20 //when flag = GET_LIST}\par
00262         \{\par
00263             {\cf20 // TX_NEWLINE;}\par
00264             {\cf20 // uart_puts_P("JUST a TEST in listing\\r\\n");}\par
00265           {\cf19 for}(j=0; j<11; j++)\par
00266             \{\par
00267             {\cf19 if}(j == 8) transmitByte({\cf23 ' '});\par
00268             {\cf20 // transmitByte (dir->name[j]);}\par
00269           \}\par
00270             uart_puts_P({\cf22 "   "});\par
00271             {\cf19 if}((dir->attrib != 0x10) && (dir->attrib != 0x08))\par
00272           \{\par
00273               uart_puts_P({\cf22 "FILE"} );\par
00274                 uart_puts_P({\cf22 "   "});\par
00275               displayMemory(LOW, dir->fileSize);\par
00276           \}\par
00277           {\cf19 else}\par
00278             \{\par
00279               {\cf19 if} (dir->attrib == 0x10)\par
00280               \{\par
00281                 uart_puts(({\cf22 "DIR"} ));\par
00282               \}\par
00283               {\cf19 else}\par
00284               \{\par
00285                 uart_puts(({\cf22 "ROOT"} ));\par
00286               \}\par
00287             \}\par
00288         \}\par
00289        \}\par
00290      \}\par
00291    \}\par
00292 \par
00293   {\cf20 //  uart_puts_P("findFiles: Getting next cluster...\\r\\n");}\par
00294    cluster = (getSetNextCluster (cluster, GET, 0));\par
00295   {\cf20 //  uart_puts_P("findFiles: Next cluster = ");}\par
00296   {\cf20 //  transmitHex(LONG, cluster);}\par
00297   {\cf20 //  uart_puts_P("\\r\\n");}\par
00298 \par
00299    {\cf19 if}(cluster > 0x0ffffff6) \{\par
00300       {\cf20 //  uart_puts_P("findFiles: End of cluster chain\\r\\n");}\par
00301           {\cf19 return} 0;\par
00302    \}\par
00303    {\cf19 if}(cluster == 0) \{\par
00304       {\cf20 //  uart_puts_P("Error in getting cluster");}\par
00305        {\cf19 return} 0;\par
00306    \}\par
00307 \}\par
00308 {\cf19 return} 0;\par
00309 \}\par
00310 \par
00311 {\cf20 //***************************************************************************}\par
00312 {\cf20 //Function: if flag=READ then to read file from SD card and send contents to UART }\par
00313 {\cf20 //if flag=VERIFY then functions will verify whether a specified file is already existing}\par
00314 {\cf20 //Arguments: flag (READ or VERIFY) and pointer to the file name}\par
00315 {\cf20 //return: 0, if normal operation or flag is READ}\par
00316 {\cf20 //        1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist}\par
00317 {\cf20 //        2, if file name is incompatible}\par
00318 {\cf20 //***************************************************************************}\par
00319 {\cf18 unsigned} {\cf18 char} readFile ({\cf18 unsigned} {\cf18 char} flag, {\cf18 unsigned} {\cf18 char} *fileName)\par
00320 \{\par
00321 {\cf17 struct }dir_Structure *dir;\par
00322 {\cf18 unsigned} {\cf18 long} cluster, byteCounter = 0, fileSize, firstSector;\par
00323 {\cf18 unsigned} {\cf18 int} k;\par
00324 {\cf18 unsigned} {\cf18 char} j, error;\par
00325 \par
00326 uart_puts_P({\cf22 "readFile: Converting filename...\\r\\n"});\par
00327 error = convertFileName (fileName); {\cf20 //convert fileName into FAT format}\par
00328 {\cf19 if}(error) \{\par
00329     uart_puts_P({\cf22 "readFile: Invalid filename!\\r\\n"});\par
00330     {\cf19 return} 2;\par
00331 \}\par
00332 \par
00333 uart_puts_P({\cf22 "readFile: Filename converted: "});\par
00334 {\cf19 for}(j=0; j<11; j++) transmitByte(fileName[j]);\par
00335 uart_puts_P({\cf22 "\\r\\n"});\par
00336 \par
00337 uart_puts_P({\cf22 "readFile: Calling findFiles...\\r\\n"});\par
00338 dir = findFiles (GET_FILE, fileName); {\cf20 //get the file location}\par
00339 uart_puts_P({\cf22 "readFile: findFiles returned\\r\\n"});\par
00340 \par
00341 {\cf19 if}(dir == 0) \par
00342 \{\par
00343   uart_puts_P({\cf22 "readFile: File not found\\r\\n"});\par
00344   {\cf19 if}(flag == READ) {\cf19 return} (1);\par
00345   {\cf19 else} {\cf19 return} (0);\par
00346 \}\par
00347 \par
00348 uart_puts_P({\cf22 "readFile: File found!\\r\\n"});\par
00349 {\cf19 if}(flag == VERIFY) {\cf19 return} (1);  {\cf20 //specified file name is already existing}\par
00350 \par
00351 cluster = ((({\cf18 unsigned} long) dir->firstClusterHI) << 16) | dir->firstClusterLO;\par
00352 \par
00353 fileSize = dir->fileSize;\par
00354 \par
00355 TX_NEWLINE;\par
00356 TX_NEWLINE;\par
00357 \par
00358 {\cf19 while}(1)\par
00359 \{\par
00360   firstSector = getFirstSector (cluster);\par
00361 \par
00362   {\cf19 for}(j=0; j<sectorPerCluster; j++)\par
00363   \{\par
00364     SD_readSingleBlock(firstSector + j);\par
00365     \par
00366     {\cf19 for}(k=0; k<512; k++)\par
00367     \{\par
00368       {\cf20 // transmitByte(buffer[k]);}\par
00369       {\cf19 if} ((byteCounter++) >= fileSize ) {\cf19 return} 0;\par
00370     \}\par
00371   \}\par
00372   cluster = getSetNextCluster (cluster, GET, 0);\par
00373   {\cf19 if}(cluster == 0) \{uart_puts_P({\cf22 "Error in getting cluster"}); {\cf19 return} 0;\}\par
00374 \}\par
00375 {\cf19 return} 0;\par
00376 \}\par
00377 \par
00378 {\cf20 //***************************************************************************}\par
00379 {\cf20 //Function: to convert normal short file name into FAT format}\par
00380 {\cf20 //Arguments: pointer to the file name}\par
00381 {\cf20 //return: 0, if successful else 1.}\par
00382 {\cf20 //***************************************************************************}\par
00383 {\cf18 unsigned} {\cf18 char} convertFileName ({\cf18 unsigned} {\cf18 char} *fileName)\par
00384 \{\par
00385 {\cf18 unsigned} {\cf18 char} fileNameFAT[11];\par
00386 {\cf18 unsigned} {\cf18 char} j, k;\par
00387 \par
00388 {\cf20 // uart_puts_P("cvt: start\\r\\n");}\par
00389 \par
00390 {\cf19 for}(j=0; j<12; j++)\par
00391   {\cf19 if}(fileName[j] == {\cf23 '.'}) {\cf19 break};\par
00392 \par
00393 {\cf20 // uart_puts_P("cvt: dot at ");}\par
00394 {\cf20 // transmitByte(j + '0');}\par
00395 {\cf20 // uart_puts_P("\\r\\n");}\par
00396 \par
00397 {\cf19 if}(j>8) \{\par
00398   {\cf20 // uart_puts_P("cvt: name too long\\r\\n");}\par
00399   {\cf19 return} 1;\par
00400 \}\par
00401 \par
00402 {\cf19 for}(k=0; k<j; k++)\par
00403   fileNameFAT[k] = fileName[k];\par
00404 \par
00405 {\cf19 for}(k=j; k<=7; k++)\par
00406   fileNameFAT[k] = {\cf23 ' '};\par
00407 \par
00408 uart_puts_P({\cf22 "cvt: name done\\r\\n"});\par
00409 \par
00410 j++;\par
00411 {\cf19 for}(k=8; k<11; k++)\par
00412 \{\par
00413   {\cf19 if}(fileName[j] != 0)\par
00414     fileNameFAT[k] = fileName[j++];\par
00415   {\cf19 else}\par
00416     {\cf19 while}(k<11)\par
00417       fileNameFAT[k++] = {\cf23 ' '};\par
00418 \}\par
00419 \par
00420 uart_puts_P({\cf22 "cvt: ext done\\r\\n"});\par
00421 \par
00422 {\cf19 for}(j=0; j<11; j++)\par
00423   {\cf19 if}((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))\par
00424     fileNameFAT[j] -= 0x20;\par
00425 \par
00426 uart_puts_P({\cf22 "cvt: caps done\\r\\n"});\par
00427 \par
00428 {\cf19 for}(j=0; j<11; j++)\par
00429   fileName[j] = fileNameFAT[j];\par
00430 \par
00431 uart_puts_P({\cf22 "cvt: OK\\r\\n"});\par
00432 \par
00433 {\cf19 return} 0;\par
00434 \}\par
00435 \par
00436 {\cf20 //************************************************************************************}\par
00437 {\cf20 //Function: to create a file in FAT32 format in the root directory if given }\par
00438 {\cf20 //          file name does not exist; if the file already exists then append the data}\par
00439 {\cf20 //Arguments: pointer to the file name}\par
00440 {\cf20 //return: none}\par
00441 {\cf20 //************************************************************************************}\par
00442 {\cf18 unsigned} {\cf18 char} writeFile ({\cf18 unsigned} {\cf18 char} *fileName)\par
00443 \{\par
00444 uart_puts_P({\cf22 "writeFile: Started\\r\\n"});\par
00445 {\cf18 unsigned} {\cf18 char} j,k, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;\par
00446 {\cf18 unsigned} {\cf18 int} i, firstClusterHigh=0, firstClusterLow=0;\par
00447 {\cf17 struct }dir_Structure *dir;\par
00448 {\cf18 unsigned} {\cf18 long} cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;\par
00449 \par
00450 uart_puts_P({\cf22 "writeFile: Verifying file...\\r\\n"});\par
00451 j = readFile (VERIFY, fileName);\par
00452 uart_puts_P({\cf22 "writeFile: Verify result = "});\par
00453 transmitByte(j + {\cf23 '0'});\par
00454 uart_puts_P({\cf22 "\\r\\n"});\par
00455 \par
00456 {\cf19 if}(j == 1) \par
00457 \{\par
00458   uart_puts_P({\cf22 "writeFile: File exists, appending...\\r\\n"});\par
00459   appendFile = 1;\par
00460   cluster = appendStartCluster;\par
00461   clusterCount=0;\par
00462   {\cf19 while}(1)\par
00463   \{\par
00464     nextCluster = getSetNextCluster (cluster, GET, 0);\par
00465     {\cf19 if}(nextCluster == EOF) {\cf19 break};\par
00466   cluster = nextCluster;\par
00467   clusterCount++;\par
00468   \}\par
00469   uart_puts_P({\cf22 "writeFile: Cluster count = "});\par
00470   transmitHex(LONG, clusterCount);\par
00471   uart_puts_P({\cf22 "\\r\\n"});\par
00472 \par
00473   sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector;\par
00474   start = 1;\par
00475 \}\par
00476 {\cf19 else} {\cf19 if}(j == 2) \par
00477 \{\par
00478    uart_puts_P({\cf22 "writeFile: Invalid filename\\r\\n"});\par
00479    {\cf19 return} 1;\par
00480 \}\par
00481 {\cf19 else}\par
00482 \{\par
00483   uart_puts_P({\cf22 "writeFile: Creating new file...\\r\\n"});\par
00484   cluster = getSetFreeCluster (NEXT_FREE, GET, 0);\par
00485   uart_puts_P({\cf22 "writeFile: Next free cluster = "});\par
00486   transmitHex(LONG, cluster);\par
00487   uart_puts_P({\cf22 "\\r\\n"});\par
00488   \par
00489   {\cf19 if}(cluster > totalClusters)\par
00490      cluster = rootCluster;\par
00491 \par
00492   cluster = searchNextFreeCluster(cluster);\par
00493   {\cf19 if}(cluster == 0)\par
00494   \{\par
00495     uart_puts_P({\cf22 "writeFile: No free cluster!\\r\\n"});\par
00496     {\cf19 return} 1;\par
00497   \}\par
00498   uart_puts_P({\cf22 "writeFile: Using cluster = "});\par
00499   transmitHex(LONG, cluster);\par
00500   uart_puts_P({\cf22 "\\r\\n"});\par
00501   \par
00502   getSetNextCluster(cluster, SET, EOF);\par
00503   firstClusterHigh = ({\cf18 unsigned} int) ((cluster & 0xffff0000) >> 16 );\par
00504   firstClusterLow = ({\cf18 unsigned} int) ( cluster & 0x0000ffff);\par
00505   fileSize = 0;\par
00506 \}\par
00507 \par
00508 k=0;\par
00509 uart_puts_P({\cf22 "writeFile: Writing data...\\r\\n"});\par
00510 \par
00511 {\cf19 while}(1)\par
00512 \{\par
00513    {\cf19 if}(start)\par
00514    \{\par
00515       start = 0;\par
00516     startBlock = getFirstSector (cluster) + sector;\par
00517     SD_readSingleBlock (startBlock);\par
00518     i = fileSize % bytesPerSector;\par
00519     j = sector;\par
00520    \}\par
00521    {\cf19 else}\par
00522    \{\par
00523       startBlock = getFirstSector (cluster);\par
00524     i=0;\par
00525     j=0;\par
00526    \}\par
00527    \par
00528    {\cf19 do}\par
00529    \{\par
00530    data = dataString[k++];\par
00531      buffer[i++] = data;\par
00532    fileSize++;\par
00533      \par
00534      {\cf19 if}(i >= 512)\par
00535    \{\par
00536      i=0;\par
00537      error = SD_writeSingleBlock (startBlock);\par
00538        j++;\par
00539      {\cf19 if}(j == sectorPerCluster) \{j = 0; {\cf19 break};\}\par
00540      startBlock++; \par
00541      \}\par
00542    \} {\cf19 while}((data != {\cf23 '\\n'}) && (k < MAX_STRING_SIZE));\par
00543 \par
00544    {\cf19 if}((data == {\cf23 '\\n'}) || (k >= MAX_STRING_SIZE))\par
00545    \{\par
00546       uart_puts_P({\cf22 "writeFile: End of data\\r\\n"});\par
00547       {\cf19 for}(;i<512;i++)\par
00548         buffer[i]= 0x00;\par
00549       error = SD_writeSingleBlock (startBlock);\par
00550       {\cf19 break};\par
00551    \} \par
00552  \par
00553    prevCluster = cluster;\par
00554    cluster = searchNextFreeCluster(prevCluster);\par
00555 \par
00556    {\cf19 if}(cluster == 0)\par
00557    \{\par
00558       uart_puts_P({\cf22 "writeFile: No free cluster during write!\\r\\n"});\par
00559     {\cf19 return} 1;\par
00560    \}\par
00561 \par
00562    getSetNextCluster(prevCluster, SET, cluster);\par
00563    getSetNextCluster(cluster, SET, EOF);\par
00564 \}        \par
00565 \par
00566 getSetFreeCluster (NEXT_FREE, SET, cluster);\par
00567 \par
00568 error = getDateTime_FAT();\par
00569 {\cf19 if}(error) \{ dateFAT = 0; timeFAT = 0;\}\par
00570 \par
00571 {\cf19 if}(appendFile)\par
00572 \{\par
00573   uart_puts_P({\cf22 "writeFile: Updating directory entry...\\r\\n"});\par
00574   SD_readSingleBlock (appendFileSector);    \par
00575   dir = ({\cf17 struct }dir_Structure *) &buffer[appendFileLocation]; \par
00576 \par
00577   dir->lastAccessDate = 0;\par
00578   dir->writeTime = timeFAT;\par
00579   dir->writeDate = dateFAT;\par
00580   extraMemory = fileSize - dir->fileSize;\par
00581   dir->fileSize = fileSize;\par
00582   SD_writeSingleBlock (appendFileSector);\par
00583   freeMemoryUpdate (REMOVE, extraMemory);\par
00584 \par
00585   uart_puts_P({\cf22 "writeFile: File appended successfully\\r\\n"});\par
00586   {\cf19 return} 0;\par
00587 \}\par
00588 \par
00589 {\cf20 //executes following portion when new file is created}\par
00590 \par
00591 prevCluster = rootCluster; {\cf20 //root cluster}\par
00592 \par
00593 {\cf19 while}(1)\par
00594 \{\par
00595    firstSector = getFirstSector (prevCluster);\par
00596 \par
00597    {\cf19 for}(sector = 0; sector < sectorPerCluster; sector++)\par
00598    \{\par
00599      SD_readSingleBlock (firstSector + sector);\par
00600     \par
00601 \par
00602      {\cf19 for}(i=0; i<bytesPerSector; i+=32)\par
00603      \{\par
00604         dir = ({\cf17 struct }dir_Structure *) &buffer[i];\par
00605 \par
00606         {\cf19 if}(fileCreatedFlag)   {\cf20 //to mark last directory entry with 0x00 (empty) mark}\par
00607          \{                    {\cf20 //indicating end of the directory file list}\par
00608            {\cf20 //dir->name[0] = EMPTY;}\par
00609            {\cf20 //SD_writeSingleBlock (firstSector + sector);}\par
00610            {\cf19 return} 0;\par
00611          \}\par
00612 \par
00613         {\cf19 if}((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  {\cf20 //looking for an empty slot to enter file info}\par
00614         \{\par
00615           {\cf19 for}(j=0; j<11; j++)\par
00616             dir->name[j] = fileName[j];\par
00617           dir->attrib = ATTR_ARCHIVE;   {\cf20 //settting file attribute as 'archive'}\par
00618           dir->NTreserved = 0;          {\cf20 //always set to 0}\par
00619           dir->timeTenth = 0;           {\cf20 //always set to 0}\par
00620           dir->createTime = timeFAT;    {\cf20 //setting time of file creation, obtained from RTC}\par
00621           dir->createDate = dateFAT;    {\cf20 //setting date of file creation, obtained from RTC}\par
00622           dir->lastAccessDate = 0;      {\cf20 //date of last access ignored}\par
00623           dir->writeTime = timeFAT;     {\cf20 //setting new time of last write, obtained from RTC}\par
00624           dir->writeDate = dateFAT;     {\cf20 //setting new date of last write, obtained from RTC}\par
00625           dir->firstClusterHI = firstClusterHigh;\par
00626           dir->firstClusterLO = firstClusterLow;\par
00627           dir->fileSize = fileSize;\par
00628 \par
00629           SD_writeSingleBlock (firstSector + sector);\par
00630           fileCreatedFlag = 1;\par
00631 \par
00632           {\cf20 //TX_NEWLINE;}\par
00633           {\cf20 //TX_NEWLINE;}\par
00634           {\cf20 //uart_puts_P(PSTR(" File Created! "));}\par
00635 \par
00636           freeMemoryUpdate (REMOVE, fileSize); {\cf20 //updating free memory count in FSinfo sector}\par
00637          \par
00638         \}\par
00639      \}\par
00640    \}\par
00641 \par
00642    cluster = getSetNextCluster (prevCluster, GET, 0);\par
00643 \par
00644    {\cf19 if}(cluster > 0x0ffffff6)\par
00645    \{\par
00646       {\cf19 if}(cluster == EOF)   {\cf20 //this situation will come when total files in root is multiple of (32*sectorPerCluster)}\par
00647       \{  \par
00648         cluster = searchNextFreeCluster(prevCluster); {\cf20 //find next cluster for root directory entries}\par
00649         getSetNextCluster(prevCluster, SET, cluster); {\cf20 //link the new cluster of root to the previous cluster}\par
00650         getSetNextCluster(cluster, SET, EOF);  {\cf20 //set the new cluster as end of the root directory}\par
00651       \} \par
00652 \par
00653       {\cf19 else}\par
00654       \{ \par
00655         uart_puts_P({\cf22 "End of Cluster Chain"}); \par
00656         {\cf19 return} 1;\par
00657       \}\par
00658    \}\par
00659    {\cf19 if}(cluster == 0) \{uart_puts_P({\cf22 "Error in getting cluster"}); {\cf19 return} 1;\}\par
00660    \par
00661    prevCluster = cluster;\par
00662  \}\par
00663  \par
00664  {\cf19 return} 0;\par
00665 \}\par
00666 \par
00667 \par
00668 {\cf20 //***************************************************************************}\par
00669 {\cf20 //Function: to search for the next free cluster in the root directory}\par
00670 {\cf20 //          starting from a specified cluster}\par
00671 {\cf20 //Arguments: Starting cluster}\par
00672 {\cf20 //return: the next free cluster}\par
00673 {\cf20 //****************************************************************}\par
00674 {\cf18 unsigned} {\cf18 long} searchNextFreeCluster ({\cf18 unsigned} {\cf18 long} startCluster)\par
00675 \{\par
00676   {\cf18 unsigned} {\cf18 long} cluster, *value, sector;\par
00677   {\cf18 unsigned} {\cf18 char} i;\par
00678     \par
00679     startCluster -=  (startCluster % 128);   {\cf20 //to start with the first file in a FAT sector}\par
00680     {\cf19 for}(cluster =startCluster; cluster <totalClusters; cluster+=128) \par
00681     \{\par
00682       sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);\par
00683       SD_readSingleBlock(sector);\par
00684       {\cf19 for}(i=0; i<128; i++)\par
00685       \{\par
00686          value = ({\cf18 unsigned} {\cf18 long} *) &buffer[i*4];\par
00687          {\cf19 if}(((*value) & 0x0fffffff) == 0)\par
00688             {\cf19 return}(cluster+i);\par
00689       \}  \par
00690     \} \par
00691 \par
00692  {\cf19 return} 0;\par
00693 \}\par
00694 \par
00695 {\cf20 //************************************************************}\par
00696 {\cf20 //Function: To convert the unsigned long value of memory into }\par
00697 {\cf20 //          text string and send to UART}\par
00698 {\cf20 //Arguments: 1. unsigned char flag. If flag is HIGH, memory will be displayed in KBytes, else in Bytes. }\par
00699 {\cf20 //           2. unsigned long memory value}\par
00700 {\cf20 //return: none}\par
00701 {\cf20 //************************************************************}\par
00702 {\cf18 void} displayMemory ({\cf18 unsigned} {\cf18 char} flag, {\cf18 unsigned} {\cf18 long} memory)\par
00703 \{\par
00704   {\cf18 unsigned} {\cf18 char} memoryString[] = {\cf22 "              Bytes"}; {\cf20 //19 character long string for memory display}\par
00705   {\cf18 unsigned} {\cf18 char} i;\par
00706   {\cf19 for}(i=12; i>0; i--) {\cf20 //converting freeMemory into ASCII string}\par
00707   \{\par
00708     {\cf19 if}(i==5 || i==9) \par
00709     \{\par
00710        memoryString[i-1] = {\cf23 ','};  \par
00711        i--;\par
00712     \}\par
00713     memoryString[i-1] = (memory % 10) | 0x30;\par
00714     memory /= 10;\par
00715     {\cf19 if}(memory == 0) {\cf19 break};\par
00716   \}\par
00717   {\cf19 if}(flag == HIGH)  memoryString[13] = {\cf23 'K'};\par
00718   transmitString(memoryString);\par
00719 \}\par
00720 \par
00721 {\cf20 //********************************************************************}\par
00722 {\cf20 //Function: to delete a specified file from the root directory}\par
00723 {\cf20 //Arguments: pointer to the file name}\par
00724 {\cf20 //return: none}\par
00725 {\cf20 //********************************************************************}\par
00726 {\cf18 void} deleteFile ({\cf18 unsigned} {\cf18 char} *fileName)\par
00727 \{\par
00728   {\cf18 unsigned} {\cf18 char} error;\par
00729 \par
00730   error = convertFileName (fileName);\par
00731   {\cf19 if}(error) {\cf19 return};\par
00732 \par
00733   findFiles (DELETE, fileName);\par
00734 \}\par
00735 \par
00736 {\cf20 //********************************************************************}\par
00737 {\cf20 //Function: update the free memory count in the FSinfo sector. }\par
00738 {\cf20 //          Whenever a file is deleted or created, this function will be called}\par
00739 {\cf20 //          to ADD or REMOVE clusters occupied by the file}\par
00740 {\cf20 //Arguments: #1.flag ADD or REMOVE #2.file size in Bytes}\par
00741 {\cf20 //return: none}\par
00742 {\cf20 //********************************************************************}\par
00743 {\cf18 void} freeMemoryUpdate ({\cf18 unsigned} {\cf18 char} flag, {\cf18 unsigned} {\cf18 long} size)\par
00744 \{\par
00745   {\cf18 unsigned} {\cf18 long} freeClusters;\par
00746   {\cf20 //convert file size into number of clusters occupied}\par
00747   {\cf19 if}((size % 512) == 0) size = size / 512;\par
00748   {\cf19 else} size = (size / 512) +1;\par
00749   {\cf19 if}((size % 8) == 0) size = size / 8;\par
00750   {\cf19 else} size = (size / 8) +1;\par
00751 \par
00752   {\cf19 if}(freeClusterCountUpdated)\par
00753   \{\par
00754     freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);\par
00755     {\cf19 if}(flag == ADD)\par
00756        freeClusters = freeClusters + size;\par
00757     {\cf19 else}  {\cf20 //when flag = REMOVE}\par
00758        freeClusters = freeClusters - size;\par
00759     getSetFreeCluster (TOTAL_FREE, SET, freeClusters);\par
00760   \}\par
00761 \}\par
00762 \par
00763 {\cf20 //******** END ****** www.dharmanitech.com *****}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/FAT32/FAT32.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/FAT32/FAT32.h}
{\xe \v lib/FAT32/FAT32.h}
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MBRinfo_Structure}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b partitionInfo_Structure}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BS_Structure}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b FSInfo_Structure}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dir_Structure}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATTR_READ_ONLY}\~ 0x01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATTR_HIDDEN}\~ 0x02\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATTR_SYSTEM}\~ 0x04\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATTR_VOLUME_ID}\~ 0x08\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATTR_DIRECTORY}\~ 0x10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATTR_ARCHIVE}\~ 0x20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATTR_LONG_NAME}\~ 0x0f\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DIR_ENTRY_SIZE}\~ 0x32\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EMPTY}\~ 0x00\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DELETED}\~ 0xe5\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GET}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SET}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b READ}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VERIFY}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADD}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REMOVE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LOW}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HIGH}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOTAL_FREE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NEXT_FREE}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GET_LIST}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GET_FILE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DELETE}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EOF}\~ 0x0fffffff\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_STRING_SIZE}\~ 100\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b getBootSectorData} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b getFirstSector} (unsigned long clusterNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b getSetFreeCluster} (unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dir_Structure} * {\b findFiles} (unsigned char flag, unsigned char *fileName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b getSetNextCluster} (unsigned long clusterNumber, unsigned char get_set, unsigned long clusterEntry)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b readFile} (unsigned char flag, unsigned char *fileName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b convertFileName} (unsigned char *fileName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b writeFile} (unsigned char *fileName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b appendFile} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b searchNextFreeCluster} (unsigned long startCluster)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b displayMemory} (unsigned char flag, unsigned long memory)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b deleteFile} (unsigned char *fileName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b freeMemoryUpdate} (unsigned char flag, unsigned long size)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned long {\b firstDataSector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned long {\b rootCluster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned long {\b totalClusters}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned int {\b bytesPerSector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned int {\b sectorPerCluster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned int {\b reservedSectorCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b unusedSectors}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b appendFileSector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b appendFileLocation}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b fileSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b appendStartCluster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b freeClusterCountUpdated}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned char {\b dataString} [{\b MAX_STRING_SIZE}]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ADD\:FAT32.h}
{\xe \v FAT32.h\:ADD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADD\~ 0}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b FAT32.h}.}\par
}
{\xe \v ATTR_ARCHIVE\:FAT32.h}
{\xe \v FAT32.h\:ATTR_ARCHIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATTR_ARCHIVE\~ 0x20}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b FAT32.h}.}\par
}
{\xe \v ATTR_DIRECTORY\:FAT32.h}
{\xe \v FAT32.h\:ATTR_DIRECTORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATTR_DIRECTORY\~ 0x10}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b FAT32.h}.}\par
}
{\xe \v ATTR_HIDDEN\:FAT32.h}
{\xe \v FAT32.h\:ATTR_HIDDEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATTR_HIDDEN\~ 0x02}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b FAT32.h}.}\par
}
{\xe \v ATTR_LONG_NAME\:FAT32.h}
{\xe \v FAT32.h\:ATTR_LONG_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATTR_LONG_NAME\~ 0x0f}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b FAT32.h}.}\par
}
{\xe \v ATTR_READ_ONLY\:FAT32.h}
{\xe \v FAT32.h\:ATTR_READ_ONLY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATTR_READ_ONLY\~ 0x01}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b FAT32.h}.}\par
}
{\xe \v ATTR_SYSTEM\:FAT32.h}
{\xe \v FAT32.h\:ATTR_SYSTEM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATTR_SYSTEM\~ 0x04}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b FAT32.h}.}\par
}
{\xe \v ATTR_VOLUME_ID\:FAT32.h}
{\xe \v FAT32.h\:ATTR_VOLUME_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATTR_VOLUME_ID\~ 0x08}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b FAT32.h}.}\par
}
{\xe \v DELETE\:FAT32.h}
{\xe \v FAT32.h\:DELETE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DELETE\~ 2}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b FAT32.h}.}\par
}
{\xe \v DELETED\:FAT32.h}
{\xe \v FAT32.h\:DELETED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DELETED\~ 0xe5}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b FAT32.h}.}\par
}
{\xe \v DIR_ENTRY_SIZE\:FAT32.h}
{\xe \v FAT32.h\:DIR_ENTRY_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DIR_ENTRY_SIZE\~ 0x32}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 106} of file {\b FAT32.h}.}\par
}
{\xe \v EMPTY\:FAT32.h}
{\xe \v FAT32.h\:EMPTY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EMPTY\~ 0x00}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b FAT32.h}.}\par
}
{\xe \v EOF\:FAT32.h}
{\xe \v FAT32.h\:EOF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EOF\~ 0x0fffffff}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b FAT32.h}.}\par
}
{\xe \v GET\:FAT32.h}
{\xe \v FAT32.h\:GET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GET\~ 0}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b FAT32.h}.}\par
}
{\xe \v GET_FILE\:FAT32.h}
{\xe \v FAT32.h\:GET_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GET_FILE\~ 1}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 120} of file {\b FAT32.h}.}\par
}
{\xe \v GET_LIST\:FAT32.h}
{\xe \v FAT32.h\:GET_LIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GET_LIST\~ 0}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b FAT32.h}.}\par
}
{\xe \v HIGH\:FAT32.h}
{\xe \v FAT32.h\:HIGH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HIGH\~ 1}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b FAT32.h}.}\par
}
{\xe \v LOW\:FAT32.h}
{\xe \v FAT32.h\:LOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LOW\~ 0}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b FAT32.h}.}\par
}
{\xe \v MAX_STRING_SIZE\:FAT32.h}
{\xe \v FAT32.h\:MAX_STRING_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_STRING_SIZE\~ 100}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b FAT32.h}.}\par
}
{\xe \v NEXT_FREE\:FAT32.h}
{\xe \v FAT32.h\:NEXT_FREE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NEXT_FREE\~ 2}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b FAT32.h}.}\par
}
{\xe \v READ\:FAT32.h}
{\xe \v FAT32.h\:READ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define READ\~ 0}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b FAT32.h}.}\par
}
{\xe \v REMOVE\:FAT32.h}
{\xe \v FAT32.h\:REMOVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REMOVE\~ 1}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b FAT32.h}.}\par
}
{\xe \v SET\:FAT32.h}
{\xe \v FAT32.h\:SET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SET\~ 1}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b FAT32.h}.}\par
}
{\xe \v TOTAL_FREE\:FAT32.h}
{\xe \v FAT32.h\:TOTAL_FREE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOTAL_FREE\~ 1}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b FAT32.h}.}\par
}
{\xe \v VERIFY\:FAT32.h}
{\xe \v FAT32.h\:VERIFY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VERIFY\~ 1}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b FAT32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v appendFile\:FAT32.h}
{\xe \v FAT32.h\:appendFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void appendFile (void )}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v convertFileName\:FAT32.h}
{\xe \v FAT32.h\:convertFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char convertFileName (unsigned char * fileName)}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 383} of file {\b FAT32.c}.}\par
}
{\xe \v deleteFile\:FAT32.h}
{\xe \v FAT32.h\:deleteFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void deleteFile (unsigned char * fileName)}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 726} of file {\b FAT32.c}.}\par
}
{\xe \v displayMemory\:FAT32.h}
{\xe \v FAT32.h\:displayMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void displayMemory (unsigned char flag, unsigned long memory)}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 702} of file {\b FAT32.c}.}\par
}
{\xe \v findFiles\:FAT32.h}
{\xe \v FAT32.h\:findFiles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b dir_Structure} * findFiles (unsigned char flag, unsigned char * fileName)}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b FAT32.c}.}\par
}
{\xe \v freeMemoryUpdate\:FAT32.h}
{\xe \v FAT32.h\:freeMemoryUpdate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void freeMemoryUpdate (unsigned char flag, unsigned long size)}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 743} of file {\b FAT32.c}.}\par
}
{\xe \v getBootSectorData\:FAT32.h}
{\xe \v FAT32.h\:getBootSectorData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char getBootSectorData (void )}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b FAT32.c}.}\par
}
{\xe \v getFirstSector\:FAT32.h}
{\xe \v FAT32.h\:getFirstSector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getFirstSector (unsigned long clusterNumber)}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b FAT32.c}.}\par
}
{\xe \v getSetFreeCluster\:FAT32.h}
{\xe \v FAT32.h\:getSetFreeCluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getSetFreeCluster (unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b FAT32.c}.}\par
}
{\xe \v getSetNextCluster\:FAT32.h}
{\xe \v FAT32.h\:getSetNextCluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long getSetNextCluster (unsigned long clusterNumber, unsigned char get_set, unsigned long clusterEntry)}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b FAT32.c}.}\par
}
{\xe \v readFile\:FAT32.h}
{\xe \v FAT32.h\:readFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char readFile (unsigned char flag, unsigned char * fileName)}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 319} of file {\b FAT32.c}.}\par
}
{\xe \v searchNextFreeCluster\:FAT32.h}
{\xe \v FAT32.h\:searchNextFreeCluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long searchNextFreeCluster (unsigned long startCluster)}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 674} of file {\b FAT32.c}.}\par
}
{\xe \v writeFile\:FAT32.h}
{\xe \v FAT32.h\:writeFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char writeFile (unsigned char * fileName)}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 442} of file {\b FAT32.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v appendFileLocation\:FAT32.h}
{\xe \v FAT32.h\:appendFileLocation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long appendFileLocation}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b FAT32.h}.}\par
}
{\xe \v appendFileSector\:FAT32.h}
{\xe \v FAT32.h\:appendFileSector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long appendFileSector}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b FAT32.h}.}\par
}
{\xe \v appendStartCluster\:FAT32.h}
{\xe \v FAT32.h\:appendStartCluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long appendStartCluster}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b FAT32.h}.}\par
}
{\xe \v bytesPerSector\:FAT32.h}
{\xe \v FAT32.h\:bytesPerSector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned int bytesPerSector}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b FAT32.h}.}\par
}
{\xe \v dataString\:FAT32.h}
{\xe \v FAT32.h\:dataString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned char dataString[{\b MAX_STRING_SIZE}]}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b FAT32.h}.}\par
}
{\xe \v fileSize\:FAT32.h}
{\xe \v FAT32.h\:fileSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long fileSize}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b FAT32.h}.}\par
}
{\xe \v firstDataSector\:FAT32.h}
{\xe \v FAT32.h\:firstDataSector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned long firstDataSector}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b FAT32.h}.}\par
}
{\xe \v freeClusterCountUpdated\:FAT32.h}
{\xe \v FAT32.h\:freeClusterCountUpdated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char freeClusterCountUpdated}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b FAT32.h}.}\par
}
{\xe \v reservedSectorCount\:FAT32.h}
{\xe \v FAT32.h\:reservedSectorCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned int reservedSectorCount}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b FAT32.h}.}\par
}
{\xe \v rootCluster\:FAT32.h}
{\xe \v FAT32.h\:rootCluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned long rootCluster}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b FAT32.h}.}\par
}
{\xe \v sectorPerCluster\:FAT32.h}
{\xe \v FAT32.h\:sectorPerCluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned int sectorPerCluster}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b FAT32.h}.}\par
}
{\xe \v totalClusters\:FAT32.h}
{\xe \v FAT32.h\:totalClusters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned long totalClusters}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b FAT32.h}.}\par
}
{\xe \v unusedSectors\:FAT32.h}
{\xe \v FAT32.h\:unusedSectors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long unusedSectors}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b FAT32.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FAT32.h\par \pard\plain 
{\tc\tcl2 \v lib/FAT32/FAT32.h}
{\xe \v lib/FAT32/FAT32.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //********************************************************}\par
00002 {\cf20 // **** ROUTINES FOR FAT32 IMPLEMATATION OF SD CARD *****}\par
00003 {\cf20 //********************************************************}\par
00004 {\cf20 //Controller        : ATmega32 (Clock: 8 Mhz-internal)}\par
00005 {\cf20 //Compiler          : AVR-GCC (winAVR with AVRStudio-4)}\par
00006 {\cf20 //Project Version   : DL_1.0}\par
00007 {\cf20 //Author            : CC Dharmani, Chennai (India)}\par
00008 {\cf20 //                    www.dharmanitech.com}\par
00009 {\cf20 //Date              : 10 May 2011}\par
00010 {\cf20 //*********************************************************}\par
00011 \par
00012 {\cf21 #ifndef _FAT32_H_}\par
00013 {\cf21 #define _FAT32_H_}\par
00014 \par
00015 {\cf20 //Structure to access Master Boot Record for getting info about partioions}\par
00016 {\cf17 struct }MBRinfo_Structure\{\par
00017 {\cf18 unsigned} {\cf18 char}   nothing[446];       {\cf20 //ignore, placed here to fill the gap in the structure}\par
00018 {\cf18 unsigned} {\cf18 char}   partitionData[64];  {\cf20 //partition records (16x4)}\par
00019 {\cf18 unsigned} {\cf18 int}    signature;      {\cf20 //0xaa55}\par
00020 \};\par
00021 \par
00022 {\cf20 //Structure to access info of the first partioion of the disk }\par
00023 {\cf17 struct }partitionInfo_Structure\{                 \par
00024 {\cf18 unsigned} {\cf18 char}   status;             {\cf20 //0x80 - active partition}\par
00025 {\cf18 unsigned} {\cf18 char}   headStart;          {\cf20 //starting head}\par
00026 {\cf18 unsigned} {\cf18 int}    cylSectStart;       {\cf20 //starting cylinder and sector}\par
00027 {\cf18 unsigned} {\cf18 char}   type;               {\cf20 //partition type }\par
00028 {\cf18 unsigned} {\cf18 char}   headEnd;            {\cf20 //ending head of the partition}\par
00029 {\cf18 unsigned} {\cf18 int}    cylSectEnd;         {\cf20 //ending cylinder and sector}\par
00030 {\cf18 unsigned} {\cf18 long}   firstSector;        {\cf20 //total sectors between MBR & the first sector of the partition}\par
00031 {\cf18 unsigned} {\cf18 long}   sectorsTotal;       {\cf20 //size of this partition in sectors}\par
00032 \};\par
00033 \par
00034 {\cf20 //Structure to access boot sector data}\par
00035 {\cf17 struct }BS_Structure\{\par
00036 {\cf18 unsigned} {\cf18 char} jumpBoot[3]; {\cf20 //default: 0x009000EB}\par
00037 {\cf18 unsigned} {\cf18 char} OEMName[8];\par
00038 {\cf18 unsigned} {\cf18 int} bytesPerSector; {\cf20 //deafault: 512}\par
00039 {\cf18 unsigned} {\cf18 char} sectorPerCluster;\par
00040 {\cf18 unsigned} {\cf18 int} reservedSectorCount;\par
00041 {\cf18 unsigned} {\cf18 char} numberofFATs;\par
00042 {\cf18 unsigned} {\cf18 int} rootEntryCount;\par
00043 {\cf18 unsigned} {\cf18 int} totalSectors_F16; {\cf20 //must be 0 for FAT32}\par
00044 {\cf18 unsigned} {\cf18 char} mediaType;\par
00045 {\cf18 unsigned} {\cf18 int} FATsize_F16; {\cf20 //must be 0 for FAT32}\par
00046 {\cf18 unsigned} {\cf18 int} sectorsPerTrack;\par
00047 {\cf18 unsigned} {\cf18 int} numberofHeads;\par
00048 {\cf18 unsigned} {\cf18 long} hiddenSectors;\par
00049 {\cf18 unsigned} {\cf18 long} totalSectors_F32;\par
00050 {\cf18 unsigned} {\cf18 long} FATsize_F32; {\cf20 //count of sectors occupied by one FAT}\par
00051 {\cf18 unsigned} {\cf18 int} extFlags;\par
00052 {\cf18 unsigned} {\cf18 int} FSversion; {\cf20 //0x0000 (defines version 0.0)}\par
00053 {\cf18 unsigned} {\cf18 long} rootCluster; {\cf20 //first cluster of root directory (=2)}\par
00054 {\cf18 unsigned} {\cf18 int} FSinfo; {\cf20 //sector number of FSinfo structure (=1)}\par
00055 {\cf18 unsigned} {\cf18 int} BackupBootSector;\par
00056 {\cf18 unsigned} {\cf18 char} reserved[12];\par
00057 {\cf18 unsigned} {\cf18 char} driveNumber;\par
00058 {\cf18 unsigned} {\cf18 char} reserved1;\par
00059 {\cf18 unsigned} {\cf18 char} bootSignature;\par
00060 {\cf18 unsigned} {\cf18 long} volumeID;\par
00061 {\cf18 unsigned} {\cf18 char} volumeLabel[11]; {\cf20 //"NO NAME "}\par
00062 {\cf18 unsigned} {\cf18 char} fileSystemType[8]; {\cf20 //"FAT32"}\par
00063 {\cf18 unsigned} {\cf18 char} bootData[420];\par
00064 {\cf18 unsigned} {\cf18 int} bootEndSignature; {\cf20 //0xaa55}\par
00065 \};\par
00066 \par
00067 \par
00068 {\cf20 //Structure to access FSinfo sector data}\par
00069 {\cf17 struct }FSInfo_Structure\par
00070 \{\par
00071 {\cf18 unsigned} {\cf18 long} leadSignature; {\cf20 //0x41615252}\par
00072 {\cf18 unsigned} {\cf18 char} reserved1[480];\par
00073 {\cf18 unsigned} {\cf18 long} structureSignature; {\cf20 //0x61417272}\par
00074 {\cf18 unsigned} {\cf18 long} freeClusterCount; {\cf20 //initial: 0xffffffff}\par
00075 {\cf18 unsigned} {\cf18 long} nextFreeCluster; {\cf20 //initial: 0xffffffff}\par
00076 {\cf18 unsigned} {\cf18 char} reserved2[12];\par
00077 {\cf18 unsigned} {\cf18 long} trailSignature; {\cf20 //0xaa550000}\par
00078 \};\par
00079 \par
00080 {\cf20 //Structure to access Directory Entry in the FAT}\par
00081 {\cf17 struct }dir_Structure\{\par
00082 {\cf18 unsigned} {\cf18 char} name[11];\par
00083 {\cf18 unsigned} {\cf18 char} attrib; {\cf20 //file attributes}\par
00084 {\cf18 unsigned} {\cf18 char} NTreserved; {\cf20 //always 0}\par
00085 {\cf18 unsigned} {\cf18 char} timeTenth; {\cf20 //tenths of seconds, set to 0 here}\par
00086 {\cf18 unsigned} {\cf18 int} createTime; {\cf20 //time file was created}\par
00087 {\cf18 unsigned} {\cf18 int} createDate; {\cf20 //date file was created}\par
00088 {\cf18 unsigned} {\cf18 int} lastAccessDate;\par
00089 {\cf18 unsigned} {\cf18 int} firstClusterHI; {\cf20 //higher word of the first cluster number}\par
00090 {\cf18 unsigned} {\cf18 int} writeTime; {\cf20 //time of last write}\par
00091 {\cf18 unsigned} {\cf18 int} writeDate; {\cf20 //date of last write}\par
00092 {\cf18 unsigned} {\cf18 int} firstClusterLO; {\cf20 //lower word of the first cluster number}\par
00093 {\cf18 unsigned} {\cf18 long} fileSize; {\cf20 //size of file in bytes}\par
00094 \};\par
00095 \par
00096 {\cf20 //Attribute definitions for file/directory}\par
00097 {\cf21 #define ATTR_READ_ONLY     0x01}\par
00098 {\cf21 #define ATTR_HIDDEN        0x02}\par
00099 {\cf21 #define ATTR_SYSTEM        0x04}\par
00100 {\cf21 #define ATTR_VOLUME_ID     0x08}\par
00101 {\cf21 #define ATTR_DIRECTORY     0x10}\par
00102 {\cf21 #define ATTR_ARCHIVE       0x20}\par
00103 {\cf21 #define ATTR_LONG_NAME     0x0f}\par
00104 \par
00105 \par
00106 {\cf21 #define DIR_ENTRY_SIZE     0x32}\par
00107 {\cf21 #define EMPTY              0x00}\par
00108 {\cf21 #define DELETED            0xe5}\par
00109 {\cf21 #define GET     0}\par
00110 {\cf21 #define SET     1}\par
00111 {\cf21 #define READ    0}\par
00112 {\cf21 #define VERIFY  1}\par
00113 {\cf21 #define ADD     0}\par
00114 {\cf21 #define REMOVE  1}\par
00115 {\cf21 #define LOW     0}\par
00116 {\cf21 #define HIGH    1   }\par
00117 {\cf21 #define TOTAL_FREE   1}\par
00118 {\cf21 #define NEXT_FREE    2}\par
00119 {\cf21 #define GET_LIST     0}\par
00120 {\cf21 #define GET_FILE     1}\par
00121 {\cf21 #define DELETE       2}\par
00122 {\cf21 #define EOF     0x0fffffff}\par
00123 \par
00124 \par
00125 {\cf21 #define MAX_STRING_SIZE     100  }{\cf20 //defining the maximum size of the dataString}\par
00126 \par
00127 \par
00128 {\cf20 //************* external variables *************}\par
00129 {\cf17 volatile} {\cf18 unsigned} {\cf18 long} firstDataSector, rootCluster, totalClusters;\par
00130 {\cf17 volatile} {\cf18 unsigned} {\cf18 int}  bytesPerSector, sectorPerCluster, reservedSectorCount;\par
00131 {\cf18 unsigned} {\cf18 long} unusedSectors, appendFileSector, appendFileLocation, fileSize, appendStartCluster;\par
00132 \par
00133 {\cf20 //global flag to keep track of free cluster count updating in FSinfo sector}\par
00134 {\cf18 unsigned} {\cf18 char} freeClusterCountUpdated;\par
00135 \par
00136 {\cf20 //data string where data is collected before sending to the card}\par
00137 {\cf17 volatile} {\cf18 unsigned} {\cf18 char} dataString[MAX_STRING_SIZE];\par
00138 \par
00139 \par
00140 \par
00141 {\cf20 //************* functions *************}\par
00142 {\cf18 unsigned} {\cf18 char} getBootSectorData ({\cf18 void});\par
00143 {\cf18 unsigned} {\cf18 long} getFirstSector({\cf18 unsigned} {\cf18 long} clusterNumber);\par
00144 {\cf18 unsigned} {\cf18 long} getSetFreeCluster({\cf18 unsigned} {\cf18 char} totOrNext, {\cf18 unsigned} {\cf18 char} get_set, {\cf18 unsigned} {\cf18 long} FSEntry);\par
00145 {\cf17 struct }dir_Structure* findFiles ({\cf18 unsigned} {\cf18 char} flag, {\cf18 unsigned} {\cf18 char} *fileName);\par
00146 {\cf18 unsigned} {\cf18 long} getSetNextCluster ({\cf18 unsigned} {\cf18 long} clusterNumber,{\cf18 unsigned} {\cf18 char} get_set,{\cf18 unsigned} {\cf18 long} clusterEntry);\par
00147 {\cf18 unsigned} {\cf18 char} readFile ({\cf18 unsigned} {\cf18 char} flag, {\cf18 unsigned} {\cf18 char} *fileName);\par
00148 {\cf18 unsigned} {\cf18 char} convertFileName ({\cf18 unsigned} {\cf18 char} *fileName);\par
00149 {\cf18 unsigned} {\cf18 char} writeFile ({\cf18 unsigned} {\cf18 char} *fileName);\par
00150 {\cf18 void} appendFile ({\cf18 void});\par
00151 {\cf18 unsigned} {\cf18 long} searchNextFreeCluster ({\cf18 unsigned} {\cf18 long} startCluster);\par
00152 {\cf18 void} displayMemory ({\cf18 unsigned} {\cf18 char} flag, {\cf18 unsigned} {\cf18 long} memory);\par
00153 {\cf18 void} deleteFile ({\cf18 unsigned} {\cf18 char} *fileName);\par
00154 {\cf18 void} freeMemoryUpdate ({\cf18 unsigned} {\cf18 char} flag, {\cf18 unsigned} {\cf18 long} size);\par
00155 \par
00156 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/gas_index_algorithm/sensirion_gas_index_algorithm.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/gas_index_algorithm/sensirion_gas_index_algorithm.c}
{\xe \v lib/gas_index_algorithm/sensirion_gas_index_algorithm.c}
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "sensirion_gas_index_algorithm.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FIX16_MAXIMUM}\~ 0x7FFFFFFF\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FIX16_MINIMUM}\~ 0x80000000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FIX16_OVERFLOW}\~ 0x80000000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FIX16_ONE}\~ 0x00010000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NUM_EXP_VALUES}\~ 4\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GasIndexAlgorithm_init} ({\b GasIndexAlgorithmParams} *params, int32_t algorithm_type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GasIndexAlgorithm_reset} ({\b GasIndexAlgorithmParams} *params)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GasIndexAlgorithm_get_states} (const {\b GasIndexAlgorithmParams} *params, int32_t *state0, int32_t *state1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GasIndexAlgorithm_set_states} ({\b GasIndexAlgorithmParams} *params, int32_t state0, int32_t state1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GasIndexAlgorithm_set_tuning_parameters} ({\b GasIndexAlgorithmParams} *params, int32_t index_offset, int32_t learning_time_offset_hours, int32_t learning_time_gain_hours, int32_t gating_max_duration_minutes, int32_t std_initial, int32_t gain_factor)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GasIndexAlgorithm_get_tuning_parameters} (const {\b GasIndexAlgorithmParams} *params, int32_t *index_offset, int32_t *learning_time_offset_hours, int32_t *learning_time_gain_hours, int32_t *gating_max_duration_minutes, int32_t *std_initial, int32_t *gain_factor)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GasIndexAlgorithm_process} ({\b GasIndexAlgorithmParams} *params, int32_t sraw, int32_t *gas_index)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v FIX16_MAXIMUM\:sensirion_gas_index_algorithm.c}
{\xe \v sensirion_gas_index_algorithm.c\:FIX16_MAXIMUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FIX16_MAXIMUM\~ 0x7FFFFFFF}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< the maximum value of {\b fix16_t} the minimum value of {\b fix16_t} \par
}{
Definition at line {\b 35} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v FIX16_MINIMUM\:sensirion_gas_index_algorithm.c}
{\xe \v sensirion_gas_index_algorithm.c\:FIX16_MINIMUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FIX16_MINIMUM\~ 0x80000000}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the value used to indicate overflows when FIXMATH_NO_OVERFLOW is not specified \par
}{
Definition at line {\b 37} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v FIX16_ONE\:sensirion_gas_index_algorithm.c}
{\xe \v sensirion_gas_index_algorithm.c\:FIX16_ONE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FIX16_ONE\~ 0x00010000}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v FIX16_OVERFLOW\:sensirion_gas_index_algorithm.c}
{\xe \v sensirion_gas_index_algorithm.c\:FIX16_OVERFLOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FIX16_OVERFLOW\~ 0x80000000}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b fix16_t} value of 1 \par
}{
Definition at line {\b 40} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v NUM_EXP_VALUES\:sensirion_gas_index_algorithm.c}
{\xe \v sensirion_gas_index_algorithm.c\:NUM_EXP_VALUES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NUM_EXP_VALUES\~ 4}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v GasIndexAlgorithm_get_states\:sensirion_gas_index_algorithm.c}
{\xe \v sensirion_gas_index_algorithm.c\:GasIndexAlgorithm_get_states}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GasIndexAlgorithm_get_states (const {\b GasIndexAlgorithmParams} * params, int32_t * state0, int32_t * state1)}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get current algorithm states. Retrieved values can be used in {\b GasIndexAlgorithm_set_states()} to resume operation after a short interruption, skipping initial learning phase. NOTE: This feature can only be used for VOC algorithm type and after at least 3 hours of continuous operation. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i params} \cell }{Pointer to the {\b GasIndexAlgorithmParams} struct \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state0} \cell }{State0 to be stored \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state1} \cell }{State1 to be stored \cell }
{\row }
}
}{
Definition at line {\b 380} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v GasIndexAlgorithm_get_tuning_parameters\:sensirion_gas_index_algorithm.c}
{\xe \v sensirion_gas_index_algorithm.c\:GasIndexAlgorithm_get_tuning_parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GasIndexAlgorithm_get_tuning_parameters (const {\b GasIndexAlgorithmParams} * params, int32_t * index_offset, int32_t * learning_time_offset_hours, int32_t * learning_time_gain_hours, int32_t * gating_max_duration_minutes, int32_t * std_initial, int32_t * gain_factor)}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get current parameters to customize the gas index algorithm. Refer to {\b GasIndexAlgorithm_set_tuning_parameters()} for description of the parameters. \par
}{
Definition at line {\b 416} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v GasIndexAlgorithm_init\:sensirion_gas_index_algorithm.c}
{\xe \v sensirion_gas_index_algorithm.c\:GasIndexAlgorithm_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GasIndexAlgorithm_init ({\b GasIndexAlgorithmParams} * params, int32_t algorithm_type)}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the gas index algorithm parameters for the specified algorithm type and reset its internal states. Call this once at the beginning. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i params} \cell }{Pointer to the {\b GasIndexAlgorithmParams} struct \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i algorithm_type} \cell }{0 (GasIndexAlgorithm_ALGORITHM_TYPE_VOC) for VOC or 1 (GasIndexAlgorithm_ALGORITHM_TYPE_NOX) for NOx \cell }
{\row }
}
}{
Definition at line {\b 321} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v GasIndexAlgorithm_process\:sensirion_gas_index_algorithm.c}
{\xe \v sensirion_gas_index_algorithm.c\:GasIndexAlgorithm_process}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GasIndexAlgorithm_process ({\b GasIndexAlgorithmParams} * params, int32_t sraw, int32_t * gas_index)}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculate the gas index value from the raw sensor value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i params} \cell }{Pointer to the {\b GasIndexAlgorithmParams} struct \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sraw} \cell }{Raw value from the SGP4x sensor \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gas_index} \cell }{Calculated gas index value from the raw sensor value. Zero during initial blackout period and 1..500 afterwards \cell }
{\row }
}
}{
Definition at line {\b 433} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v GasIndexAlgorithm_reset\:sensirion_gas_index_algorithm.c}
{\xe \v sensirion_gas_index_algorithm.c\:GasIndexAlgorithm_reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GasIndexAlgorithm_reset ({\b GasIndexAlgorithmParams} * params)}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset the internal states of the gas index algorithm. Previously set tuning parameters are preserved. Call this when resuming operation after a measurement interruption. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i params} \cell }{Pointer to the {\b GasIndexAlgorithmParams} struct \cell }
{\row }
}
}{
Definition at line {\b 353} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v GasIndexAlgorithm_set_states\:sensirion_gas_index_algorithm.c}
{\xe \v sensirion_gas_index_algorithm.c\:GasIndexAlgorithm_set_states}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GasIndexAlgorithm_set_states ({\b GasIndexAlgorithmParams} * params, int32_t state0, int32_t state1)}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set previously retrieved algorithm states to resume operation after a short interruption, skipping initial learning phase. This feature should not be used after interruptions of more than 10 minutes. Call this once after {\b GasIndexAlgorithm_init()} or {\b GasIndexAlgorithm_reset()} and the optional {\b GasIndexAlgorithm_set_tuning_parameters()}, if desired. Otherwise, the algorithm will start with initial learning phase. NOTE: This feature can only be used for VOC algorithm type. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i params} \cell }{Pointer to the {\b GasIndexAlgorithmParams} struct \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state0} \cell }{State0 to be restored \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state1} \cell }{State1 to be restored \cell }
{\row }
}
}{
Definition at line {\b 388} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v GasIndexAlgorithm_set_tuning_parameters\:sensirion_gas_index_algorithm.c}
{\xe \v sensirion_gas_index_algorithm.c\:GasIndexAlgorithm_set_tuning_parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GasIndexAlgorithm_set_tuning_parameters ({\b GasIndexAlgorithmParams} * params, int32_t index_offset, int32_t learning_time_offset_hours, int32_t learning_time_gain_hours, int32_t gating_max_duration_minutes, int32_t std_initial, int32_t gain_factor)}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set parameters to customize the gas index algorithm. Call this once after {\b GasIndexAlgorithm_init()} and before optional {\b GasIndexAlgorithm_set_states()}, if desired. Otherwise, the default values will be used.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i params} \cell }{Pointer to the {\b GasIndexAlgorithmParams} struct \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index_offset} \cell }{Gas index representing typical (average) conditions. Range 1..250, default 100 for VOC and 1 for NOx \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i learning_time_offset_hours} \cell }{Time constant of long-term estimator for offset. Past events will be forgotten after about twice the learning time. Range 1..1000 [hours], default 12 [hours] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i learning_time_gain_hours} \cell }{Time constant of long-term estimator for gain. Past events will be forgotten after about twice the learning time. Range 1..1000 [hours], default 12 [hours] NOTE: This value is not relevant for NOx algorithm type \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gating_max_duration_minutes} \cell }{Maximum duration of gating (freeze of estimator during high gas index signal). 0 (no gating) or range 1..3000 [minutes], default 180 [minutes] for VOC and 720 [minutes] for NOx \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i std_initial} \cell }{Initial estimate for standard deviation. Lower value boosts events during initial learning period, but may result in larger device-to-device variations. Range 10..5000, default 50 NOTE: This value is not relevant for NOx algorithm type \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gain_factor} \cell }{Factor used to scale applied gain value when calculating gas index. Range 1..1000, default 230 \cell }
{\row }
}
}{
Definition at line {\b 400} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sensirion_gas_index_algorithm.c\par \pard\plain 
{\tc\tcl2 \v lib/gas_index_algorithm/sensirion_gas_index_algorithm.c}
{\xe \v lib/gas_index_algorithm/sensirion_gas_index_algorithm.c}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * Copyright (c) 2022, Sensirion AG}\par
00003 {\cf20  * All rights reserved.}\par
00004 {\cf20  *}\par
00005 {\cf20  * Redistribution and use in source and binary forms, with or without}\par
00006 {\cf20  * modification, are permitted provided that the following conditions are met:}\par
00007 {\cf20  *}\par
00008 {\cf20  * * Redistributions of source code must retain the above copyright notice, this}\par
00009 {\cf20  *   list of conditions and the following disclaimer.}\par
00010 {\cf20  *}\par
00011 {\cf20  * * Redistributions in binary form must reproduce the above copyright notice,}\par
00012 {\cf20  *   this list of conditions and the following disclaimer in the documentation}\par
00013 {\cf20  *   and/or other materials provided with the distribution.}\par
00014 {\cf20  *}\par
00015 {\cf20  * * Neither the name of Sensirion AG nor the names of its}\par
00016 {\cf20  *   contributors may be used to endorse or promote products derived from}\par
00017 {\cf20  *   this software without specific prior written permission.}\par
00018 {\cf20  *}\par
00019 {\cf20  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}\par
00020 {\cf20  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}\par
00021 {\cf20  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}\par
00022 {\cf20  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE}\par
00023 {\cf20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}\par
00024 {\cf20  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}\par
00025 {\cf20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}\par
00026 {\cf20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}\par
00027 {\cf20  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}\par
00028 {\cf20  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}\par
00029 {\cf20  * POSSIBILITY OF SUCH DAMAGE.}\par
00030 {\cf20  */}\par
00031 \par
00032 {\cf21 #include "sensirion_gas_index_algorithm.h"}\par
00033 \par
00035 {\cf21 #define FIX16_MAXIMUM 0x7FFFFFFF}{\cf21 }\par
00037 {\cf21 #define FIX16_MINIMUM 0x80000000}{\cf21 }\par
00040 {\cf21 #define FIX16_OVERFLOW 0x80000000}{\cf21 }\par
00042 {\cf21 #define FIX16_ONE 0x00010000}\par
00043 \par
00044 {\cf17 static} {\cf17 inline} fix16_t fix16_from_int(int32_t a) \{\par
00045     {\cf19 return} a * FIX16_ONE;\par
00046 \}\par
00047 \par
00048 {\cf17 static} {\cf17 inline} int32_t fix16_cast_to_int(fix16_t a) \{\par
00049     {\cf19 return} (a >= 0) ? (a >> 16) : -((-a) >> 16);\par
00050 \}\par
00051 \par
00053 {\cf17 static} fix16_t fix16_mul(fix16_t inArg0, fix16_t inArg1);\par
00054 \par
00056 {\cf17 static} fix16_t fix16_div(fix16_t inArg0, fix16_t inArg1);\par
00057 \par
00059 {\cf17 static} fix16_t fix16_sqrt(fix16_t inValue);\par
00060 \par
00062 {\cf17 static} fix16_t fix16_exp(fix16_t inValue);\par
00063 \par
00064 {\cf17 static} fix16_t fix16_mul(fix16_t inArg0, fix16_t inArg1) \{\par
00065     {\cf20 // Each argument is divided to 16-bit parts.}\par
00066     {\cf20 //                  AB}\par
00067     {\cf20 //          *    CD}\par
00068     {\cf20 // -----------}\par
00069     {\cf20 //                  BD  16 * 16 -> 32 bit products}\par
00070     {\cf20 //               CB}\par
00071     {\cf20 //               AD}\par
00072     {\cf20 //              AC}\par
00073     {\cf20 //           |----| 64 bit product}\par
00074     uint32_t absArg0 = (uint32_t)((inArg0 >= 0) ? inArg0 : (-inArg0));\par
00075     uint32_t absArg1 = (uint32_t)((inArg1 >= 0) ? inArg1 : (-inArg1));\par
00076     uint32_t A = (absArg0 >> 16), C = (absArg1 >> 16);\par
00077     uint32_t B = (absArg0 & 0xFFFF), D = (absArg1 & 0xFFFF);\par
00078 \par
00079     uint32_t AC = A * C;\par
00080     uint32_t AD_CB = A * D + C * B;\par
00081     uint32_t BD = B * D;\par
00082 \par
00083     uint32_t product_hi = AC + (AD_CB >> 16);\par
00084 \par
00085     {\cf20 // Handle carry from lower 32 bits to upper part of result.}\par
00086     uint32_t ad_cb_temp = AD_CB << 16;\par
00087     uint32_t product_lo = BD + ad_cb_temp;\par
00088     {\cf19 if} (product_lo < BD)\par
00089         product_hi++;\par
00090 \par
00091 {\cf21 #ifndef FIXMATH_NO_OVERFLOW}\par
00092     {\cf20 // The upper 17 bits should all be zero.}\par
00093     {\cf19 if} (product_hi >> 15)\par
00094         {\cf19 return} (fix16_t)FIX16_OVERFLOW;\par
00095 {\cf21 #endif}\par
00096 \par
00097 {\cf21 #ifdef FIXMATH_NO_ROUNDING}\par
00098     fix16_t result = (fix16_t)((product_hi << 16) | (product_lo >> 16));\par
00099     {\cf19 if} ((inArg0 < 0) != (inArg1 < 0))\par
00100         result = -result;\par
00101     {\cf19 return} result;\par
00102 {\cf21 #else}\par
00103     {\cf20 // Adding 0x8000 (= 0.5) and then using right shift}\par
00104     {\cf20 // achieves proper rounding to result.}\par
00105     {\cf20 // Handle carry from lower to upper part.}\par
00106     uint32_t product_lo_tmp = product_lo;\par
00107     product_lo += 0x8000;\par
00108     {\cf19 if} (product_lo < product_lo_tmp)\par
00109         product_hi++;\par
00110 \par
00111     {\cf20 // Discard the lowest 16 bits and convert back to signed result.}\par
00112     fix16_t result = (fix16_t)((product_hi << 16) | (product_lo >> 16));\par
00113     {\cf19 if} ((inArg0 < 0) != (inArg1 < 0))\par
00114         result = -result;\par
00115     {\cf19 return} result;\par
00116 {\cf21 #endif}\par
00117 \}\par
00118 \par
00119 {\cf17 static} fix16_t fix16_div(fix16_t a, fix16_t b) \{\par
00120     {\cf20 // This uses the basic binary restoring division algorithm.}\par
00121     {\cf20 // It appears to be faster to do the whole division manually than}\par
00122     {\cf20 // trying to compose a 64-bit divide out of 32-bit divisions on}\par
00123     {\cf20 // platforms without hardware divide.}\par
00124 \par
00125     {\cf19 if} (b == 0)\par
00126         {\cf19 return} (fix16_t)FIX16_MINIMUM;\par
00127 \par
00128     uint32_t remainder = (uint32_t)((a >= 0) ? a : (-a));\par
00129     uint32_t divider = (uint32_t)((b >= 0) ? b : (-b));\par
00130 \par
00131     uint32_t quotient = 0;\par
00132     uint32_t bit = 0x10000;\par
00133 \par
00134     {\cf20 /* The algorithm requires D >= R */}\par
00135     {\cf19 while} (divider < remainder) \{\par
00136         divider <<= 1;\par
00137         bit <<= 1;\par
00138     \}\par
00139 \par
00140 {\cf21 #ifndef FIXMATH_NO_OVERFLOW}\par
00141     {\cf19 if} (!bit)\par
00142         {\cf19 return} (fix16_t)FIX16_OVERFLOW;\par
00143 {\cf21 #endif}\par
00144 \par
00145     {\cf19 if} (divider & 0x80000000) \{\par
00146         {\cf20 // Perform one step manually to avoid overflows later.}\par
00147         {\cf20 // We know that divider's bottom bit is 0 here.}\par
00148         {\cf19 if} (remainder >= divider) \{\par
00149             quotient |= bit;\par
00150             remainder -= divider;\par
00151         \}\par
00152         divider >>= 1;\par
00153         bit >>= 1;\par
00154     \}\par
00155 \par
00156     {\cf20 /* Main division loop */}\par
00157     {\cf19 while} (bit && remainder) \{\par
00158         {\cf19 if} (remainder >= divider) \{\par
00159             quotient |= bit;\par
00160             remainder -= divider;\par
00161         \}\par
00162 \par
00163         remainder <<= 1;\par
00164         bit >>= 1;\par
00165     \}\par
00166 \par
00167 {\cf21 #ifndef FIXMATH_NO_ROUNDING}\par
00168     {\cf19 if} (remainder >= divider) \{\par
00169         quotient++;\par
00170     \}\par
00171 {\cf21 #endif}\par
00172 \par
00173     fix16_t result = (fix16_t)quotient;\par
00174 \par
00175     {\cf20 /* Figure out the sign of result */}\par
00176     {\cf19 if} ((a < 0) != (b < 0)) \{\par
00177 {\cf21 #ifndef FIXMATH_NO_OVERFLOW}\par
00178         {\cf19 if} (result == (fix16_t)FIX16_MINIMUM)\par
00179             {\cf19 return} (fix16_t)FIX16_OVERFLOW;\par
00180 {\cf21 #endif}\par
00181 \par
00182         result = -result;\par
00183     \}\par
00184 \par
00185     {\cf19 return} result;\par
00186 \}\par
00187 \par
00188 {\cf17 static} fix16_t fix16_sqrt(fix16_t x) \{\par
00189     {\cf20 // It is assumed that x is not negative}\par
00190 \par
00191     uint32_t num = (uint32_t)x;\par
00192     uint32_t result = 0;\par
00193     uint32_t bit;\par
00194     uint8_t n;\par
00195 \par
00196     bit = (uint32_t)1 << 30;\par
00197     {\cf19 while} (bit > num)\par
00198         bit >>= 2;\par
00199 \par
00200     {\cf20 // The main part is executed twice, in order to avoid}\par
00201     {\cf20 // using 64 bit values in computations.}\par
00202     {\cf19 for} (n = 0; n < 2; n++) \{\par
00203         {\cf20 // First we get the top 24 bits of the answer.}\par
00204         {\cf19 while} (bit) \{\par
00205             {\cf19 if} (num >= result + bit) \{\par
00206                 num -= result + bit;\par
00207                 result = (result >> 1) + bit;\par
00208             \} {\cf19 else} \{\par
00209                 result = (result >> 1);\par
00210             \}\par
00211             bit >>= 2;\par
00212         \}\par
00213 \par
00214         {\cf19 if} (n == 0) \{\par
00215             {\cf20 // Then process it again to get the lowest 8 bits.}\par
00216             {\cf19 if} (num > 65535) \{\par
00217                 {\cf20 // The remainder 'num' is too large to be shifted left}\par
00218                 {\cf20 // by 16, so we have to add 1 to result manually and}\par
00219                 {\cf20 // adjust 'num' accordingly.}\par
00220                 {\cf20 // num = a - (result + 0.5)^2}\par
00221                 {\cf20 //   = num + result^2 - (result + 0.5)^2}\par
00222                 {\cf20 //   = num - result - 0.5}\par
00223                 num -= result;\par
00224                 num = (num << 16) - 0x8000;\par
00225                 result = (result << 16) + 0x8000;\par
00226             \} {\cf19 else} \{\par
00227                 num <<= 16;\par
00228                 result <<= 16;\par
00229             \}\par
00230 \par
00231             bit = 1 << 14;\par
00232         \}\par
00233     \}\par
00234 \par
00235 {\cf21 #ifndef FIXMATH_NO_ROUNDING}\par
00236     {\cf20 // Finally, if next bit would have been 1, round the result upwards.}\par
00237     {\cf19 if} (num > result) \{\par
00238         result++;\par
00239     \}\par
00240 {\cf21 #endif}\par
00241 \par
00242     {\cf19 return} (fix16_t)result;\par
00243 \}\par
00244 \par
00245 {\cf17 static} fix16_t fix16_exp(fix16_t x) \{\par
00246     {\cf20 // Function to approximate exp(); optimized more for code size than speed}\par
00247 \par
00248     {\cf20 // exp(x) for x = +/- \{1, 1/8, 1/64, 1/512\}}\par
00249 {\cf21 #define NUM_EXP_VALUES 4}\par
00250     {\cf17 static} {\cf17 const} fix16_t exp_pos_values[NUM_EXP_VALUES] = \{\par
00251         F16(2.7182818), F16(1.1331485), F16(1.0157477), F16(1.0019550)\};\par
00252     {\cf17 static} {\cf17 const} fix16_t exp_neg_values[NUM_EXP_VALUES] = \{\par
00253         F16(0.3678794), F16(0.8824969), F16(0.9844964), F16(0.9980488)\};\par
00254     {\cf17 const} fix16_t* exp_values;\par
00255 \par
00256     fix16_t res, arg;\par
00257     uint16_t i;\par
00258 \par
00259     {\cf19 if} (x >= F16(10.3972))\par
00260         {\cf19 return} FIX16_MAXIMUM;\par
00261     {\cf19 if} (x <= F16(-11.7835))\par
00262         {\cf19 return} 0;\par
00263 \par
00264     {\cf19 if} (x < 0) \{\par
00265         x = -x;\par
00266         exp_values = exp_neg_values;\par
00267     \} {\cf19 else} \{\par
00268         exp_values = exp_pos_values;\par
00269     \}\par
00270 \par
00271     res = FIX16_ONE;\par
00272     arg = FIX16_ONE;\par
00273     {\cf19 for} (i = 0; i < NUM_EXP_VALUES; i++) \{\par
00274         {\cf19 while} (x >= arg) \{\par
00275             res = fix16_mul(res, exp_values[i]);\par
00276             x -= arg;\par
00277         \}\par
00278         arg >>= 3;\par
00279     \}\par
00280     {\cf19 return} res;\par
00281 \}\par
00282 \par
00283 {\cf17 static} {\cf18 void} GasIndexAlgorithm__init_instances(GasIndexAlgorithmParams* params);\par
00284 {\cf17 static} {\cf18 void} GasIndexAlgorithm__mean_variance_estimator__set_parameters(\par
00285     GasIndexAlgorithmParams* params);\par
00286 {\cf17 static} {\cf18 void} GasIndexAlgorithm__mean_variance_estimator__set_states(\par
00287     GasIndexAlgorithmParams* params, fix16_t mean, fix16_t std,\par
00288     fix16_t uptime_gamma);\par
00289 {\cf17 static} fix16_t GasIndexAlgorithm__mean_variance_estimator__get_std(\par
00290     {\cf17 const} GasIndexAlgorithmParams* params);\par
00291 {\cf17 static} fix16_t GasIndexAlgorithm__mean_variance_estimator__get_mean(\par
00292     {\cf17 const} GasIndexAlgorithmParams* params);\par
00293 {\cf17 static} {\cf18 bool} GasIndexAlgorithm__mean_variance_estimator__is_initialized(\par
00294     GasIndexAlgorithmParams* params);\par
00295 {\cf17 static} {\cf18 void} GasIndexAlgorithm__mean_variance_estimator___calculate_gamma(\par
00296     GasIndexAlgorithmParams* params);\par
00297 {\cf17 static} {\cf18 void} GasIndexAlgorithm__mean_variance_estimator__process(\par
00298     GasIndexAlgorithmParams* params, fix16_t sraw);\par
00299 {\cf17 static} {\cf18 void}\par
00300 GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters(\par
00301     GasIndexAlgorithmParams* params, fix16_t X0, fix16_t K);\par
00302 {\cf17 static} fix16_t GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(\par
00303     GasIndexAlgorithmParams* params, fix16_t sample);\par
00304 {\cf17 static} {\cf18 void} GasIndexAlgorithm__mox_model__set_parameters(\par
00305     GasIndexAlgorithmParams* params, fix16_t SRAW_STD, fix16_t SRAW_MEAN);\par
00306 {\cf17 static} fix16_t\par
00307 GasIndexAlgorithm__mox_model__process(GasIndexAlgorithmParams* params,\par
00308                                       fix16_t sraw);\par
00309 {\cf17 static} {\cf18 void} GasIndexAlgorithm__sigmoid_scaled__set_parameters(\par
00310     GasIndexAlgorithmParams* params, fix16_t X0, fix16_t K,\par
00311     fix16_t offset_default);\par
00312 {\cf17 static} fix16_t\par
00313 GasIndexAlgorithm__sigmoid_scaled__process(GasIndexAlgorithmParams* params,\par
00314                                            fix16_t sample);\par
00315 {\cf17 static} {\cf18 void} GasIndexAlgorithm__adaptive_lowpass__set_parameters(\par
00316     GasIndexAlgorithmParams* params);\par
00317 {\cf17 static} fix16_t\par
00318 GasIndexAlgorithm__adaptive_lowpass__process(GasIndexAlgorithmParams* params,\par
00319                                              fix16_t sample);\par
00320 \par
00321 {\cf18 void} GasIndexAlgorithm_init(GasIndexAlgorithmParams* params,\par
00322                             int32_t algorithm_type) \{\par
00323 \par
00324     params->mAlgorithm_Type = algorithm_type;\par
00325     {\cf19 if} ((algorithm_type == GasIndexAlgorithm_ALGORITHM_TYPE_NOX)) \{\par
00326         params->mIndex_Offset = F16(GasIndexAlgorithm_NOX_INDEX_OFFSET_DEFAULT);\par
00327         params->mSraw_Minimum = GasIndexAlgorithm_NOX_SRAW_MINIMUM;\par
00328         params->mGating_Max_Duration_Minutes =\par
00329             F16(GasIndexAlgorithm_GATING_NOX_MAX_DURATION_MINUTES);\par
00330         params->mInit_Duration_Mean =\par
00331             F16(GasIndexAlgorithm_INIT_DURATION_MEAN_NOX);\par
00332         params->mInit_Duration_Variance =\par
00333             F16(GasIndexAlgorithm_INIT_DURATION_VARIANCE_NOX);\par
00334         params->mGating_Threshold = F16(GasIndexAlgorithm_GATING_THRESHOLD_NOX);\par
00335     \} {\cf19 else} \{\par
00336         params->mIndex_Offset = F16(GasIndexAlgorithm_VOC_INDEX_OFFSET_DEFAULT);\par
00337         params->mSraw_Minimum = GasIndexAlgorithm_VOC_SRAW_MINIMUM;\par
00338         params->mGating_Max_Duration_Minutes =\par
00339             F16(GasIndexAlgorithm_GATING_VOC_MAX_DURATION_MINUTES);\par
00340         params->mInit_Duration_Mean =\par
00341             F16(GasIndexAlgorithm_INIT_DURATION_MEAN_VOC);\par
00342         params->mInit_Duration_Variance =\par
00343             F16(GasIndexAlgorithm_INIT_DURATION_VARIANCE_VOC);\par
00344         params->mGating_Threshold = F16(GasIndexAlgorithm_GATING_THRESHOLD_VOC);\par
00345     \}\par
00346     params->mIndex_Gain = F16(GasIndexAlgorithm_INDEX_GAIN);\par
00347     params->mTau_Mean_Hours = F16(GasIndexAlgorithm_TAU_MEAN_HOURS);\par
00348     params->mTau_Variance_Hours = F16(GasIndexAlgorithm_TAU_VARIANCE_HOURS);\par
00349     params->mSraw_Std_Initial = F16(GasIndexAlgorithm_SRAW_STD_INITIAL);\par
00350     GasIndexAlgorithm_reset(params);\par
00351 \}\par
00352 \par
00353 {\cf18 void} GasIndexAlgorithm_reset(GasIndexAlgorithmParams* params) \{\par
00354     params->mUptime = F16(0.);\par
00355     params->mSraw = F16(0.);\par
00356     params->mGas_Index = 0;\par
00357     GasIndexAlgorithm__init_instances(params);\par
00358 \}\par
00359 \par
00360 {\cf17 static} {\cf18 void} GasIndexAlgorithm__init_instances(GasIndexAlgorithmParams* params) \{\par
00361 \par
00362     GasIndexAlgorithm__mean_variance_estimator__set_parameters(params);\par
00363     GasIndexAlgorithm__mox_model__set_parameters(\par
00364         params, GasIndexAlgorithm__mean_variance_estimator__get_std(params),\par
00365         GasIndexAlgorithm__mean_variance_estimator__get_mean(params));\par
00366     {\cf19 if} ((params->mAlgorithm_Type == GasIndexAlgorithm_ALGORITHM_TYPE_NOX)) \{\par
00367         GasIndexAlgorithm__sigmoid_scaled__set_parameters(\par
00368             params, F16(GasIndexAlgorithm_SIGMOID_X0_NOX),\par
00369             F16(GasIndexAlgorithm_SIGMOID_K_NOX),\par
00370             F16(GasIndexAlgorithm_NOX_INDEX_OFFSET_DEFAULT));\par
00371     \} {\cf19 else} \{\par
00372         GasIndexAlgorithm__sigmoid_scaled__set_parameters(\par
00373             params, F16(GasIndexAlgorithm_SIGMOID_X0_VOC),\par
00374             F16(GasIndexAlgorithm_SIGMOID_K_VOC),\par
00375             F16(GasIndexAlgorithm_VOC_INDEX_OFFSET_DEFAULT));\par
00376     \}\par
00377     GasIndexAlgorithm__adaptive_lowpass__set_parameters(params);\par
00378 \}\par
00379 \par
00380 {\cf18 void} GasIndexAlgorithm_get_states({\cf17 const} GasIndexAlgorithmParams* params,\par
00381                                   int32_t* state0, int32_t* state1) \{\par
00382 \par
00383     *state0 = GasIndexAlgorithm__mean_variance_estimator__get_mean(params);\par
00384     *state1 = GasIndexAlgorithm__mean_variance_estimator__get_std(params);\par
00385     {\cf19 return};\par
00386 \}\par
00387 \par
00388 {\cf18 void} GasIndexAlgorithm_set_states(GasIndexAlgorithmParams* params,\par
00389                                   int32_t state0, int32_t state1) \{\par
00390 \par
00391     GasIndexAlgorithm__mean_variance_estimator__set_states(\par
00392         params, state0, state1,\par
00393         F16(GasIndexAlgorithm_PERSISTENCE_UPTIME_GAMMA));\par
00394     GasIndexAlgorithm__mox_model__set_parameters(\par
00395         params, GasIndexAlgorithm__mean_variance_estimator__get_std(params),\par
00396         GasIndexAlgorithm__mean_variance_estimator__get_mean(params));\par
00397     params->mSraw = state0;\par
00398 \}\par
00399 \par
00400 {\cf18 void} GasIndexAlgorithm_set_tuning_parameters(\par
00401     GasIndexAlgorithmParams* params, int32_t index_offset,\par
00402     int32_t learning_time_offset_hours, int32_t learning_time_gain_hours,\par
00403     int32_t gating_max_duration_minutes, int32_t std_initial,\par
00404     int32_t gain_factor) \{\par
00405 \par
00406     params->mIndex_Offset = (fix16_from_int(index_offset));\par
00407     params->mTau_Mean_Hours = (fix16_from_int(learning_time_offset_hours));\par
00408     params->mTau_Variance_Hours = (fix16_from_int(learning_time_gain_hours));\par
00409     params->mGating_Max_Duration_Minutes =\par
00410         (fix16_from_int(gating_max_duration_minutes));\par
00411     params->mSraw_Std_Initial = (fix16_from_int(std_initial));\par
00412     params->mIndex_Gain = (fix16_from_int(gain_factor));\par
00413     GasIndexAlgorithm__init_instances(params);\par
00414 \}\par
00415 \par
00416 {\cf18 void} GasIndexAlgorithm_get_tuning_parameters(\par
00417     {\cf17 const} GasIndexAlgorithmParams* params, int32_t* index_offset,\par
00418     int32_t* learning_time_offset_hours, int32_t* learning_time_gain_hours,\par
00419     int32_t* gating_max_duration_minutes, int32_t* std_initial,\par
00420     int32_t* gain_factor) \{\par
00421 \par
00422     *index_offset = (fix16_cast_to_int(params->mIndex_Offset));\par
00423     *learning_time_offset_hours = (fix16_cast_to_int(params->mTau_Mean_Hours));\par
00424     *learning_time_gain_hours =\par
00425         (fix16_cast_to_int(params->mTau_Variance_Hours));\par
00426     *gating_max_duration_minutes =\par
00427         (fix16_cast_to_int(params->mGating_Max_Duration_Minutes));\par
00428     *std_initial = (fix16_cast_to_int(params->mSraw_Std_Initial));\par
00429     *gain_factor = (fix16_cast_to_int(params->mIndex_Gain));\par
00430     {\cf19 return};\par
00431 \}\par
00432 \par
00433 {\cf18 void} GasIndexAlgorithm_process(GasIndexAlgorithmParams* params, int32_t sraw,\par
00434                                int32_t* gas_index) \{\par
00435 \par
00436     {\cf19 if} ((params->mUptime <= F16(GasIndexAlgorithm_INITIAL_BLACKOUT))) \{\par
00437         params->mUptime =\par
00438             (params->mUptime + F16(GasIndexAlgorithm_SAMPLING_INTERVAL));\par
00439     \} {\cf19 else} \{\par
00440         {\cf19 if} (((sraw > 0) && (sraw < 65000))) \{\par
00441             {\cf19 if} ((sraw < (params->mSraw_Minimum + 1))) \{\par
00442                 sraw = (params->mSraw_Minimum + 1);\par
00443             \} {\cf19 else} {\cf19 if} ((sraw > (params->mSraw_Minimum + 32767))) \{\par
00444                 sraw = (params->mSraw_Minimum + 32767);\par
00445             \}\par
00446             params->mSraw = (fix16_from_int((sraw - params->mSraw_Minimum)));\par
00447         \}\par
00448         {\cf19 if} (((params->mAlgorithm_Type ==\par
00449               GasIndexAlgorithm_ALGORITHM_TYPE_VOC) ||\par
00450              GasIndexAlgorithm__mean_variance_estimator__is_initialized(\par
00451                  params))) \{\par
00452             params->mGas_Index =\par
00453                 GasIndexAlgorithm__mox_model__process(params, params->mSraw);\par
00454             params->mGas_Index = GasIndexAlgorithm__sigmoid_scaled__process(\par
00455                 params, params->mGas_Index);\par
00456         \} {\cf19 else} \{\par
00457             params->mGas_Index = params->mIndex_Offset;\par
00458         \}\par
00459         params->mGas_Index = GasIndexAlgorithm__adaptive_lowpass__process(\par
00460             params, params->mGas_Index);\par
00461         {\cf19 if} ((params->mGas_Index < F16(0.5))) \{\par
00462             params->mGas_Index = F16(0.5);\par
00463         \}\par
00464         {\cf19 if} ((params->mSraw > F16(0.))) \{\par
00465             GasIndexAlgorithm__mean_variance_estimator__process(params,\par
00466                                                                 params->mSraw);\par
00467             GasIndexAlgorithm__mox_model__set_parameters(\par
00468                 params,\par
00469                 GasIndexAlgorithm__mean_variance_estimator__get_std(params),\par
00470                 GasIndexAlgorithm__mean_variance_estimator__get_mean(params));\par
00471         \}\par
00472     \}\par
00473     *gas_index = (fix16_cast_to_int((params->mGas_Index + F16(0.5))));\par
00474     {\cf19 return};\par
00475 \}\par
00476 \par
00477 {\cf17 static} {\cf18 void} GasIndexAlgorithm__mean_variance_estimator__set_parameters(\par
00478     GasIndexAlgorithmParams* params) \{\par
00479 \par
00480     params->m_Mean_Variance_Estimator___Initialized = {\cf17 false};\par
00481     params->m_Mean_Variance_Estimator___Mean = F16(0.);\par
00482     params->m_Mean_Variance_Estimator___Sraw_Offset = F16(0.);\par
00483     params->m_Mean_Variance_Estimator___Std = params->mSraw_Std_Initial;\par
00484     params->m_Mean_Variance_Estimator___Gamma_Mean = (fix16_div(\par
00485         F16((\par
00486             (GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__ADDITIONAL_GAMMA_MEAN_SCALING *\par
00487              GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING) *\par
00488             (GasIndexAlgorithm_SAMPLING_INTERVAL / 3600.))),\par
00489         (params->mTau_Mean_Hours +\par
00490          F16((GasIndexAlgorithm_SAMPLING_INTERVAL / 3600.)))));\par
00491     params->m_Mean_Variance_Estimator___Gamma_Variance = (fix16_div(\par
00492         F16((GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING *\par
00493              (GasIndexAlgorithm_SAMPLING_INTERVAL / 3600.))),\par
00494         (params->mTau_Variance_Hours +\par
00495          F16((GasIndexAlgorithm_SAMPLING_INTERVAL / 3600.)))));\par
00496     {\cf19 if} ((params->mAlgorithm_Type == GasIndexAlgorithm_ALGORITHM_TYPE_NOX)) \{\par
00497         params->m_Mean_Variance_Estimator___Gamma_Initial_Mean = F16((\par
00498             ((GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__ADDITIONAL_GAMMA_MEAN_SCALING *\par
00499               GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING) *\par
00500              GasIndexAlgorithm_SAMPLING_INTERVAL) /\par
00501             (GasIndexAlgorithm_TAU_INITIAL_MEAN_NOX +\par
00502              GasIndexAlgorithm_SAMPLING_INTERVAL)));\par
00503     \} {\cf19 else} \{\par
00504         params->m_Mean_Variance_Estimator___Gamma_Initial_Mean = F16((\par
00505             ((GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__ADDITIONAL_GAMMA_MEAN_SCALING *\par
00506               GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING) *\par
00507              GasIndexAlgorithm_SAMPLING_INTERVAL) /\par
00508             (GasIndexAlgorithm_TAU_INITIAL_MEAN_VOC +\par
00509              GasIndexAlgorithm_SAMPLING_INTERVAL)));\par
00510     \}\par
00511     params->m_Mean_Variance_Estimator___Gamma_Initial_Variance =\par
00512         F16(((GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING *\par
00513               GasIndexAlgorithm_SAMPLING_INTERVAL) /\par
00514              (GasIndexAlgorithm_TAU_INITIAL_VARIANCE +\par
00515               GasIndexAlgorithm_SAMPLING_INTERVAL)));\par
00516     params->m_Mean_Variance_Estimator__Gamma_Mean = F16(0.);\par
00517     params->m_Mean_Variance_Estimator__Gamma_Variance = F16(0.);\par
00518     params->m_Mean_Variance_Estimator___Uptime_Gamma = F16(0.);\par
00519     params->m_Mean_Variance_Estimator___Uptime_Gating = F16(0.);\par
00520     params->m_Mean_Variance_Estimator___Gating_Duration_Minutes = F16(0.);\par
00521 \}\par
00522 \par
00523 {\cf17 static} {\cf18 void} GasIndexAlgorithm__mean_variance_estimator__set_states(\par
00524     GasIndexAlgorithmParams* params, fix16_t mean, fix16_t std,\par
00525     fix16_t uptime_gamma) \{\par
00526 \par
00527     params->m_Mean_Variance_Estimator___Mean = mean;\par
00528     params->m_Mean_Variance_Estimator___Std = std;\par
00529     params->m_Mean_Variance_Estimator___Uptime_Gamma = uptime_gamma;\par
00530     params->m_Mean_Variance_Estimator___Initialized = {\cf17 true};\par
00531 \}\par
00532 \par
00533 {\cf17 static} fix16_t GasIndexAlgorithm__mean_variance_estimator__get_std(\par
00534     {\cf17 const} GasIndexAlgorithmParams* params) \{\par
00535 \par
00536     {\cf19 return} params->m_Mean_Variance_Estimator___Std;\par
00537 \}\par
00538 \par
00539 {\cf17 static} fix16_t GasIndexAlgorithm__mean_variance_estimator__get_mean(\par
00540     {\cf17 const} GasIndexAlgorithmParams* params) \{\par
00541 \par
00542     {\cf19 return} (params->m_Mean_Variance_Estimator___Mean +\par
00543             params->m_Mean_Variance_Estimator___Sraw_Offset);\par
00544 \}\par
00545 \par
00546 {\cf17 static} {\cf18 bool} GasIndexAlgorithm__mean_variance_estimator__is_initialized(\par
00547     GasIndexAlgorithmParams* params) \{\par
00548 \par
00549     {\cf19 return} params->m_Mean_Variance_Estimator___Initialized;\par
00550 \}\par
00551 \par
00552 {\cf17 static} {\cf18 void} GasIndexAlgorithm__mean_variance_estimator___calculate_gamma(\par
00553     GasIndexAlgorithmParams* params) \{\par
00554 \par
00555     fix16_t uptime_limit;\par
00556     fix16_t sigmoid_gamma_mean;\par
00557     fix16_t gamma_mean;\par
00558     fix16_t gating_threshold_mean;\par
00559     fix16_t sigmoid_gating_mean;\par
00560     fix16_t sigmoid_gamma_variance;\par
00561     fix16_t gamma_variance;\par
00562     fix16_t gating_threshold_variance;\par
00563     fix16_t sigmoid_gating_variance;\par
00564 \par
00565     uptime_limit = F16((GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__FIX16_MAX -\par
00566                         GasIndexAlgorithm_SAMPLING_INTERVAL));\par
00567     {\cf19 if} ((params->m_Mean_Variance_Estimator___Uptime_Gamma < uptime_limit)) \{\par
00568         params->m_Mean_Variance_Estimator___Uptime_Gamma =\par
00569             (params->m_Mean_Variance_Estimator___Uptime_Gamma +\par
00570              F16(GasIndexAlgorithm_SAMPLING_INTERVAL));\par
00571     \}\par
00572     {\cf19 if} ((params->m_Mean_Variance_Estimator___Uptime_Gating < uptime_limit)) \{\par
00573         params->m_Mean_Variance_Estimator___Uptime_Gating =\par
00574             (params->m_Mean_Variance_Estimator___Uptime_Gating +\par
00575              F16(GasIndexAlgorithm_SAMPLING_INTERVAL));\par
00576     \}\par
00577     GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters(\par
00578         params, params->mInit_Duration_Mean,\par
00579         F16(GasIndexAlgorithm_INIT_TRANSITION_MEAN));\par
00580     sigmoid_gamma_mean =\par
00581         GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(\par
00582             params, params->m_Mean_Variance_Estimator___Uptime_Gamma);\par
00583     gamma_mean =\par
00584         (params->m_Mean_Variance_Estimator___Gamma_Mean +\par
00585          (fix16_mul((params->m_Mean_Variance_Estimator___Gamma_Initial_Mean -\par
00586                      params->m_Mean_Variance_Estimator___Gamma_Mean),\par
00587                     sigmoid_gamma_mean)));\par
00588     gating_threshold_mean =\par
00589         (params->mGating_Threshold +\par
00590          (fix16_mul(\par
00591              (F16(GasIndexAlgorithm_GATING_THRESHOLD_INITIAL) -\par
00592               params->mGating_Threshold),\par
00593              GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(\par
00594                  params, params->m_Mean_Variance_Estimator___Uptime_Gating))));\par
00595     GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters(\par
00596         params, gating_threshold_mean,\par
00597         F16(GasIndexAlgorithm_GATING_THRESHOLD_TRANSITION));\par
00598     sigmoid_gating_mean =\par
00599         GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(\par
00600             params, params->mGas_Index);\par
00601     params->m_Mean_Variance_Estimator__Gamma_Mean =\par
00602         (fix16_mul(sigmoid_gating_mean, gamma_mean));\par
00603     GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters(\par
00604         params, params->mInit_Duration_Variance,\par
00605         F16(GasIndexAlgorithm_INIT_TRANSITION_VARIANCE));\par
00606     sigmoid_gamma_variance =\par
00607         GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(\par
00608             params, params->m_Mean_Variance_Estimator___Uptime_Gamma);\par
00609     gamma_variance =\par
00610         (params->m_Mean_Variance_Estimator___Gamma_Variance +\par
00611          (fix16_mul(\par
00612              (params->m_Mean_Variance_Estimator___Gamma_Initial_Variance -\par
00613               params->m_Mean_Variance_Estimator___Gamma_Variance),\par
00614              (sigmoid_gamma_variance - sigmoid_gamma_mean))));\par
00615     gating_threshold_variance =\par
00616         (params->mGating_Threshold +\par
00617          (fix16_mul(\par
00618              (F16(GasIndexAlgorithm_GATING_THRESHOLD_INITIAL) -\par
00619               params->mGating_Threshold),\par
00620              GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(\par
00621                  params, params->m_Mean_Variance_Estimator___Uptime_Gating))));\par
00622     GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters(\par
00623         params, gating_threshold_variance,\par
00624         F16(GasIndexAlgorithm_GATING_THRESHOLD_TRANSITION));\par
00625     sigmoid_gating_variance =\par
00626         GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(\par
00627             params, params->mGas_Index);\par
00628     params->m_Mean_Variance_Estimator__Gamma_Variance =\par
00629         (fix16_mul(sigmoid_gating_variance, gamma_variance));\par
00630     params->m_Mean_Variance_Estimator___Gating_Duration_Minutes =\par
00631         (params->m_Mean_Variance_Estimator___Gating_Duration_Minutes +\par
00632          (fix16_mul(\par
00633              F16((GasIndexAlgorithm_SAMPLING_INTERVAL / 60.)),\par
00634              ((fix16_mul((F16(1.) - sigmoid_gating_mean),\par
00635                          F16((1. + GasIndexAlgorithm_GATING_MAX_RATIO)))) -\par
00636               F16(GasIndexAlgorithm_GATING_MAX_RATIO)))));\par
00637     {\cf19 if} ((params->m_Mean_Variance_Estimator___Gating_Duration_Minutes <\par
00638          F16(0.))) \{\par
00639         params->m_Mean_Variance_Estimator___Gating_Duration_Minutes = F16(0.);\par
00640     \}\par
00641     {\cf19 if} ((params->m_Mean_Variance_Estimator___Gating_Duration_Minutes >\par
00642          params->mGating_Max_Duration_Minutes)) \{\par
00643         params->m_Mean_Variance_Estimator___Uptime_Gating = F16(0.);\par
00644     \}\par
00645 \}\par
00646 \par
00647 {\cf17 static} {\cf18 void} GasIndexAlgorithm__mean_variance_estimator__process(\par
00648     GasIndexAlgorithmParams* params, fix16_t sraw) \{\par
00649 \par
00650     fix16_t delta_sgp;\par
00651     fix16_t c;\par
00652     fix16_t additional_scaling;\par
00653 \par
00654     {\cf19 if} ((params->m_Mean_Variance_Estimator___Initialized == {\cf17 false})) \{\par
00655         params->m_Mean_Variance_Estimator___Initialized = {\cf17 true};\par
00656         params->m_Mean_Variance_Estimator___Sraw_Offset = sraw;\par
00657         params->m_Mean_Variance_Estimator___Mean = F16(0.);\par
00658     \} {\cf19 else} \{\par
00659         {\cf19 if} (((params->m_Mean_Variance_Estimator___Mean >= F16(100.)) ||\par
00660              (params->m_Mean_Variance_Estimator___Mean <= F16(-100.)))) \{\par
00661             params->m_Mean_Variance_Estimator___Sraw_Offset =\par
00662                 (params->m_Mean_Variance_Estimator___Sraw_Offset +\par
00663                  params->m_Mean_Variance_Estimator___Mean);\par
00664             params->m_Mean_Variance_Estimator___Mean = F16(0.);\par
00665         \}\par
00666         sraw = (sraw - params->m_Mean_Variance_Estimator___Sraw_Offset);\par
00667         GasIndexAlgorithm__mean_variance_estimator___calculate_gamma(params);\par
00668         delta_sgp = (fix16_div(\par
00669             (sraw - params->m_Mean_Variance_Estimator___Mean),\par
00670             F16(GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING)));\par
00671         {\cf19 if} ((delta_sgp < F16(0.))) \{\par
00672             c = (params->m_Mean_Variance_Estimator___Std - delta_sgp);\par
00673         \} {\cf19 else} \{\par
00674             c = (params->m_Mean_Variance_Estimator___Std + delta_sgp);\par
00675         \}\par
00676         additional_scaling = F16(1.);\par
00677         {\cf19 if} ((c > F16(1440.))) \{\par
00678             additional_scaling = (fix16_mul((fix16_div(c, F16(1440.))),\par
00679                                             (fix16_div(c, F16(1440.)))));\par
00680         \}\par
00681         params->m_Mean_Variance_Estimator___Std = (fix16_mul(\par
00682             fix16_sqrt((fix16_mul(\par
00683                 additional_scaling,\par
00684                 (F16(GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING) -\par
00685                  params->m_Mean_Variance_Estimator__Gamma_Variance)))),\par
00686             fix16_sqrt((\par
00687                 (fix16_mul(\par
00688                     params->m_Mean_Variance_Estimator___Std,\par
00689                     (fix16_div(\par
00690                         params->m_Mean_Variance_Estimator___Std,\par
00691                         (fix16_mul(\par
00692                             F16(GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING),\par
00693                             additional_scaling)))))) +\par
00694                 (fix16_mul(\par
00695                     (fix16_div(\par
00696                         (fix16_mul(\par
00697                             params->m_Mean_Variance_Estimator__Gamma_Variance,\par
00698                             delta_sgp)),\par
00699                         additional_scaling)),\par
00700                     delta_sgp))))));\par
00701         params->m_Mean_Variance_Estimator___Mean =\par
00702             (params->m_Mean_Variance_Estimator___Mean +\par
00703              (fix16_div(\par
00704                  (fix16_mul(params->m_Mean_Variance_Estimator__Gamma_Mean,\par
00705                             delta_sgp)),\par
00706                  F16(GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__ADDITIONAL_GAMMA_MEAN_SCALING))));\par
00707     \}\par
00708 \}\par
00709 \par
00710 {\cf17 static} {\cf18 void}\par
00711 GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters(\par
00712     GasIndexAlgorithmParams* params, fix16_t X0, fix16_t K) \{\par
00713 \par
00714     params->m_Mean_Variance_Estimator___Sigmoid__K = K;\par
00715     params->m_Mean_Variance_Estimator___Sigmoid__X0 = X0;\par
00716 \}\par
00717 \par
00718 {\cf17 static} fix16_t GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(\par
00719     GasIndexAlgorithmParams* params, fix16_t sample) \{\par
00720 \par
00721     fix16_t x;\par
00722 \par
00723     x = (fix16_mul(params->m_Mean_Variance_Estimator___Sigmoid__K,\par
00724                    (sample - params->m_Mean_Variance_Estimator___Sigmoid__X0)));\par
00725     {\cf19 if} ((x < F16(-50.))) \{\par
00726         {\cf19 return} F16(1.);\par
00727     \} {\cf19 else} {\cf19 if} ((x > F16(50.))) \{\par
00728         {\cf19 return} F16(0.);\par
00729     \} {\cf19 else} \{\par
00730         {\cf19 return} (fix16_div(F16(1.), (F16(1.) + fix16_exp(x))));\par
00731     \}\par
00732 \}\par
00733 \par
00734 {\cf17 static} {\cf18 void} GasIndexAlgorithm__mox_model__set_parameters(\par
00735     GasIndexAlgorithmParams* params, fix16_t SRAW_STD, fix16_t SRAW_MEAN) \{\par
00736 \par
00737     params->m_Mox_Model__Sraw_Std = SRAW_STD;\par
00738     params->m_Mox_Model__Sraw_Mean = SRAW_MEAN;\par
00739 \}\par
00740 \par
00741 {\cf17 static} fix16_t\par
00742 GasIndexAlgorithm__mox_model__process(GasIndexAlgorithmParams* params,\par
00743                                       fix16_t sraw) \{\par
00744 \par
00745     {\cf19 if} ((params->mAlgorithm_Type == GasIndexAlgorithm_ALGORITHM_TYPE_NOX)) \{\par
00746         {\cf19 return} (fix16_mul((fix16_div((sraw - params->m_Mox_Model__Sraw_Mean),\par
00747                                      F16(GasIndexAlgorithm_SRAW_STD_NOX))),\par
00748                           params->mIndex_Gain));\par
00749     \} {\cf19 else} \{\par
00750         {\cf19 return} (fix16_mul(\par
00751             (fix16_div((sraw - params->m_Mox_Model__Sraw_Mean),\par
00752                        (-(params->m_Mox_Model__Sraw_Std +\par
00753                           F16(GasIndexAlgorithm_SRAW_STD_BONUS_VOC))))),\par
00754             params->mIndex_Gain));\par
00755     \}\par
00756 \}\par
00757 \par
00758 {\cf17 static} {\cf18 void} GasIndexAlgorithm__sigmoid_scaled__set_parameters(\par
00759     GasIndexAlgorithmParams* params, fix16_t X0, fix16_t K,\par
00760     fix16_t offset_default) \{\par
00761 \par
00762     params->m_Sigmoid_Scaled__K = K;\par
00763     params->m_Sigmoid_Scaled__X0 = X0;\par
00764     params->m_Sigmoid_Scaled__Offset_Default = offset_default;\par
00765 \}\par
00766 \par
00767 {\cf17 static} fix16_t\par
00768 GasIndexAlgorithm__sigmoid_scaled__process(GasIndexAlgorithmParams* params,\par
00769                                            fix16_t sample) \{\par
00770 \par
00771     fix16_t x;\par
00772     fix16_t shift;\par
00773 \par
00774     x = (fix16_mul(params->m_Sigmoid_Scaled__K,\par
00775                    (sample - params->m_Sigmoid_Scaled__X0)));\par
00776     {\cf19 if} ((x < F16(-50.))) \{\par
00777         {\cf19 return} F16(GasIndexAlgorithm_SIGMOID_L);\par
00778     \} {\cf19 else} {\cf19 if} ((x > F16(50.))) \{\par
00779         {\cf19 return} F16(0.);\par
00780     \} {\cf19 else} \{\par
00781         {\cf19 if} ((sample >= F16(0.))) \{\par
00782             {\cf19 if} ((params->m_Sigmoid_Scaled__Offset_Default == F16(1.))) \{\par
00783                 shift = (fix16_mul(F16((500. / 499.)),\par
00784                                    (F16(1.) - params->mIndex_Offset)));\par
00785             \} {\cf19 else} \{\par
00786                 shift =\par
00787                     (fix16_div((F16(GasIndexAlgorithm_SIGMOID_L) -\par
00788                                 (fix16_mul(F16(5.), params->mIndex_Offset))),\par
00789                                F16(4.)));\par
00790             \}\par
00791             {\cf19 return} ((fix16_div((F16(GasIndexAlgorithm_SIGMOID_L) + shift),\par
00792                                (F16(1.) + fix16_exp(x)))) -\par
00793                     shift);\par
00794         \} {\cf19 else} \{\par
00795             {\cf19 return} (\par
00796                 fix16_mul((fix16_div(params->mIndex_Offset,\par
00797                                      params->m_Sigmoid_Scaled__Offset_Default)),\par
00798                           (fix16_div(F16(GasIndexAlgorithm_SIGMOID_L),\par
00799                                      (F16(1.) + fix16_exp(x))))));\par
00800         \}\par
00801     \}\par
00802 \}\par
00803 \par
00804 {\cf17 static} {\cf18 void} GasIndexAlgorithm__adaptive_lowpass__set_parameters(\par
00805     GasIndexAlgorithmParams* params) \{\par
00806 \par
00807     params->m_Adaptive_Lowpass__A1 = F16((\par
00808         GasIndexAlgorithm_SAMPLING_INTERVAL /\par
00809         (GasIndexAlgorithm_LP_TAU_FAST + GasIndexAlgorithm_SAMPLING_INTERVAL)));\par
00810     params->m_Adaptive_Lowpass__A2 = F16((\par
00811         GasIndexAlgorithm_SAMPLING_INTERVAL /\par
00812         (GasIndexAlgorithm_LP_TAU_SLOW + GasIndexAlgorithm_SAMPLING_INTERVAL)));\par
00813     params->m_Adaptive_Lowpass___Initialized = {\cf17 false};\par
00814 \}\par
00815 \par
00816 {\cf17 static} fix16_t\par
00817 GasIndexAlgorithm__adaptive_lowpass__process(GasIndexAlgorithmParams* params,\par
00818                                              fix16_t sample) \{\par
00819 \par
00820     fix16_t abs_delta;\par
00821     fix16_t F1;\par
00822     fix16_t tau_a;\par
00823     fix16_t a3;\par
00824 \par
00825     {\cf19 if} ((params->m_Adaptive_Lowpass___Initialized == {\cf17 false})) \{\par
00826         params->m_Adaptive_Lowpass___X1 = sample;\par
00827         params->m_Adaptive_Lowpass___X2 = sample;\par
00828         params->m_Adaptive_Lowpass___X3 = sample;\par
00829         params->m_Adaptive_Lowpass___Initialized = {\cf17 true};\par
00830     \}\par
00831     params->m_Adaptive_Lowpass___X1 =\par
00832         ((fix16_mul((F16(1.) - params->m_Adaptive_Lowpass__A1),\par
00833                     params->m_Adaptive_Lowpass___X1)) +\par
00834          (fix16_mul(params->m_Adaptive_Lowpass__A1, sample)));\par
00835     params->m_Adaptive_Lowpass___X2 =\par
00836         ((fix16_mul((F16(1.) - params->m_Adaptive_Lowpass__A2),\par
00837                     params->m_Adaptive_Lowpass___X2)) +\par
00838          (fix16_mul(params->m_Adaptive_Lowpass__A2, sample)));\par
00839     abs_delta =\par
00840         (params->m_Adaptive_Lowpass___X1 - params->m_Adaptive_Lowpass___X2);\par
00841     {\cf19 if} ((abs_delta < F16(0.))) \{\par
00842         abs_delta = (-abs_delta);\par
00843     \}\par
00844     F1 = fix16_exp((fix16_mul(F16(GasIndexAlgorithm_LP_ALPHA), abs_delta)));\par
00845     tau_a = ((fix16_mul(F16((GasIndexAlgorithm_LP_TAU_SLOW -\par
00846                              GasIndexAlgorithm_LP_TAU_FAST)),\par
00847                         F1)) +\par
00848              F16(GasIndexAlgorithm_LP_TAU_FAST));\par
00849     a3 = (fix16_div(F16(GasIndexAlgorithm_SAMPLING_INTERVAL),\par
00850                     (F16(GasIndexAlgorithm_SAMPLING_INTERVAL) + tau_a)));\par
00851     params->m_Adaptive_Lowpass___X3 =\par
00852         ((fix16_mul((F16(1.) - a3), params->m_Adaptive_Lowpass___X3)) +\par
00853          (fix16_mul(a3, sample)));\par
00854     {\cf19 return} params->m_Adaptive_Lowpass___X3;\par
00855 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/gas_index_algorithm/sensirion_gas_index_algorithm.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/gas_index_algorithm/sensirion_gas_index_algorithm.h}
{\xe \v lib/gas_index_algorithm/sensirion_gas_index_algorithm.h}
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GasIndexAlgorithmParams}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GASINDEXALGORITHM_H_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b F16}(x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b bool}\~ int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b true}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b false}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LIBRARY_VERSION_NAME}\~ "3.2.0"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_ALGORITHM_TYPE_VOC}\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_ALGORITHM_TYPE_NOX}\~ (1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_SAMPLING_INTERVAL}\~ (1.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_INITIAL_BLACKOUT}\~ (45.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_INDEX_GAIN}\~ (230.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_SRAW_STD_INITIAL}\~ (50.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_SRAW_STD_BONUS_VOC}\~ (220.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_SRAW_STD_NOX}\~ (2000.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TAU_MEAN_HOURS}\~ (12.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TAU_VARIANCE_HOURS}\~ (12.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TAU_INITIAL_MEAN_VOC}\~ (20.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TAU_INITIAL_MEAN_NOX}\~ (1200.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_INIT_DURATION_MEAN_VOC}\~ ((3600. * 0.75))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_INIT_DURATION_MEAN_NOX}\~ ((3600. * 4.75))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_INIT_TRANSITION_MEAN}\~ (0.01)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TAU_INITIAL_VARIANCE}\~ (2500.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_INIT_DURATION_VARIANCE_VOC}\~ ((3600. * 1.45))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_INIT_DURATION_VARIANCE_NOX}\~ ((3600. * 5.70))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_INIT_TRANSITION_VARIANCE}\~ (0.01)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_GATING_THRESHOLD_VOC}\~ (340.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_GATING_THRESHOLD_NOX}\~ (30.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_GATING_THRESHOLD_INITIAL}\~ (510.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_GATING_THRESHOLD_TRANSITION}\~ (0.09)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_GATING_VOC_MAX_DURATION_MINUTES}\~ ((60. * 3.))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_GATING_NOX_MAX_DURATION_MINUTES}\~ ((60. * 12.))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_GATING_MAX_RATIO}\~ (0.3)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_SIGMOID_L}\~ (500.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_SIGMOID_K_VOC}\~ (-0.0065)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_SIGMOID_X0_VOC}\~ (213.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_SIGMOID_K_NOX}\~ (-0.0101)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_SIGMOID_X0_NOX}\~ (614.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_VOC_INDEX_OFFSET_DEFAULT}\~ (100.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_NOX_INDEX_OFFSET_DEFAULT}\~ (1.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_LP_TAU_FAST}\~ (20.0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_LP_TAU_SLOW}\~ (500.0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_LP_ALPHA}\~ (-0.2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_VOC_SRAW_MINIMUM}\~ (20000)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_NOX_SRAW_MINIMUM}\~ (10000)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_PERSISTENCE_UPTIME_GAMMA}\~ ((3. * 3600.))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TUNING_INDEX_OFFSET_MIN}\~ (1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TUNING_INDEX_OFFSET_MAX}\~ (250)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TUNING_LEARNING_TIME_OFFSET_HOURS_MIN}\~ (1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TUNING_LEARNING_TIME_OFFSET_HOURS_MAX}\~ (1000)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TUNING_LEARNING_TIME_GAIN_HOURS_MIN}\~ (1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TUNING_LEARNING_TIME_GAIN_HOURS_MAX}\~ (1000)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TUNING_GATING_MAX_DURATION_MINUTES_MIN}\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TUNING_GATING_MAX_DURATION_MINUTES_MAX}\~ (3000)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TUNING_STD_INITIAL_MIN}\~ (10)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TUNING_STD_INITIAL_MAX}\~ (5000)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TUNING_GAIN_FACTOR_MIN}\~ (1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_TUNING_GAIN_FACTOR_MAX}\~ (1000)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING}\~ (64.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__ADDITIONAL_GAMMA_MEAN_SCALING}\~     (8.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__FIX16_MAX}\~ (32767.)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef int32_t {\b fix16_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GasIndexAlgorithm_init} ({\b GasIndexAlgorithmParams} *params, int32_t algorithm_type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GasIndexAlgorithm_reset} ({\b GasIndexAlgorithmParams} *params)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GasIndexAlgorithm_get_states} (const {\b GasIndexAlgorithmParams} *params, int32_t *state0, int32_t *state1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GasIndexAlgorithm_set_states} ({\b GasIndexAlgorithmParams} *params, int32_t state0, int32_t state1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GasIndexAlgorithm_set_tuning_parameters} ({\b GasIndexAlgorithmParams} *params, int32_t index_offset, int32_t learning_time_offset_hours, int32_t learning_time_gain_hours, int32_t gating_max_duration_minutes, int32_t std_initial, int32_t gain_factor)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GasIndexAlgorithm_get_tuning_parameters} (const {\b GasIndexAlgorithmParams} *params, int32_t *index_offset, int32_t *learning_time_offset_hours, int32_t *learning_time_gain_hours, int32_t *gating_max_duration_minutes, int32_t *std_initial, int32_t *gain_factor)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GasIndexAlgorithm_process} ({\b GasIndexAlgorithmParams} *params, int32_t sraw, int32_t *gas_index)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v bool\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define bool\~ int}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v F16\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:F16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define F16( x)}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     ((fix16_t)(((x) >= 0) ? ((x)*65536.0 + 0.5) : ((x)*65536.0 - 0.5)))\par
}
{
Definition at line {\b 46} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v false\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:false}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define false\~ 0}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_ALGORITHM_TYPE_NOX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_ALGORITHM_TYPE_NOX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_ALGORITHM_TYPE_NOX\~ (1)}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_ALGORITHM_TYPE_VOC\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_ALGORITHM_TYPE_VOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_ALGORITHM_TYPE_VOC\~ (0)}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_GATING_MAX_RATIO\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_GATING_MAX_RATIO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_GATING_MAX_RATIO\~ (0.3)}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_GATING_NOX_MAX_DURATION_MINUTES\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_GATING_NOX_MAX_DURATION_MINUTES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_GATING_NOX_MAX_DURATION_MINUTES\~ ((60. * 12.))}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_GATING_THRESHOLD_INITIAL\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_GATING_THRESHOLD_INITIAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_GATING_THRESHOLD_INITIAL\~ (510.)}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_GATING_THRESHOLD_NOX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_GATING_THRESHOLD_NOX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_GATING_THRESHOLD_NOX\~ (30.)}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_GATING_THRESHOLD_TRANSITION\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_GATING_THRESHOLD_TRANSITION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_GATING_THRESHOLD_TRANSITION\~ (0.09)}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_GATING_THRESHOLD_VOC\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_GATING_THRESHOLD_VOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_GATING_THRESHOLD_VOC\~ (340.)}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_GATING_VOC_MAX_DURATION_MINUTES\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_GATING_VOC_MAX_DURATION_MINUTES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_GATING_VOC_MAX_DURATION_MINUTES\~ ((60. * 3.))}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GASINDEXALGORITHM_H_\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GASINDEXALGORITHM_H_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GASINDEXALGORITHM_H_}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_INDEX_GAIN\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_INDEX_GAIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_INDEX_GAIN\~ (230.)}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_INIT_DURATION_MEAN_NOX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_INIT_DURATION_MEAN_NOX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_INIT_DURATION_MEAN_NOX\~ ((3600. * 4.75))}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_INIT_DURATION_MEAN_VOC\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_INIT_DURATION_MEAN_VOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_INIT_DURATION_MEAN_VOC\~ ((3600. * 0.75))}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_INIT_DURATION_VARIANCE_NOX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_INIT_DURATION_VARIANCE_NOX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_INIT_DURATION_VARIANCE_NOX\~ ((3600. * 5.70))}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_INIT_DURATION_VARIANCE_VOC\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_INIT_DURATION_VARIANCE_VOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_INIT_DURATION_VARIANCE_VOC\~ ((3600. * 1.45))}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_INIT_TRANSITION_MEAN\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_INIT_TRANSITION_MEAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_INIT_TRANSITION_MEAN\~ (0.01)}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_INIT_TRANSITION_VARIANCE\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_INIT_TRANSITION_VARIANCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_INIT_TRANSITION_VARIANCE\~ (0.01)}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_INITIAL_BLACKOUT\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_INITIAL_BLACKOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_INITIAL_BLACKOUT\~ (45.)}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_LP_ALPHA\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_LP_ALPHA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_LP_ALPHA\~ (-0.2)}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_LP_TAU_FAST\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_LP_TAU_FAST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_LP_TAU_FAST\~ (20.0)}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_LP_TAU_SLOW\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_LP_TAU_SLOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_LP_TAU_SLOW\~ (500.0)}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__ADDITIONAL_GAMMA_MEAN_SCALING\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__ADDITIONAL_GAMMA_MEAN_SCALING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__ADDITIONAL_GAMMA_MEAN_SCALING\~     (8.)}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__FIX16_MAX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__FIX16_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__FIX16_MAX\~ (32767.)}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING\~ (64.)}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_NOX_INDEX_OFFSET_DEFAULT\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_NOX_INDEX_OFFSET_DEFAULT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_NOX_INDEX_OFFSET_DEFAULT\~ (1.)}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_NOX_SRAW_MINIMUM\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_NOX_SRAW_MINIMUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_NOX_SRAW_MINIMUM\~ (10000)}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_PERSISTENCE_UPTIME_GAMMA\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_PERSISTENCE_UPTIME_GAMMA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_PERSISTENCE_UPTIME_GAMMA\~ ((3. * 3600.))}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_SAMPLING_INTERVAL\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_SAMPLING_INTERVAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_SAMPLING_INTERVAL\~ (1.)}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_SIGMOID_K_NOX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_SIGMOID_K_NOX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_SIGMOID_K_NOX\~ (-0.0101)}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_SIGMOID_K_VOC\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_SIGMOID_K_VOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_SIGMOID_K_VOC\~ (-0.0065)}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_SIGMOID_L\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_SIGMOID_L}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_SIGMOID_L\~ (500.)}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_SIGMOID_X0_NOX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_SIGMOID_X0_NOX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_SIGMOID_X0_NOX\~ (614.)}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_SIGMOID_X0_VOC\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_SIGMOID_X0_VOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_SIGMOID_X0_VOC\~ (213.)}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_SRAW_STD_BONUS_VOC\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_SRAW_STD_BONUS_VOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_SRAW_STD_BONUS_VOC\~ (220.)}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_SRAW_STD_INITIAL\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_SRAW_STD_INITIAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_SRAW_STD_INITIAL\~ (50.)}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_SRAW_STD_NOX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_SRAW_STD_NOX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_SRAW_STD_NOX\~ (2000.)}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TAU_INITIAL_MEAN_NOX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TAU_INITIAL_MEAN_NOX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TAU_INITIAL_MEAN_NOX\~ (1200.)}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TAU_INITIAL_MEAN_VOC\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TAU_INITIAL_MEAN_VOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TAU_INITIAL_MEAN_VOC\~ (20.)}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TAU_INITIAL_VARIANCE\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TAU_INITIAL_VARIANCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TAU_INITIAL_VARIANCE\~ (2500.)}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TAU_MEAN_HOURS\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TAU_MEAN_HOURS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TAU_MEAN_HOURS\~ (12.)}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TAU_VARIANCE_HOURS\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TAU_VARIANCE_HOURS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TAU_VARIANCE_HOURS\~ (12.)}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TUNING_GAIN_FACTOR_MAX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TUNING_GAIN_FACTOR_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TUNING_GAIN_FACTOR_MAX\~ (1000)}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 120} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TUNING_GAIN_FACTOR_MIN\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TUNING_GAIN_FACTOR_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TUNING_GAIN_FACTOR_MIN\~ (1)}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TUNING_GATING_MAX_DURATION_MINUTES_MAX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TUNING_GATING_MAX_DURATION_MINUTES_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TUNING_GATING_MAX_DURATION_MINUTES_MAX\~ (3000)}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TUNING_GATING_MAX_DURATION_MINUTES_MIN\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TUNING_GATING_MAX_DURATION_MINUTES_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TUNING_GATING_MAX_DURATION_MINUTES_MIN\~ (0)}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TUNING_INDEX_OFFSET_MAX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TUNING_INDEX_OFFSET_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TUNING_INDEX_OFFSET_MAX\~ (250)}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TUNING_INDEX_OFFSET_MIN\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TUNING_INDEX_OFFSET_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TUNING_INDEX_OFFSET_MIN\~ (1)}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TUNING_LEARNING_TIME_GAIN_HOURS_MAX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TUNING_LEARNING_TIME_GAIN_HOURS_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TUNING_LEARNING_TIME_GAIN_HOURS_MAX\~ (1000)}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TUNING_LEARNING_TIME_GAIN_HOURS_MIN\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TUNING_LEARNING_TIME_GAIN_HOURS_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TUNING_LEARNING_TIME_GAIN_HOURS_MIN\~ (1)}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TUNING_LEARNING_TIME_OFFSET_HOURS_MAX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TUNING_LEARNING_TIME_OFFSET_HOURS_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TUNING_LEARNING_TIME_OFFSET_HOURS_MAX\~ (1000)}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TUNING_LEARNING_TIME_OFFSET_HOURS_MIN\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TUNING_LEARNING_TIME_OFFSET_HOURS_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TUNING_LEARNING_TIME_OFFSET_HOURS_MIN\~ (1)}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TUNING_STD_INITIAL_MAX\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TUNING_STD_INITIAL_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TUNING_STD_INITIAL_MAX\~ (5000)}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_TUNING_STD_INITIAL_MIN\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_TUNING_STD_INITIAL_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_TUNING_STD_INITIAL_MIN\~ (10)}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_VOC_INDEX_OFFSET_DEFAULT\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_VOC_INDEX_OFFSET_DEFAULT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_VOC_INDEX_OFFSET_DEFAULT\~ (100.)}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v GasIndexAlgorithm_VOC_SRAW_MINIMUM\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_VOC_SRAW_MINIMUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GasIndexAlgorithm_VOC_SRAW_MINIMUM\~ (20000)}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 106} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v LIBRARY_VERSION_NAME\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:LIBRARY_VERSION_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LIBRARY_VERSION_NAME\~ "3.2.0"}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\xe \v true\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:true}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define true\~ 1}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v fix16_t\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:fix16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef int32_t {\b fix16_t}}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b sensirion_gas_index_algorithm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v GasIndexAlgorithm_get_states\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_get_states}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GasIndexAlgorithm_get_states (const {\b GasIndexAlgorithmParams} * params, int32_t * state0, int32_t * state1)}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get current algorithm states. Retrieved values can be used in {\b GasIndexAlgorithm_set_states()} to resume operation after a short interruption, skipping initial learning phase. NOTE: This feature can only be used for VOC algorithm type and after at least 3 hours of continuous operation. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i params} \cell }{Pointer to the {\b GasIndexAlgorithmParams} struct \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state0} \cell }{State0 to be stored \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state1} \cell }{State1 to be stored \cell }
{\row }
}
}{
Definition at line {\b 380} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v GasIndexAlgorithm_get_tuning_parameters\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_get_tuning_parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GasIndexAlgorithm_get_tuning_parameters (const {\b GasIndexAlgorithmParams} * params, int32_t * index_offset, int32_t * learning_time_offset_hours, int32_t * learning_time_gain_hours, int32_t * gating_max_duration_minutes, int32_t * std_initial, int32_t * gain_factor)}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get current parameters to customize the gas index algorithm. Refer to {\b GasIndexAlgorithm_set_tuning_parameters()} for description of the parameters. \par
}{
Definition at line {\b 416} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v GasIndexAlgorithm_init\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GasIndexAlgorithm_init ({\b GasIndexAlgorithmParams} * params, int32_t algorithm_type)}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the gas index algorithm parameters for the specified algorithm type and reset its internal states. Call this once at the beginning. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i params} \cell }{Pointer to the {\b GasIndexAlgorithmParams} struct \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i algorithm_type} \cell }{0 (GasIndexAlgorithm_ALGORITHM_TYPE_VOC) for VOC or 1 (GasIndexAlgorithm_ALGORITHM_TYPE_NOX) for NOx \cell }
{\row }
}
}{
Definition at line {\b 321} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v GasIndexAlgorithm_process\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_process}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GasIndexAlgorithm_process ({\b GasIndexAlgorithmParams} * params, int32_t sraw, int32_t * gas_index)}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculate the gas index value from the raw sensor value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i params} \cell }{Pointer to the {\b GasIndexAlgorithmParams} struct \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sraw} \cell }{Raw value from the SGP4x sensor \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gas_index} \cell }{Calculated gas index value from the raw sensor value. Zero during initial blackout period and 1..500 afterwards \cell }
{\row }
}
}{
Definition at line {\b 433} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v GasIndexAlgorithm_reset\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GasIndexAlgorithm_reset ({\b GasIndexAlgorithmParams} * params)}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset the internal states of the gas index algorithm. Previously set tuning parameters are preserved. Call this when resuming operation after a measurement interruption. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i params} \cell }{Pointer to the {\b GasIndexAlgorithmParams} struct \cell }
{\row }
}
}{
Definition at line {\b 353} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v GasIndexAlgorithm_set_states\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_set_states}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GasIndexAlgorithm_set_states ({\b GasIndexAlgorithmParams} * params, int32_t state0, int32_t state1)}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set previously retrieved algorithm states to resume operation after a short interruption, skipping initial learning phase. This feature should not be used after interruptions of more than 10 minutes. Call this once after {\b GasIndexAlgorithm_init()} or {\b GasIndexAlgorithm_reset()} and the optional {\b GasIndexAlgorithm_set_tuning_parameters()}, if desired. Otherwise, the algorithm will start with initial learning phase. NOTE: This feature can only be used for VOC algorithm type. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i params} \cell }{Pointer to the {\b GasIndexAlgorithmParams} struct \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state0} \cell }{State0 to be restored \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state1} \cell }{State1 to be restored \cell }
{\row }
}
}{
Definition at line {\b 388} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
{\xe \v GasIndexAlgorithm_set_tuning_parameters\:sensirion_gas_index_algorithm.h}
{\xe \v sensirion_gas_index_algorithm.h\:GasIndexAlgorithm_set_tuning_parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GasIndexAlgorithm_set_tuning_parameters ({\b GasIndexAlgorithmParams} * params, int32_t index_offset, int32_t learning_time_offset_hours, int32_t learning_time_gain_hours, int32_t gating_max_duration_minutes, int32_t std_initial, int32_t gain_factor)}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set parameters to customize the gas index algorithm. Call this once after {\b GasIndexAlgorithm_init()} and before optional {\b GasIndexAlgorithm_set_states()}, if desired. Otherwise, the default values will be used.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i params} \cell }{Pointer to the {\b GasIndexAlgorithmParams} struct \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index_offset} \cell }{Gas index representing typical (average) conditions. Range 1..250, default 100 for VOC and 1 for NOx \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i learning_time_offset_hours} \cell }{Time constant of long-term estimator for offset. Past events will be forgotten after about twice the learning time. Range 1..1000 [hours], default 12 [hours] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i learning_time_gain_hours} \cell }{Time constant of long-term estimator for gain. Past events will be forgotten after about twice the learning time. Range 1..1000 [hours], default 12 [hours] NOTE: This value is not relevant for NOx algorithm type \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gating_max_duration_minutes} \cell }{Maximum duration of gating (freeze of estimator during high gas index signal). 0 (no gating) or range 1..3000 [minutes], default 180 [minutes] for VOC and 720 [minutes] for NOx \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i std_initial} \cell }{Initial estimate for standard deviation. Lower value boosts events during initial learning period, but may result in larger device-to-device variations. Range 10..5000, default 50 NOTE: This value is not relevant for NOx algorithm type \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gain_factor} \cell }{Factor used to scale applied gain value when calculating gas index. Range 1..1000, default 230 \cell }
{\row }
}
}{
Definition at line {\b 400} of file {\b sensirion_gas_index_algorithm.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sensirion_gas_index_algorithm.h\par \pard\plain 
{\tc\tcl2 \v lib/gas_index_algorithm/sensirion_gas_index_algorithm.h}
{\xe \v lib/gas_index_algorithm/sensirion_gas_index_algorithm.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * Copyright (c) 2022, Sensirion AG}\par
00003 {\cf20  * All rights reserved.}\par
00004 {\cf20  *}\par
00005 {\cf20  * Redistribution and use in source and binary forms, with or without}\par
00006 {\cf20  * modification, are permitted provided that the following conditions are met:}\par
00007 {\cf20  *}\par
00008 {\cf20  * * Redistributions of source code must retain the above copyright notice, this}\par
00009 {\cf20  *   list of conditions and the following disclaimer.}\par
00010 {\cf20  *}\par
00011 {\cf20  * * Redistributions in binary form must reproduce the above copyright notice,}\par
00012 {\cf20  *   this list of conditions and the following disclaimer in the documentation}\par
00013 {\cf20  *   and/or other materials provided with the distribution.}\par
00014 {\cf20  *}\par
00015 {\cf20  * * Neither the name of Sensirion AG nor the names of its}\par
00016 {\cf20  *   contributors may be used to endorse or promote products derived from}\par
00017 {\cf20  *   this software without specific prior written permission.}\par
00018 {\cf20  *}\par
00019 {\cf20  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}\par
00020 {\cf20  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}\par
00021 {\cf20  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}\par
00022 {\cf20  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE}\par
00023 {\cf20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}\par
00024 {\cf20  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}\par
00025 {\cf20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}\par
00026 {\cf20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}\par
00027 {\cf20  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}\par
00028 {\cf20  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}\par
00029 {\cf20  * POSSIBILITY OF SUCH DAMAGE.}\par
00030 {\cf20  */}\par
00031 {\cf21 #ifdef __cplusplus}\par
00032 {\cf17 extern} {\cf22 "C"} \{\par
00033 {\cf21 #endif}\par
00034 \par
00035 {\cf21 #ifndef GASINDEXALGORITHM_H_}\par
00036 {\cf21 #define GASINDEXALGORITHM_H_}\par
00037 \par
00038 {\cf21 #include <stdint.h>}\par
00039 \par
00040 {\cf20 /* The fixed point arithmetic parts of this code were originally created by}\par
00041 {\cf20  * https://github.com/PetteriAimonen/libfixmath}\par
00042 {\cf20  */}\par
00043 \par
00044 {\cf17 typedef} int32_t fix16_t;\par
00045 \par
00046 {\cf21 #define F16(x) \\}\par
00047 {\cf21     ((fix16_t)(((x) >= 0) ? ((x)*65536.0 + 0.5) : ((x)*65536.0 - 0.5)))}\par
00048 \par
00049 {\cf21 #ifndef __cplusplus}\par
00050 \par
00051 {\cf21 #if __STDC_VERSION__ >= 199901L}\par
00052 {\cf21 #include <stdbool.h>}\par
00053 {\cf21 #else}\par
00054 \par
00055 {\cf21 #ifndef bool}\par
00056 {\cf21 #define bool int}\par
00057 {\cf21 #define true 1}\par
00058 {\cf21 #define false 0}\par
00059 {\cf21 #endif  }{\cf20 // bool}\par
00060 \par
00061 {\cf21 #endif  }{\cf20 // __STDC_VERSION__}\par
00062 \par
00063 {\cf21 #endif  }{\cf20 // __cplusplus}\par
00064 \par
00065 {\cf20 // Should be set by the building toolchain}\par
00066 {\cf21 #ifndef LIBRARY_VERSION_NAME}\par
00067 {\cf21 #define LIBRARY_VERSION_NAME "3.2.0"}\par
00068 {\cf21 #endif}\par
00069 \par
00070 {\cf21 #define GasIndexAlgorithm_ALGORITHM_TYPE_VOC (0)}\par
00071 {\cf21 #define GasIndexAlgorithm_ALGORITHM_TYPE_NOX (1)}\par
00072 {\cf21 #define GasIndexAlgorithm_SAMPLING_INTERVAL (1.)}\par
00073 {\cf21 #define GasIndexAlgorithm_INITIAL_BLACKOUT (45.)}\par
00074 {\cf21 #define GasIndexAlgorithm_INDEX_GAIN (230.)}\par
00075 {\cf21 #define GasIndexAlgorithm_SRAW_STD_INITIAL (50.)}\par
00076 {\cf21 #define GasIndexAlgorithm_SRAW_STD_BONUS_VOC (220.)}\par
00077 {\cf21 #define GasIndexAlgorithm_SRAW_STD_NOX (2000.)}\par
00078 {\cf21 #define GasIndexAlgorithm_TAU_MEAN_HOURS (12.)}\par
00079 {\cf21 #define GasIndexAlgorithm_TAU_VARIANCE_HOURS (12.)}\par
00080 {\cf21 #define GasIndexAlgorithm_TAU_INITIAL_MEAN_VOC (20.)}\par
00081 {\cf21 #define GasIndexAlgorithm_TAU_INITIAL_MEAN_NOX (1200.)}\par
00082 {\cf21 #define GasIndexAlgorithm_INIT_DURATION_MEAN_VOC ((3600. * 0.75))}\par
00083 {\cf21 #define GasIndexAlgorithm_INIT_DURATION_MEAN_NOX ((3600. * 4.75))}\par
00084 {\cf21 #define GasIndexAlgorithm_INIT_TRANSITION_MEAN (0.01)}\par
00085 {\cf21 #define GasIndexAlgorithm_TAU_INITIAL_VARIANCE (2500.)}\par
00086 {\cf21 #define GasIndexAlgorithm_INIT_DURATION_VARIANCE_VOC ((3600. * 1.45))}\par
00087 {\cf21 #define GasIndexAlgorithm_INIT_DURATION_VARIANCE_NOX ((3600. * 5.70))}\par
00088 {\cf21 #define GasIndexAlgorithm_INIT_TRANSITION_VARIANCE (0.01)}\par
00089 {\cf21 #define GasIndexAlgorithm_GATING_THRESHOLD_VOC (340.)}\par
00090 {\cf21 #define GasIndexAlgorithm_GATING_THRESHOLD_NOX (30.)}\par
00091 {\cf21 #define GasIndexAlgorithm_GATING_THRESHOLD_INITIAL (510.)}\par
00092 {\cf21 #define GasIndexAlgorithm_GATING_THRESHOLD_TRANSITION (0.09)}\par
00093 {\cf21 #define GasIndexAlgorithm_GATING_VOC_MAX_DURATION_MINUTES ((60. * 3.))}\par
00094 {\cf21 #define GasIndexAlgorithm_GATING_NOX_MAX_DURATION_MINUTES ((60. * 12.))}\par
00095 {\cf21 #define GasIndexAlgorithm_GATING_MAX_RATIO (0.3)}\par
00096 {\cf21 #define GasIndexAlgorithm_SIGMOID_L (500.)}\par
00097 {\cf21 #define GasIndexAlgorithm_SIGMOID_K_VOC (-0.0065)}\par
00098 {\cf21 #define GasIndexAlgorithm_SIGMOID_X0_VOC (213.)}\par
00099 {\cf21 #define GasIndexAlgorithm_SIGMOID_K_NOX (-0.0101)}\par
00100 {\cf21 #define GasIndexAlgorithm_SIGMOID_X0_NOX (614.)}\par
00101 {\cf21 #define GasIndexAlgorithm_VOC_INDEX_OFFSET_DEFAULT (100.)}\par
00102 {\cf21 #define GasIndexAlgorithm_NOX_INDEX_OFFSET_DEFAULT (1.)}\par
00103 {\cf21 #define GasIndexAlgorithm_LP_TAU_FAST (20.0)}\par
00104 {\cf21 #define GasIndexAlgorithm_LP_TAU_SLOW (500.0)}\par
00105 {\cf21 #define GasIndexAlgorithm_LP_ALPHA (-0.2)}\par
00106 {\cf21 #define GasIndexAlgorithm_VOC_SRAW_MINIMUM (20000)}\par
00107 {\cf21 #define GasIndexAlgorithm_NOX_SRAW_MINIMUM (10000)}\par
00108 {\cf21 #define GasIndexAlgorithm_PERSISTENCE_UPTIME_GAMMA ((3. * 3600.))}\par
00109 {\cf21 #define GasIndexAlgorithm_TUNING_INDEX_OFFSET_MIN (1)}\par
00110 {\cf21 #define GasIndexAlgorithm_TUNING_INDEX_OFFSET_MAX (250)}\par
00111 {\cf21 #define GasIndexAlgorithm_TUNING_LEARNING_TIME_OFFSET_HOURS_MIN (1)}\par
00112 {\cf21 #define GasIndexAlgorithm_TUNING_LEARNING_TIME_OFFSET_HOURS_MAX (1000)}\par
00113 {\cf21 #define GasIndexAlgorithm_TUNING_LEARNING_TIME_GAIN_HOURS_MIN (1)}\par
00114 {\cf21 #define GasIndexAlgorithm_TUNING_LEARNING_TIME_GAIN_HOURS_MAX (1000)}\par
00115 {\cf21 #define GasIndexAlgorithm_TUNING_GATING_MAX_DURATION_MINUTES_MIN (0)}\par
00116 {\cf21 #define GasIndexAlgorithm_TUNING_GATING_MAX_DURATION_MINUTES_MAX (3000)}\par
00117 {\cf21 #define GasIndexAlgorithm_TUNING_STD_INITIAL_MIN (10)}\par
00118 {\cf21 #define GasIndexAlgorithm_TUNING_STD_INITIAL_MAX (5000)}\par
00119 {\cf21 #define GasIndexAlgorithm_TUNING_GAIN_FACTOR_MIN (1)}\par
00120 {\cf21 #define GasIndexAlgorithm_TUNING_GAIN_FACTOR_MAX (1000)}\par
00121 {\cf21 #define GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING (64.)}\par
00122 {\cf21 #define GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__ADDITIONAL_GAMMA_MEAN_SCALING \\}\par
00123 {\cf21     (8.)}\par
00124 {\cf21 #define GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__FIX16_MAX (32767.)}\par
00125 \par
00129 {\cf17 typedef} {\cf17 struct }\{\par
00130     int32_t mAlgorithm_Type;\par
00131     fix16_t mIndex_Offset;\par
00132     int32_t mSraw_Minimum;\par
00133     fix16_t mGating_Max_Duration_Minutes;\par
00134     fix16_t mInit_Duration_Mean;\par
00135     fix16_t mInit_Duration_Variance;\par
00136     fix16_t mGating_Threshold;\par
00137     fix16_t mIndex_Gain;\par
00138     fix16_t mTau_Mean_Hours;\par
00139     fix16_t mTau_Variance_Hours;\par
00140     fix16_t mSraw_Std_Initial;\par
00141     fix16_t mUptime;\par
00142     fix16_t mSraw;\par
00143     fix16_t mGas_Index;\par
00144     {\cf18 bool} m_Mean_Variance_Estimator___Initialized;\par
00145     fix16_t m_Mean_Variance_Estimator___Mean;\par
00146     fix16_t m_Mean_Variance_Estimator___Sraw_Offset;\par
00147     fix16_t m_Mean_Variance_Estimator___Std;\par
00148     fix16_t m_Mean_Variance_Estimator___Gamma_Mean;\par
00149     fix16_t m_Mean_Variance_Estimator___Gamma_Variance;\par
00150     fix16_t m_Mean_Variance_Estimator___Gamma_Initial_Mean;\par
00151     fix16_t m_Mean_Variance_Estimator___Gamma_Initial_Variance;\par
00152     fix16_t m_Mean_Variance_Estimator__Gamma_Mean;\par
00153     fix16_t m_Mean_Variance_Estimator__Gamma_Variance;\par
00154     fix16_t m_Mean_Variance_Estimator___Uptime_Gamma;\par
00155     fix16_t m_Mean_Variance_Estimator___Uptime_Gating;\par
00156     fix16_t m_Mean_Variance_Estimator___Gating_Duration_Minutes;\par
00157     fix16_t m_Mean_Variance_Estimator___Sigmoid__K;\par
00158     fix16_t m_Mean_Variance_Estimator___Sigmoid__X0;\par
00159     fix16_t m_Mox_Model__Sraw_Std;\par
00160     fix16_t m_Mox_Model__Sraw_Mean;\par
00161     fix16_t m_Sigmoid_Scaled__K;\par
00162     fix16_t m_Sigmoid_Scaled__X0;\par
00163     fix16_t m_Sigmoid_Scaled__Offset_Default;\par
00164     fix16_t m_Adaptive_Lowpass__A1;\par
00165     fix16_t m_Adaptive_Lowpass__A2;\par
00166     {\cf18 bool} m_Adaptive_Lowpass___Initialized;\par
00167     fix16_t m_Adaptive_Lowpass___X1;\par
00168     fix16_t m_Adaptive_Lowpass___X2;\par
00169     fix16_t m_Adaptive_Lowpass___X3;\par
00170 \} GasIndexAlgorithmParams;\par
00171 \par
00179 {\cf18 void} GasIndexAlgorithm_init(GasIndexAlgorithmParams* params,\par
00180                             int32_t algorithm_type);\par
00181 \par
00188 {\cf18 void} GasIndexAlgorithm_reset(GasIndexAlgorithmParams* params);\par
00189 \par
00200 {\cf18 void} GasIndexAlgorithm_get_states({\cf17 const} GasIndexAlgorithmParams* params,\par
00201                                   int32_t* state0, int32_t* state1);\par
00202 \par
00215 {\cf18 void} GasIndexAlgorithm_set_states(GasIndexAlgorithmParams* params,\par
00216                                   int32_t state0, int32_t state1);\par
00217 \par
00254 {\cf18 void} GasIndexAlgorithm_set_tuning_parameters(\par
00255     GasIndexAlgorithmParams* params, int32_t index_offset,\par
00256     int32_t learning_time_offset_hours, int32_t learning_time_gain_hours,\par
00257     int32_t gating_max_duration_minutes, int32_t std_initial,\par
00258     int32_t gain_factor);\par
00259 \par
00265 {\cf18 void} GasIndexAlgorithm_get_tuning_parameters(\par
00266     {\cf17 const} GasIndexAlgorithmParams* params, int32_t* index_offset,\par
00267     int32_t* learning_time_offset_hours, int32_t* learning_time_gain_hours,\par
00268     int32_t* gating_max_duration_minutes, int32_t* std_initial,\par
00269     int32_t* gain_factor);\par
00270 \par
00279 {\cf18 void} GasIndexAlgorithm_process(GasIndexAlgorithmParams* params, int32_t sraw,\par
00280                                int32_t* gas_index);\par
00281 \par
00282 {\cf21 #endif }{\cf20 /* GASINDEXALGORITHM_H_ */}{\cf21 }\par
00283 \par
00284 {\cf21 #ifdef __cplusplus}\par
00285 \}\par
00286 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/gpio/gpio.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/gpio/gpio.c}
{\xe \v lib/gpio/gpio.c}
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <gpio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_mode_output} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Configure one output pin. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_mode_input_pullup} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Configure one input pin and enable pull-up. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_write_low} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write one pin to low value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_write_high} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write one pin to high value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b gpio_read} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a value from input pin. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_mode_input_nopull} (volatile uint8_t *reg, uint8_t pin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_toggle} (volatile uint8_t *reg, uint8_t pin)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gpio.c\par \pard\plain 
{\tc\tcl2 \v lib/gpio/gpio.c}
{\xe \v lib/gpio/gpio.c}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /* }\par
00002 {\cf20  * GPIO library for AVR-GCC.}\par
00003 {\cf20  * (c) 2019-2024 Tomas Fryza, MIT license}\par
00004 {\cf20  *}\par
00005 {\cf20  * Developed using PlatformIO and AVR 8-bit Toolchain 3.6.2.}\par
00006 {\cf20  * Tested on Arduino Uno board and ATmega328P, 16 MHz.}\par
00007 {\cf20  */}\par
00008 \par
00009 {\cf20 // -- Includes -------------------------------------------------------}\par
00010 {\cf21 #include <gpio.h>}\par
00011 \par
00012 \par
00013 {\cf20 // -- Function definitions -------------------------------------------}\par
00014 {\cf20 /*}\par
00015 {\cf20  * Function: gpio_mode_output()}\par
00016 {\cf20  * Purpose:  Configure one output pin.}\par
00017 {\cf20  * Input(s): reg - Address of Data Direction Register, such as &DDRB}\par
00018 {\cf20  *           pin - Pin designation in the interval 0 to 7}\par
00019 {\cf20  * Returns:  none}\par
00020 {\cf20  */}\par
00021 {\cf18 void} gpio_mode_output({\cf17 volatile} uint8_t *reg, uint8_t pin)\par
00022 \{\par
00023     *reg = *reg | (1<<pin);\par
00024 \}\par
00025 \par
00026 \par
00027 {\cf20 /*}\par
00028 {\cf20  * Function: gpio_mode_input_pullup()}\par
00029 {\cf20  * Purpose:  Configure one input pin and enable pull-up.}\par
00030 {\cf20  * Input(s): reg - Address of Data Direction Register, such as &DDRB}\par
00031 {\cf20  *           pin - Pin designation in the interval 0 to 7}\par
00032 {\cf20  * Returns:  none}\par
00033 {\cf20  */}\par
00034 {\cf18 void} gpio_mode_input_pullup({\cf17 volatile} uint8_t *reg, uint8_t pin)\par
00035 \{\par
00036     *reg = *reg & ~(1<<pin);  {\cf20 // Data Direction Register}\par
00037     reg++;                    {\cf20 // Change pointer to Data Register}\par
00038     *reg = *reg | (1<<pin);   {\cf20 // Data Register}\par
00039 \}\par
00040 \par
00041 \par
00042 {\cf20 /*}\par
00043 {\cf20  * Function: gpio_write_low()}\par
00044 {\cf20  * Purpose:  Write one pin to low value.}\par
00045 {\cf20  * Input(s): reg - Address of Port Register, such as &PORTB}\par
00046 {\cf20  *           pin - Pin designation in the interval 0 to 7}\par
00047 {\cf20  * Returns:  none}\par
00048 {\cf20  */}\par
00049 {\cf18 void} gpio_write_low({\cf17 volatile} uint8_t *reg, uint8_t pin)\par
00050 \{\par
00051     *reg = *reg & ~(1<<pin);\par
00052 \}\par
00053 \par
00054 \par
00055 {\cf20 /*}\par
00056 {\cf20  * Function: gpio_write_high()}\par
00057 {\cf20  * Purpose:  Write one pin to high value.}\par
00058 {\cf20  * Input(s): reg - Address of Port Register, such as &PORTB}\par
00059 {\cf20  *           pin - Pin designation in the interval 0 to 7}\par
00060 {\cf20  * Returns:  none}\par
00061 {\cf20  */}\par
00062 {\cf18 void} gpio_write_high({\cf17 volatile} uint8_t *reg, uint8_t pin)\par
00063 \{\par
00064     *reg = *reg | (1<<pin);\par
00065 \}\par
00066 \par
00067 \par
00068 {\cf20 /*}\par
00069 {\cf20  * Function: gpio_read()}\par
00070 {\cf20  * Purpose:  Read a value from input pin.}\par
00071 {\cf20  * Input(s): reg - Address of Pin Register, such as &PINB}\par
00072 {\cf20  *           pin - Pin designation in the interval 0 to 7}\par
00073 {\cf20  * Returns:  Pin value}\par
00074 {\cf20  */}\par
00075 uint8_t gpio_read({\cf17 volatile} uint8_t *reg, uint8_t pin)\par
00076 \{\par
00077     uint8_t temp;\par
00078 \par
00079     temp = *reg & (1<<pin);\par
00080 \par
00081     {\cf19 if} (temp != 0) \{\par
00082         {\cf19 return} 1;\par
00083     \}\par
00084     {\cf19 else} \{\par
00085         {\cf19 return} 0;\par
00086     \}\par
00087 \}\par
00088 \par
00089 \par
00090 \par
00091 {\cf18 void} gpio_mode_input_nopull({\cf17 volatile} uint8_t *reg, uint8_t pin)\par
00092 \{\par
00093     *reg = *reg & ~(1<<pin);\par
00094 \}\par
00095 \par
00096 \par
00097 \par
00098 {\cf18 void} gpio_toggle({\cf17 volatile} uint8_t *reg, uint8_t pin)\par
00099  \{\par
00100     *reg = *reg ^ (1 << pin);\par
00101     reg++;                    {\cf20 // Change pointer to Data Register}\par
00102     *reg = *reg & ~(1<<pin);\par
00103  \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/gpio/gpio.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/gpio/gpio.h}
{\xe \v lib/gpio/gpio.h}
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <avr/io.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_mode_output} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Configure one output pin. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_mode_input_pullup} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Configure one input pin and enable pull-up. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_write_low} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write one pin to low value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_write_high} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write one pin to high value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b gpio_read} (volatile uint8_t *reg, uint8_t pin)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a value from input pin. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_mode_input_nopull} (volatile uint8_t *reg, uint8_t pin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpio_toggle} (volatile uint8_t *reg, uint8_t pin)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gpio.h\par \pard\plain 
{\tc\tcl2 \v lib/gpio/gpio.h}
{\xe \v lib/gpio/gpio.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef GPIO_H}\par
00002 {\cf21 # define GPIO_H}\par
00003 \par
00004 {\cf20 /* }\par
00005 {\cf20  * GPIO library for AVR-GCC.}\par
00006 {\cf20  * (c) 2019-2024 Tomas Fryza, MIT license}\par
00007 {\cf20  *}\par
00008 {\cf20  * Developed using PlatformIO and AVR 8-bit Toolchain 3.6.2.}\par
00009 {\cf20  * Tested on Arduino Uno board and ATmega328P, 16 MHz.}\par
00010 {\cf20  */}\par
00011 \par
00025 \par
00026 {\cf20 // -- Includes -------------------------------------------------------}\par
00027 {\cf21 #include <avr/io.h>}\par
00028 \par
00029 \par
00030 {\cf20 // -- Function prototypes --------------------------------------------}\par
00037 {\cf18 void} gpio_mode_output({\cf17 volatile} uint8_t *reg, uint8_t pin);\par
00038 \par
00039 \par
00046 {\cf18 void} gpio_mode_input_pullup({\cf17 volatile} uint8_t *reg, uint8_t pin);\par
00047 \par
00048 \par
00055 {\cf18 void} gpio_write_low({\cf17 volatile} uint8_t *reg, uint8_t pin);\par
00056 \par
00057 \par
00064 {\cf18 void} gpio_write_high({\cf17 volatile} uint8_t *reg, uint8_t pin);\par
00065 \par
00066 \par
00073 uint8_t gpio_read({\cf17 volatile} uint8_t *reg, uint8_t pin);\par
00074 \par
00075 \par
00076 {\cf18 void} gpio_mode_input_nopull({\cf17 volatile} uint8_t *reg, uint8_t pin);\par
00077 \par
00078 \par
00079 {\cf18 void} gpio_toggle({\cf17 volatile} uint8_t *reg, uint8_t pin);\par
00080 \par
00081 \par
00083 \par
00084 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/rtc/rtc.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/rtc/rtc.c}
{\xe \v lib/rtc/rtc.c}
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "rtc.h"}\par
{\f2 #include <twi.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_ADDRESS}\~ 0x68\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_SEC}\~ 0x00\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_MIN}\~ 0x01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_HOUR}\~ 0x02\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_DAY}\~ 0x03\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_DATE}\~ 0x04\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_MONTH}\~ 0x05\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_YEAR}\~ 0x06\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rtc_setup} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rtc_read_reg} (uint8_t reg_addr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rtc_write_reg} (uint8_t reg_addr, uint8_t {\b data})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rtc_set_time} (uint8_t hours, uint8_t minutes, uint8_t seconds)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rtc_get_time} (uint8_t *hours, uint8_t *minutes, uint8_t *seconds)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rtc_get_date} (uint8_t *date, uint8_t *month, uint8_t *year)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rtc_get_day} (uint8_t *day)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rtc_set_date} (uint8_t day, uint8_t date, uint8_t month, uint8_t year)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b RTC_read} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b getDateTime_FAT} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v RTC_ADDRESS\:rtc.c}
{\xe \v rtc.c\:RTC_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_ADDRESS\~ 0x68}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b rtc.c}.}\par
}
{\xe \v RTC_DATE\:rtc.c}
{\xe \v rtc.c\:RTC_DATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_DATE\~ 0x04}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b rtc.c}.}\par
}
{\xe \v RTC_DAY\:rtc.c}
{\xe \v rtc.c\:RTC_DAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_DAY\~ 0x03}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b rtc.c}.}\par
}
{\xe \v RTC_HOUR\:rtc.c}
{\xe \v rtc.c\:RTC_HOUR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_HOUR\~ 0x02}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b rtc.c}.}\par
}
{\xe \v RTC_MIN\:rtc.c}
{\xe \v rtc.c\:RTC_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_MIN\~ 0x01}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b rtc.c}.}\par
}
{\xe \v RTC_MONTH\:rtc.c}
{\xe \v rtc.c\:RTC_MONTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_MONTH\~ 0x05}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b rtc.c}.}\par
}
{\xe \v RTC_SEC\:rtc.c}
{\xe \v rtc.c\:RTC_SEC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_SEC\~ 0x00}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b rtc.c}.}\par
}
{\xe \v RTC_YEAR\:rtc.c}
{\xe \v rtc.c\:RTC_YEAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_YEAR\~ 0x06}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b rtc.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v getDateTime_FAT\:rtc.c}
{\xe \v rtc.c\:getDateTime_FAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char getDateTime_FAT (void )}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b rtc.c}.}\par
}
{\xe \v rtc_get_date\:rtc.c}
{\xe \v rtc.c\:rtc_get_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rtc_get_date (uint8_t * date, uint8_t * month, uint8_t * year)}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b rtc.c}.}\par
}
{\xe \v rtc_get_day\:rtc.c}
{\xe \v rtc.c\:rtc_get_day}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rtc_get_day (uint8_t * day)}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b rtc.c}.}\par
}
{\xe \v rtc_get_time\:rtc.c}
{\xe \v rtc.c\:rtc_get_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rtc_get_time (uint8_t * hours, uint8_t * minutes, uint8_t * seconds)}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b rtc.c}.}\par
}
{\xe \v RTC_read\:rtc.c}
{\xe \v rtc.c\:RTC_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t RTC_read (void )}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b rtc.c}.}\par
}
{\xe \v rtc_read_reg\:rtc.c}
{\xe \v rtc.c\:rtc_read_reg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rtc_read_reg (uint8_t reg_addr)}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b rtc.c}.}\par
}
{\xe \v rtc_set_date\:rtc.c}
{\xe \v rtc.c\:rtc_set_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rtc_set_date (uint8_t day, uint8_t date, uint8_t month, uint8_t year)}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b rtc.c}.}\par
}
{\xe \v rtc_set_time\:rtc.c}
{\xe \v rtc.c\:rtc_set_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rtc_set_time (uint8_t hours, uint8_t minutes, uint8_t seconds)}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b rtc.c}.}\par
}
{\xe \v rtc_setup\:rtc.c}
{\xe \v rtc.c\:rtc_setup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rtc_setup (void )}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b rtc.c}.}\par
}
{\xe \v rtc_write_reg\:rtc.c}
{\xe \v rtc.c\:rtc_write_reg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rtc_write_reg (uint8_t reg_addr, uint8_t data)}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b rtc.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
rtc.c\par \pard\plain 
{\tc\tcl2 \v lib/rtc/rtc.c}
{\xe \v lib/rtc/rtc.c}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "rtc.h"}\par
00002 {\cf21 #include <twi.h>}\par
00003 \par
00004 \par
00005 {\cf21 #define RTC_ADDRESS 0x68  }{\cf20 // I2C slave address of RTC DS3231}\par
00006 \par
00007 {\cf20 //adresy registrov}\par
00008 {\cf21 #define RTC_SEC 0x00    }{\cf20 // RTC register address for "seconds"}\par
00009 {\cf21 #define RTC_MIN 0x01    }{\cf20 // RTC register address for "minutes"}\par
00010 {\cf21 #define RTC_HOUR 0x02   }{\cf20 // RTC register address for "hours"}\par
00011 {\cf21 #define RTC_DAY 0x03}\par
00012 {\cf21 #define RTC_DATE 0x04}\par
00013 {\cf21 #define RTC_MONTH 0x05}\par
00014 {\cf21 #define RTC_YEAR 0x06}\par
00015 {\cf20 // #define RTC_CONTROL 0x07}\par
00016 \par
00017 {\cf20 // -- Functions --------------------------------------------}\par
00018 {\cf17 static} {\cf17 inline} uint8_t decimal_to_bcd(uint8_t value)\par
00019 \{\par
00020     {\cf19 return} (uint8_t)((value / 10) << 4) | (value % 10);\par
00021 \}\par
00022 \par
00023 {\cf17 static} {\cf17 inline} uint8_t bcd_to_decimal(uint8_t bcd)\par
00024 \{\par
00025     {\cf19 return} (uint8_t)(((bcd >> 4) * 10) + (bcd & 0x0F));\par
00026 \}\par
00027 \par
00028 {\cf18 void} rtc_setup({\cf18 void})\par
00029 \{   \par
00030     {\cf20 //start oscilator and select 24-hour mode}\par
00031     uint8_t sec_reg = rtc_read_reg(RTC_SEC);\par
00032     uint8_t hour_reg = rtc_read_reg(RTC_HOUR);\par
00033     hour_reg &= ~(1 << 6); {\cf20 // Clear 12/24 bit to select 24-hour mode}\par
00034     sec_reg &= ~(1 << 7); {\cf20 // Clear CH (Clock Halt) bit to start the oscillator}\par
00035     rtc_write_reg(RTC_SEC, sec_reg);\par
00036     rtc_write_reg(RTC_HOUR, hour_reg);\par
00037     rtc_write_reg(RTC_CONTROL, 0x00); {\cf20 // set the control register to disable oscillator output}\par
00038 \par
00039 \}\par
00040 \par
00041 uint8_t rtc_read_reg(uint8_t reg_addr)\par
00042 \{\par
00043     uint8_t data = 0;\par
00044     twi_readfrom_mem_into(RTC_ADDRESS, reg_addr, &data, 1);\par
00045     {\cf19 return} data;\par
00046 \}\par
00047 \par
00048 uint8_t rtc_write_reg(uint8_t reg_addr, uint8_t data)\par
00049 \{\par
00050     {\cf19 return} twi_writeto_mem(RTC_ADDRESS, reg_addr, data);\par
00051 \}\par
00052 \par
00053 uint8_t rtc_set_time(uint8_t hours, uint8_t minutes, uint8_t seconds)\par
00054 \{\par
00055     rtc_write_reg(RTC_HOUR, decimal_to_bcd(hours));\par
00056     rtc_write_reg(RTC_MIN, decimal_to_bcd(minutes));\par
00057     rtc_write_reg(RTC_SEC, decimal_to_bcd(seconds));\par
00058     {\cf19 return} 0;\par
00059 \}\par
00060 \par
00061 uint8_t rtc_get_time(uint8_t *hours, uint8_t *minutes, uint8_t *seconds)\par
00062 \{\par
00063     uint8_t sec_bcd = rtc_read_reg(RTC_SEC);\par
00064     uint8_t min_bcd = rtc_read_reg(RTC_MIN);\par
00065     uint8_t hour_bcd = rtc_read_reg(RTC_HOUR);\par
00066 \par
00067     *seconds = bcd_to_decimal(sec_bcd); {\cf20 // CH bit je stale nulovy takze netreba maskovat}\par
00068     *minutes = bcd_to_decimal(min_bcd);\par
00069     *hours = bcd_to_decimal(hour_bcd); {\cf20 // netreba maskovat ani 24h mod lebo ten bit 6 je stale nulovy}\par
00070 \par
00071     {\cf19 return} 0;\par
00072 \}\par
00073 uint8_t rtc_get_date(uint8_t *date, uint8_t *month, uint8_t *year)\par
00074 \{\par
00075     uint8_t date_bcd = rtc_read_reg(RTC_DATE);\par
00076     uint8_t month_bcd = rtc_read_reg(RTC_MONTH);\par
00077     uint8_t year_bcd = rtc_read_reg(RTC_YEAR);\par
00078 \par
00079     *date = bcd_to_decimal(date_bcd);\par
00080     *month = bcd_to_decimal(month_bcd);\par
00081     *year = bcd_to_decimal(year_bcd);\par
00082 \par
00083     {\cf19 return} 0;\par
00084 \}\par
00085 uint8_t rtc_get_day(uint8_t *day)\par
00086 \{\par
00087     uint8_t day_bcd = rtc_read_reg(RTC_DAY);\par
00088     *day = bcd_to_decimal(day_bcd);\par
00089     {\cf19 return} 0;\par
00090 \}\par
00091 uint8_t rtc_set_date(uint8_t day, uint8_t date, uint8_t month, uint8_t year)\par
00092 \{\par
00093     rtc_write_reg(RTC_DAY, decimal_to_bcd(day));\par
00094     rtc_write_reg(RTC_DATE, decimal_to_bcd(date));\par
00095     rtc_write_reg(RTC_MONTH, decimal_to_bcd(month));\par
00096     rtc_write_reg(RTC_YEAR, decimal_to_bcd(year));\par
00097     {\cf19 return} 0;\par
00098 \}\par
00099 uint8_t RTC_read({\cf18 void})\par
00100 \{\par
00101     twi_readfrom_mem_into(RTC_ADDRESS, RTC_SEC, &rtc_register[0], 7);\par
00102     {\cf19 return} 0;\par
00103 \}\par
00104 {\cf18 unsigned} {\cf18 char} getDateTime_FAT({\cf18 void})\par
00105 \{\par
00106     uint8_t date, month, year;\par
00107     uint8_t hours, minutes, seconds;\par
00108     uint8_t error;\par
00109 \par
00110     error = rtc_get_date(&date, &month, &year);\par
00111     {\cf19 if}(error) {\cf19 return} 1;\par
00112     \par
00113     error = rtc_get_time(&hours, &minutes, &seconds);\par
00114     {\cf19 if}(error) {\cf19 return} 1;\par
00115 \par
00116     {\cf20 // Calculate year for FAT (years since 1980)}\par
00117     {\cf18 unsigned} {\cf18 int} yr = year + 2000 - 1980;\par
00118     dateFAT = yr;\par
00119 \par
00120     {\cf20 // Add month}\par
00121     dateFAT = (dateFAT << 4) | month;\par
00122 \par
00123     {\cf20 // Add date}\par
00124     dateFAT = (dateFAT << 5) | date;\par
00125 \par
00126     {\cf20 // Add hours}\par
00127     timeFAT = hours;\par
00128 \par
00129     {\cf20 // Add minutes}\par
00130     timeFAT = (timeFAT << 6) | minutes;\par
00131 \par
00132     {\cf20 // Add seconds (FAT32 uses 2-second resolution)}\par
00133     timeFAT = (timeFAT << 5) | (seconds / 2);\par
00134 \par
00135     {\cf19 return} 0;\par
00136 \}\par
00137 {\cf20 // \{}\par
00138   \par
00139 {\cf20 //    unsigned char mth, dt, hr, min, sec, error; }\par
00140 {\cf20 //    unsigned int yr;}\par
00141 \par
00142 {\cf20 //    error = RTC_read();}\par
00143 {\cf20 //    if(error) return 1;}\par
00144 \par
00145 {\cf20 //    yr = (YEAR & 0xf0) >> 4;}\par
00146 {\cf20 //    yr = (yr * 10)+(YEAR & 0x0f);}\par
00147 {\cf20 //    yr = yr+2000;}\par
00148 {\cf20 //    yr = yr - 1980;}\par
00149 \par
00150 {\cf20 //    dateFAT = yr;}\par
00151 \par
00152 {\cf20 //    mth = (MONTH & 0xf0) >> 4;}\par
00153 {\cf20 //    mth = (mth * 10)+(MONTH & 0x0f);}\par
00154 \par
00155 {\cf20 //    dateFAT = (dateFAT << 4) | mth;}\par
00156 \par
00157 {\cf20 //    dt = (DATE & 0xf0) >> 4;}\par
00158 {\cf20 //    dt = (dt * 10)+(DATE & 0x0f);}\par
00159 \par
00160 {\cf20 //    dateFAT = (dateFAT << 5) | dt;}\par
00161 \par
00162 \par
00163 {\cf20 //    hr = (HOURS & 0xf0) >> 4;}\par
00164 {\cf20 //    hr = (hr * 10)+(HOURS & 0x0f);}\par
00165 \par
00166 {\cf20 //    timeFAT = hr;}\par
00167 \par
00168 {\cf20 //    min = (MINUTES & 0xf0) >> 4;}\par
00169 {\cf20 //    min = (min * 10)+(MINUTES & 0x0f);}\par
00170 \par
00171 {\cf20 //    timeFAT = (timeFAT << 6) | min;}\par
00172 \par
00173 {\cf20 //    sec = (SECONDS & 0xf0) >> 4;}\par
00174 {\cf20 //    sec = (sec * 10)+(SECONDS & 0x0f);}\par
00175 {\cf20 //    sec = sec / 2;    //FAT32 fromat accepts dates with 2sec resolution (e.g. value 5 => 10sec)}\par
00176 \par
00177 {\cf20 //    timeFAT = (timeFAT << 5) | sec;}\par
00178 \par
00179    \par
00180 {\cf20 //    return 0;}\par
00181 {\cf20 // \}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/rtc/rtc.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/rtc/rtc.h}
{\xe \v lib/rtc/rtc.h}
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_ADDRESS}\~ 0x68\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_SEC}\~ 0x00  /* Seconds (and CH bit) */\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_MIN}\~ 0x01  /* Minutes */\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_HOUR}\~ 0x02  /* Hours (12/24 bit) */\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_DAY}\~ 0x03  /* Day of week */\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_DATE}\~ 0x04  /* Date (day of month) */\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_MONTH}\~ 0x05  /* Month */\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_YEAR}\~ 0x06  /* Year (00..99) */\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTC_CONTROL}\~ 0x07  /* Control register (square-wave output) */\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SECONDS}\~ {\b rtc_register}[0]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MINUTES}\~ {\b rtc_register}[1]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HOURS}\~ {\b rtc_register}[2]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DAY}\~ {\b rtc_register}[3]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DATE}\~ {\b rtc_register}[4]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MONTH}\~ {\b rtc_register}[5]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b YEAR}\~ {\b rtc_register}[6]\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rtc_setup} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rtc_read_reg} (uint8_t reg_addr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rtc_write_reg} (uint8_t reg_addr, uint8_t {\b data})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rtc_set_time} (uint8_t hours, uint8_t minutes, uint8_t seconds)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rtc_get_time} (uint8_t *hours, uint8_t *minutes, uint8_t *seconds)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rtc_set_date} (uint8_t day, uint8_t date, uint8_t month, uint8_t year)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rtc_get_date} (uint8_t *date, uint8_t *month, uint8_t *year)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rtc_get_day} (uint8_t *day)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b getDateTime_FAT} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b rtc_register} [7]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b dateFAT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b timeFAT}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DATE\:rtc.h}
{\xe \v rtc.h\:DATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DATE\~ {\b rtc_register}[4]}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b rtc.h}.}\par
}
{\xe \v DAY\:rtc.h}
{\xe \v rtc.h\:DAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DAY\~ {\b rtc_register}[3]}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b rtc.h}.}\par
}
{\xe \v HOURS\:rtc.h}
{\xe \v rtc.h\:HOURS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HOURS\~ {\b rtc_register}[2]}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b rtc.h}.}\par
}
{\xe \v MINUTES\:rtc.h}
{\xe \v rtc.h\:MINUTES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MINUTES\~ {\b rtc_register}[1]}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b rtc.h}.}\par
}
{\xe \v MONTH\:rtc.h}
{\xe \v rtc.h\:MONTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MONTH\~ {\b rtc_register}[5]}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b rtc.h}.}\par
}
{\xe \v RTC_ADDRESS\:rtc.h}
{\xe \v rtc.h\:RTC_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_ADDRESS\~ 0x68}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b rtc.h}.}\par
}
{\xe \v RTC_CONTROL\:rtc.h}
{\xe \v rtc.h\:RTC_CONTROL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_CONTROL\~ 0x07  /* Control register (square-wave output) */}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b rtc.h}.}\par
}
{\xe \v RTC_DATE\:rtc.h}
{\xe \v rtc.h\:RTC_DATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_DATE\~ 0x04  /* Date (day of month) */}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b rtc.h}.}\par
}
{\xe \v RTC_DAY\:rtc.h}
{\xe \v rtc.h\:RTC_DAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_DAY\~ 0x03  /* Day of week */}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b rtc.h}.}\par
}
{\xe \v RTC_HOUR\:rtc.h}
{\xe \v rtc.h\:RTC_HOUR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_HOUR\~ 0x02  /* Hours (12/24 bit) */}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b rtc.h}.}\par
}
{\xe \v RTC_MIN\:rtc.h}
{\xe \v rtc.h\:RTC_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_MIN\~ 0x01  /* Minutes */}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b rtc.h}.}\par
}
{\xe \v RTC_MONTH\:rtc.h}
{\xe \v rtc.h\:RTC_MONTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_MONTH\~ 0x05  /* Month */}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b rtc.h}.}\par
}
{\xe \v RTC_SEC\:rtc.h}
{\xe \v rtc.h\:RTC_SEC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_SEC\~ 0x00  /* Seconds (and CH bit) */}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b rtc.h}.}\par
}
{\xe \v RTC_YEAR\:rtc.h}
{\xe \v rtc.h\:RTC_YEAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTC_YEAR\~ 0x06  /* Year (00..99) */}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b rtc.h}.}\par
}
{\xe \v SECONDS\:rtc.h}
{\xe \v rtc.h\:SECONDS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SECONDS\~ {\b rtc_register}[0]}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b rtc.h}.}\par
}
{\xe \v YEAR\:rtc.h}
{\xe \v rtc.h\:YEAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define YEAR\~ {\b rtc_register}[6]}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b rtc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v getDateTime_FAT\:rtc.h}
{\xe \v rtc.h\:getDateTime_FAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char getDateTime_FAT (void )}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b rtc.c}.}\par
}
{\xe \v rtc_get_date\:rtc.h}
{\xe \v rtc.h\:rtc_get_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rtc_get_date (uint8_t * date, uint8_t * month, uint8_t * year)}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b rtc.c}.}\par
}
{\xe \v rtc_get_day\:rtc.h}
{\xe \v rtc.h\:rtc_get_day}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rtc_get_day (uint8_t * day)}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b rtc.c}.}\par
}
{\xe \v rtc_get_time\:rtc.h}
{\xe \v rtc.h\:rtc_get_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rtc_get_time (uint8_t * hours, uint8_t * minutes, uint8_t * seconds)}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b rtc.c}.}\par
}
{\xe \v rtc_read_reg\:rtc.h}
{\xe \v rtc.h\:rtc_read_reg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rtc_read_reg (uint8_t reg_addr)}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b rtc.c}.}\par
}
{\xe \v rtc_set_date\:rtc.h}
{\xe \v rtc.h\:rtc_set_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rtc_set_date (uint8_t day, uint8_t date, uint8_t month, uint8_t year)}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b rtc.c}.}\par
}
{\xe \v rtc_set_time\:rtc.h}
{\xe \v rtc.h\:rtc_set_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rtc_set_time (uint8_t hours, uint8_t minutes, uint8_t seconds)}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b rtc.c}.}\par
}
{\xe \v rtc_setup\:rtc.h}
{\xe \v rtc.h\:rtc_setup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rtc_setup (void )}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b rtc.c}.}\par
}
{\xe \v rtc_write_reg\:rtc.h}
{\xe \v rtc.h\:rtc_write_reg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rtc_write_reg (uint8_t reg_addr, uint8_t data)}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b rtc.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v dateFAT\:rtc.h}
{\xe \v rtc.h\:dateFAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int dateFAT}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b rtc.h}.}\par
}
{\xe \v rtc_register\:rtc.h}
{\xe \v rtc.h\:rtc_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char rtc_register[7]}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b rtc.h}.}\par
}
{\xe \v timeFAT\:rtc.h}
{\xe \v rtc.h\:timeFAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int timeFAT}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b rtc.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
rtc.h\par \pard\plain 
{\tc\tcl2 \v lib/rtc/rtc.h}
{\xe \v lib/rtc/rtc.h}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef RTC_H}\par
00002 {\cf21     #define RTC_H}\par
00003 {\cf21 #endif  }\par
00004 {\cf20 // #include <avr/io.h>}\par
00005 {\cf21 #include <stdint.h>}\par
00006 \par
00007 {\cf20 /* I2C address of DS1307 RTC */}\par
00008 {\cf21 #define RTC_ADDRESS 0x68}\par
00009 \par
00010 {\cf20 /* RTC register addresses (DS1307) */}\par
00011 {\cf21 #define RTC_SEC     0x00  }{\cf20 /* Seconds (and CH bit) */}{\cf21 }\par
00012 {\cf21 #define RTC_MIN     0x01  }{\cf20 /* Minutes */}{\cf21 }\par
00013 {\cf21 #define RTC_HOUR    0x02  }{\cf20 /* Hours (12/24 bit) */}{\cf21 }\par
00014 {\cf21 #define RTC_DAY     0x03  }{\cf20 /* Day of week */}{\cf21 }\par
00015 {\cf21 #define RTC_DATE    0x04  }{\cf20 /* Date (day of month) */}{\cf21 }\par
00016 {\cf21 #define RTC_MONTH   0x05  }{\cf20 /* Month */}{\cf21 }\par
00017 {\cf21 #define RTC_YEAR    0x06  }{\cf20 /* Year (00..99) */}{\cf21 }\par
00018 {\cf21 #define RTC_CONTROL 0x07  }{\cf20 /* Control register (square-wave output) */}{\cf21 }\par
00019 \par
00020 \par
00021 {\cf21 #define     SECONDS         rtc_register[0]}\par
00022 {\cf21 #define     MINUTES         rtc_register[1]}\par
00023 {\cf21 #define     HOURS           rtc_register[2]}\par
00024 {\cf21 #define     DAY             rtc_register[3]}\par
00025 {\cf21 #define     DATE            rtc_register[4]}\par
00026 {\cf21 #define     MONTH           rtc_register[5]}\par
00027 {\cf21 #define     YEAR            rtc_register[6]}\par
00028 \par
00029 {\cf18 unsigned} {\cf18 char} rtc_register[7];\par
00030 {\cf18 unsigned} {\cf18 int} dateFAT, timeFAT;\par
00031 \par
00032 {\cf20 /*}\par
00033 {\cf20  * rtc_setup}\par
00034 {\cf20  *  - Initialize RTC device state: start oscillator (clear CH bit),}\par
00035 {\cf20  *    select 24-hour mode (clear 12/24 bit) and clear control register.}\par
00036 {\cf20  *  - No parameters, returns void.}\par
00037 {\cf20  */}\par
00038 {\cf18 void} rtc_setup({\cf18 void});\par
00039 \par
00040 {\cf20 /*}\par
00041 {\cf20  * rtc_read_reg}\par
00042 {\cf20  *  - Read single RTC register over I2C.}\par
00043 {\cf20  *  - reg_addr : register address (use RTC_* macros)}\par
00044 {\cf20  *  - returns  : byte read from device}\par
00045 {\cf20  */}\par
00046 uint8_t rtc_read_reg(uint8_t reg_addr);\par
00047 \par
00048 \par
00049 {\cf20 /*}\par
00050 {\cf20  * rtc_write_reg}\par
00051 {\cf20  *  - Write single RTC register over I2C.}\par
00052 {\cf20  *  - reg_addr : register address (use RTC_* macros)}\par
00053 {\cf20  *  - data     : byte to write}\par
00054 {\cf20  *  - returns  : result code from underlying TWI write (0 = success typically)}\par
00055 {\cf20  */}\par
00056 uint8_t rtc_write_reg(uint8_t reg_addr, uint8_t data);\par
00057 \par
00058 {\cf20 /*}\par
00059 {\cf20  * rtc_set_time}\par
00060 {\cf20  *  - Set RTC time (hours, minutes, seconds) in decimal (0..23, 0..59, 0..59).}\par
00061 {\cf20  *  - Values are converted to BCD before writing.}\par
00062 {\cf20  *  - returns  : 0 on success (function currently always returns 0)}\par
00063 {\cf20  */}\par
00064 uint8_t rtc_set_time(uint8_t hours, uint8_t minutes, uint8_t seconds);\par
00065 \par
00066 {\cf20 /*}\par
00067 {\cf20  * rtc_get_time}\par
00068 {\cf20  *  - Read current time from RTC and convert BCD -> decimal.}\par
00069 {\cf20  *  - hours, minutes, seconds : pointers to store values (non-NULL)}\par
00070 {\cf20  *  - returns : 0 on success}\par
00071 {\cf20  */}\par
00072 uint8_t rtc_get_time(uint8_t *hours, uint8_t *minutes, uint8_t *seconds);\par
00073 \par
00074 {\cf20 /*}\par
00075 {\cf20  * rtc_set_date}\par
00076 {\cf20  *  - Set RTC calendar date (day-of-week, date, month, year) in decimal.}\par
00077 {\cf20  *  - day   : 1..7 (day of week), date: 1..31, month: 1..12, year: 0..99}\par
00078 {\cf20  *  - Values are converted to BCD before writing.}\par
00079 {\cf20  *  - returns : 0 on success}\par
00080 {\cf20  */}\par
00081 uint8_t rtc_set_date(uint8_t day, uint8_t date, uint8_t month, uint8_t year);\par
00082 \par
00083 uint8_t rtc_get_date(uint8_t *date, uint8_t *month, uint8_t *year);\par
00084 uint8_t rtc_get_day(uint8_t *day);\par
00085 \par
00086 {\cf18 unsigned} {\cf18 char} getDateTime_FAT({\cf18 void});\par
00087 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/sd/SD_routines.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/sd/SD_routines.c}
{\xe \v lib/sd/SD_routines.c}
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <avr/io.h>}\par
{\f2 #include <avr/pgmspace.h>}\par
{\f2 #include "SPI_routines.h"}\par
{\f2 #include "sd_routines.h"}\par
{\f2 #include <uart.h>}\par
{\f2 #include <util/delay.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SD_init} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SD_sendCommand} (unsigned char cmd, unsigned long arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SD_erase} (unsigned long {\b startBlock}, unsigned long {\b totalBlocks})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SD_readSingleBlock} (unsigned long {\b startBlock})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SD_writeSingleBlock} (unsigned long {\b startBlock})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned char {\b SDHC_flag} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned char {\b cardType} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned char {\b buffer} [512]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v SD_erase\:SD_routines.c}
{\xe \v SD_routines.c\:SD_erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SD_erase (unsigned long startBlock, unsigned long totalBlocks)}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 191} of file {\b SD_routines.c}.}\par
}
{\xe \v SD_init\:SD_routines.c}
{\xe \v SD_routines.c\:SD_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SD_init (void )}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b SD_routines.c}.}\par
}
{\xe \v SD_readSingleBlock\:SD_routines.c}
{\xe \v SD_routines.c\:SD_readSingleBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SD_readSingleBlock (unsigned long startBlock)}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 216} of file {\b SD_routines.c}.}\par
}
{\xe \v SD_sendCommand\:SD_routines.c}
{\xe \v SD_routines.c\:SD_sendCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SD_sendCommand (unsigned char cmd, unsigned long arg)}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b SD_routines.c}.}\par
}
{\xe \v SD_writeSingleBlock\:SD_routines.c}
{\xe \v SD_routines.c\:SD_writeSingleBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SD_writeSingleBlock (unsigned long startBlock)}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 251} of file {\b SD_routines.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v buffer\:SD_routines.c}
{\xe \v SD_routines.c\:buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned char buffer[512]}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b SD_routines.c}.}\par
}
{\xe \v cardType\:SD_routines.c}
{\xe \v SD_routines.c\:cardType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned char cardType = 0}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b SD_routines.c}.}\par
}
{\xe \v SDHC_flag\:SD_routines.c}
{\xe \v SD_routines.c\:SDHC_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned char SDHC_flag = 0}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b SD_routines.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SD_routines.c\par \pard\plain 
{\tc\tcl2 \v lib/sd/SD_routines.c}
{\xe \v lib/sd/SD_routines.c}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //**************************************************************}\par
00002 {\cf20 // ****** FUNCTIONS FOR SD RAW DATA TRANSFER *******}\par
00003 {\cf20 //**************************************************************}\par
00004 {\cf20 //Controller        : ATmega32 (Clock: 8 Mhz-internal)}\par
00005 {\cf20 //Compiler          : AVR-GCC (winAVR with AVRStudio-4)}\par
00006 {\cf20 //Project Version   : DL_1.0}\par
00007 {\cf20 //Author            : CC Dharmani, Chennai (India)}\par
00008 {\cf20 //                    www.dharmanitech.com}\par
00009 {\cf20 //Date              : 10 May 2011}\par
00010 {\cf20 //**************************************************************}\par
00011 \par
00012 {\cf20 //Link to the Post: http://www.dharmanitech.com/2009/01/sd-card-interfacing-with-atmega8-fat32.html}\par
00013 \par
00014 {\cf21 #include <avr/io.h>}\par
00015 {\cf21 #include <avr/pgmspace.h>}\par
00016 {\cf21 #include "SPI_routines.h"}\par
00017 {\cf21 #include "sd_routines.h"}\par
00018 {\cf21 #include <uart.h>}\par
00019 {\cf21 #include <util/delay.h>}\par
00020 \par
00021 {\cf20 // Global variables}\par
00022 {\cf17 volatile} {\cf18 unsigned} {\cf18 char} SDHC_flag = 0;\par
00023 {\cf17 volatile} {\cf18 unsigned} {\cf18 char} cardType = 0;\par
00024 {\cf17 volatile} {\cf18 unsigned} {\cf18 char} buffer[512];\par
00025 \par
00026 {\cf20 //******************************************************************}\par
00027 {\cf20 //Function  : to initialize the SD/SDHC card in SPI mode}\par
00028 {\cf20 //Arguments : none}\par
00029 {\cf20 //return    : unsigned char; will be 0 if no error,}\par
00030 {\cf20 //            otherwise the response byte will be sent}\par
00031 {\cf20 //******************************************************************}\par
00032 {\cf18 unsigned} {\cf18 char} SD_init({\cf18 void})\par
00033 \{\par
00034 {\cf18 unsigned} {\cf18 char} i, response, SD_version;\par
00035 {\cf18 unsigned} {\cf18 int} retry=0 ;\par
00036 \par
00037  {\cf19 for}(i=0;i<10;i++)\par
00038     SPI_transmit(0xff);\par
00039 \par
00040 SD_CS_ASSERT;\par
00041 {\cf19 do}\par
00042 \{\par
00043   \par
00044    response = SD_sendCommand(GO_IDLE_STATE, 0); {\cf20 //send 'reset & go idle' command}\par
00045    retry++;\par
00046    {\cf19 if}(retry>0xFF) \par
00047    \{\par
00048       uart_puts({\cf22 "SD_CS_DEASSERT\\r\\n"});\par
00049       SD_CS_DEASSERT;\par
00050       {\cf19 return} 1;\par
00051    \}\par
00052    \par
00053 \} {\cf19 while}(response != 0x01);\par
00054 \par
00055 SD_CS_DEASSERT;\par
00056 SPI_transmit (0xff);\par
00057 SPI_transmit (0xff);\par
00058 \par
00059 retry = 0;\par
00060 \par
00061 SD_version = 2; {\cf20 //default set to SD compliance with ver2.x; }\par
00062                 {\cf20 //this may change after checking the next command}\par
00063 {\cf19 do}\par
00064 \{\par
00065 response = SD_sendCommand(SEND_IF_COND,0x000001AA); {\cf20 //Check power supply status, mendatory for SDHC card}\par
00066 retry++;\par
00067 {\cf19 if}(retry>0xfe) \par
00068    \{\par
00069       SD_version = 1;\par
00070       cardType = 1;\par
00071       {\cf19 break};\par
00072    \} {\cf20 //time out}\par
00073 \par
00074 \}{\cf19 while}(response != 0x01);\par
00075 \par
00076 retry = 0;\par
00077 \par
00078 {\cf19 do}\par
00079 \{\par
00080 response = SD_sendCommand(APP_CMD,0); {\cf20 //CMD55, must be sent before sending any ACMD command}\par
00081 response = SD_sendCommand(SD_SEND_OP_COND,0x40000000); {\cf20 //ACMD41}\par
00082 \par
00083 retry++;\par
00084 {\cf19 if}(retry>0xfe) \par
00085    \{\par
00086       uart_puts({\cf22 "SD_SEND_OP_COND timeout\\r\\n"});\par
00087       {\cf19 return} 1;\par
00088    \} \par
00089 \par
00090 \}{\cf19 while}(response != 0x00);\par
00091 \par
00092 \par
00093 retry = 0;\par
00094 SDHC_flag = 0;\par
00095 \par
00096 {\cf19 if} (SD_version == 2)\par
00097 \{ \par
00098    {\cf19 do}\par
00099    \{\par
00100       response = SD_sendCommand(READ_OCR,0);\par
00101       retry++;\par
00102       {\cf19 if}(retry>0xfe) \par
00103       \{\par
00104          cardType = 0;\par
00105          {\cf19 break};\par
00106       \}\par
00107 \par
00108    \}{\cf19 while}(response != 0x00);\par
00109 \par
00110    {\cf19 if}(SDHC_flag == 1) cardType = 2;\par
00111    {\cf19 else} cardType = 3;\par
00112 \}\par
00113 \par
00114 {\cf20 //SD_sendCommand(CRC_ON_OFF, OFF); //disable CRC; deafault - CRC disabled in SPI mode}\par
00115 {\cf20 //SD_sendCommand(SET_BLOCK_LEN, 512); //set block size to 512; default size is 512}\par
00116 \par
00117 SPI_HIGH_SPEED;\par
00118 \par
00119 {\cf19 return} 0; {\cf20 //successful return}\par
00120 \}\par
00121 \par
00122 {\cf20 //******************************************************************}\par
00123 {\cf20 //Function  : to send a command to SD card}\par
00124 {\cf20 //Arguments : unsigned char (8-bit command value)}\par
00125 {\cf20 //            & unsigned long (32-bit command argument)}\par
00126 {\cf20 //return    : unsigned char; response byte}\par
00127 {\cf20 //******************************************************************}\par
00128 {\cf18 unsigned} {\cf18 char} SD_sendCommand({\cf18 unsigned} {\cf18 char} cmd, {\cf18 unsigned} {\cf18 long} arg)\par
00129 \{\par
00130    \par
00131 {\cf18 unsigned} {\cf18 char} response, retry=0, status;\par
00132 {\cf20 // uart_puts_P("In SD_sendCommand\\r\\n");}\par
00133 {\cf20 //SD card accepts byte address while SDHC accepts block address in multiples of 512}\par
00134 {\cf20 //so, if it's SD card we need to convert block address into corresponding byte address by }\par
00135 {\cf20 //multipying it with 512. which is equivalent to shifting it left 9 times}\par
00136 {\cf20 //following 'if' loop does that}\par
00137 \par
00138 {\cf19 if}(SDHC_flag == 0)  \par
00139 \{\par
00140    uart_puts_P({\cf22 "SDHC_flag == 0\\r\\n"});   \par
00141 {\cf19 if}(cmd == READ_SINGLE_BLOCK     ||\par
00142    cmd == READ_MULTIPLE_BLOCKS  ||\par
00143    cmd == WRITE_SINGLE_BLOCK    ||\par
00144    cmd == WRITE_MULTIPLE_BLOCKS ||\par
00145    cmd == ERASE_BLOCK_START_ADDR|| \par
00146    cmd == ERASE_BLOCK_END_ADDR ) \par
00147    \{\par
00148       arg = arg << 9;\par
00149    \}       \par
00150 \}\par
00151 SD_CS_ASSERT;\par
00152 uart_puts_P({\cf22 "After SD_CS_ASSERT\\r\\n"});\par
00153 _delay_ms(1); {\cf20 //small delay before sending command}\par
00154 SPI_transmit(cmd | 0x40); {\cf20 //send command, first two bits always '01'}\par
00155 SPI_transmit(arg>>24);\par
00156 SPI_transmit(arg>>16);\par
00157 SPI_transmit(arg>>8);\par
00158 SPI_transmit(arg);\par
00159 {\cf20 // uart_puts_P("CMDs\\r\\n");}\par
00160 {\cf19 if}(cmd == SEND_IF_COND)  {\cf20 //it is compulsory to send correct CRC for CMD8 (CRC=0x87) & CMD0 (CRC=0x95)}\par
00161   SPI_transmit(0x87);    {\cf20 //for remaining commands, CRC is ignored in SPI mode}\par
00162 {\cf19 else} \par
00163   SPI_transmit(0x95); \par
00164 \par
00165 {\cf19 while}((response = SPI_receive()) == 0xff) {\cf20 //wait response}\par
00166    {\cf19 if}(retry++ > 0xfe) {\cf19 break}; {\cf20 //time out error}\par
00167 \par
00168 {\cf19 if}(response == 0x00 && cmd == 58)  {\cf20 //checking response of CMD58}\par
00169 \{\par
00170   status = SPI_receive() & 0x40;     {\cf20 //first byte of the OCR register (bit 31:24)}\par
00171   {\cf19 if}(status == 0x40) SDHC_flag = 1;  {\cf20 //we need it to verify SDHC card}\par
00172   {\cf19 else} SDHC_flag = 0;\par
00173 \par
00174   SPI_receive(); {\cf20 //remaining 3 bytes of the OCR register are ignored here}\par
00175   SPI_receive(); {\cf20 //one can use these bytes to check power supply limits of SD}\par
00176   SPI_receive(); \par
00177 \}\par
00178 \par
00179 SPI_receive(); {\cf20 //extra 8 CLK}\par
00180 SD_CS_DEASSERT;\par
00181 \par
00182 {\cf19 return} response; {\cf20 //return state}\par
00183 \}\par
00184 \par
00185 {\cf20 //*****************************************************************}\par
00186 {\cf20 //Function  : to erase specified no. of blocks of SD card}\par
00187 {\cf20 //Arguments : none}\par
00188 {\cf20 //return    : unsigned char; will be 0 if no error,}\par
00189 {\cf20 //            otherwise the response byte will be sent}\par
00190 {\cf20 //*****************************************************************}\par
00191 {\cf18 unsigned} {\cf18 char} SD_erase ({\cf18 unsigned} {\cf18 long} startBlock, {\cf18 unsigned} {\cf18 long} totalBlocks)\par
00192 \{\par
00193 {\cf18 unsigned} {\cf18 char} response;\par
00194 \par
00195 response = SD_sendCommand(ERASE_BLOCK_START_ADDR, startBlock); {\cf20 //send starting block address}\par
00196 {\cf19 if}(response != 0x00) {\cf20 //check for SD status: 0x00 - OK (No flags set)}\par
00197   {\cf19 return} response;\par
00198 \par
00199 response = SD_sendCommand(ERASE_BLOCK_END_ADDR,(startBlock + totalBlocks - 1)); {\cf20 //send end block address}\par
00200 {\cf19 if}(response != 0x00)\par
00201   {\cf19 return} response;\par
00202 \par
00203 response = SD_sendCommand(ERASE_SELECTED_BLOCKS, 0); {\cf20 //erase all selected blocks}\par
00204 {\cf19 if}(response != 0x00)\par
00205   {\cf19 return} response;\par
00206 \par
00207 {\cf19 return} 0; {\cf20 //normal return}\par
00208 \}\par
00209 \par
00210 {\cf20 //******************************************************************}\par
00211 {\cf20 //Function  : to read a single block from SD card}\par
00212 {\cf20 //Arguments : none}\par
00213 {\cf20 //return    : unsigned char; will be 0 if no error,}\par
00214 {\cf20 //            otherwise the response byte will be sent}\par
00215 {\cf20 //******************************************************************}\par
00216 {\cf18 unsigned} {\cf18 char} SD_readSingleBlock({\cf18 unsigned} {\cf18 long} startBlock)\par
00217 \{\par
00218    uart_puts_P({\cf22 "In SD_readSingleBlock\\r\\n"});\par
00219    {\cf20 // uart_pu}\par
00220 {\cf18 unsigned} {\cf18 char} response;\par
00221 {\cf18 unsigned} {\cf18 int} i, retry=0;\par
00222 uart_puts_P({\cf22 "re1\\r\\n"});\par
00223  response = SD_sendCommand(READ_SINGLE_BLOCK, startBlock); {\cf20 //read a Block command}\par
00224  uart_puts_P({\cf22 "re2\\r\\n"});\par
00225  {\cf19 if}(response != 0x00) {\cf19 return} response; {\cf20 //check for SD status: 0x00 - OK (No flags set)}\par
00226 \par
00227 SD_CS_ASSERT;\par
00228 _delay_ms(1); {\cf20 //small delay before reading data}\par
00229 retry = 0;\par
00230 {\cf19 while}(SPI_receive() != 0xfe) {\cf20 //wait for start block token 0xfe (0x11111110)}\par
00231   {\cf19 if}(retry++ > 0xfffe)\{SD_CS_DEASSERT; {\cf19 return} 1;\} {\cf20 //return if time-out}\par
00232 \par
00233 {\cf19 for}(i=0; i<512; i++) {\cf20 //read 512 bytes}\par
00234   buffer[i] = SPI_receive();\par
00235 \par
00236 SPI_receive(); {\cf20 //receive incoming CRC (16-bit), CRC is ignored here}\par
00237 SPI_receive();\par
00238 \par
00239 SPI_receive(); {\cf20 //extra 8 clock pulses}\par
00240 SD_CS_DEASSERT;\par
00241 \par
00242 {\cf19 return} 0;\par
00243 \}\par
00244 \par
00245 {\cf20 //******************************************************************}\par
00246 {\cf20 //Function  : to write to a single block of SD card}\par
00247 {\cf20 //Arguments : none}\par
00248 {\cf20 //return    : unsigned char; will be 0 if no error,}\par
00249 {\cf20 //            otherwise the response byte will be sent}\par
00250 {\cf20 //******************************************************************}\par
00251 {\cf18 unsigned} {\cf18 char} SD_writeSingleBlock({\cf18 unsigned} {\cf18 long} startBlock)\par
00252 \{\par
00253 {\cf18 unsigned} {\cf18 char} response;\par
00254 {\cf18 unsigned} {\cf18 int} i, retry=0;\par
00255 \par
00256  response = SD_sendCommand(WRITE_SINGLE_BLOCK, startBlock); {\cf20 //write a Block command}\par
00257   \par
00258  {\cf19 if}(response != 0x00) {\cf19 return} response; {\cf20 //check for SD status: 0x00 - OK (No flags set)}\par
00259 \par
00260 SD_CS_ASSERT;\par
00261 \par
00262 SPI_transmit(0xfe);     {\cf20 //Send start block token 0xfe (0x11111110)}\par
00263 \par
00264 {\cf19 for}(i=0; i<512; i++)    {\cf20 //send 512 bytes data}\par
00265   SPI_transmit(buffer[i]);\par
00266 \par
00267 SPI_transmit(0xff);     {\cf20 //transmit dummy CRC (16-bit), CRC is ignored here}\par
00268 SPI_transmit(0xff);\par
00269 \par
00270 response = SPI_receive();\par
00271 \par
00272 {\cf19 if}( (response & 0x1f) != 0x05) {\cf20 //response= 0xXXX0AAA1 ; AAA='010' - data accepted}\par
00273 \{                              {\cf20 //AAA='101'-data rejected due to CRC error}\par
00274   SD_CS_DEASSERT;              {\cf20 //AAA='110'-data rejected due to write error}\par
00275   {\cf19 return} response;\par
00276 \}\par
00277 \par
00278 {\cf19 while}(!SPI_receive()) {\cf20 //wait for SD card to complete writing and get idle}\par
00279 {\cf19 if}(retry++ > 0xfffe)\{SD_CS_DEASSERT; {\cf19 return} 1;\}\par
00280 \par
00281 SD_CS_DEASSERT;\par
00282 SPI_transmit(0xff);   {\cf20 //just spend 8 clock cycle delay before reasserting the CS line}\par
00283 SD_CS_ASSERT;         {\cf20 //re-asserting the CS line to verify if card is still busy}\par
00284 \par
00285 {\cf19 while}(!SPI_receive()) {\cf20 //wait for SD card to complete writing and get idle}\par
00286    {\cf19 if}(retry++ > 0xfffe)\{SD_CS_DEASSERT; {\cf19 return} 1;\}\par
00287 SD_CS_DEASSERT;\par
00288 \par
00289 {\cf19 return} 0;\par
00290 \}\par
00291 \par
00292 \par
00293 {\cf21 #ifndef FAT_TESTING_ONLY}\par
00294 \par
00295 {\cf20 //***************************************************************************}\par
00296 {\cf20 //Function  : to read multiple blocks from SD card & send every block to UART}\par
00297 {\cf20 //Arguments : none}\par
00298 {\cf20 //return    : unsigned char; will be 0 if no error,}\par
00299 {\cf20 //            otherwise the response byte will be sent}\par
00300 {\cf20 //****************************************************************************}\par
00301 {\cf18 unsigned} {\cf18 char} SD_readMultipleBlock ({\cf18 unsigned} {\cf18 long} startBlock, {\cf18 unsigned} {\cf18 long} totalBlocks)\par
00302 \{\par
00303 {\cf18 unsigned} {\cf18 char} response;\par
00304 {\cf18 unsigned} {\cf18 int} i, retry=0;\par
00305 \par
00306 retry = 0;\par
00307 \par
00308 response = SD_sendCommand(READ_MULTIPLE_BLOCKS, startBlock); {\cf20 //write a Block command}\par
00309   \par
00310 {\cf19 if}(response != 0x00) {\cf19 return} response; {\cf20 //check for SD status: 0x00 - OK (No flags set)}\par
00311 \par
00312 SD_CS_ASSERT;\par
00313 \par
00314 {\cf19 while}( totalBlocks )\par
00315 \{\par
00316   retry = 0;\par
00317   {\cf19 while}(SPI_receive() != 0xfe) {\cf20 //wait for start block token 0xfe (0x11111110)}\par
00318   {\cf19 if}(retry++ > 0xfffe)\{SD_CS_DEASSERT; {\cf19 return} 1;\} {\cf20 //return if time-out}\par
00319 \par
00320   {\cf19 for}(i=0; i<512; i++) {\cf20 //read 512 bytes}\par
00321      buffer[i] = SPI_receive();\par
00322 \par
00323   SPI_receive(); {\cf20 //receive incoming CRC (16-bit), CRC is ignored here}\par
00324   SPI_receive();\par
00325 \par
00326   SPI_receive(); {\cf20 //extra 8 cycles}\par
00327   uart_puts({\cf22 "\\r\\n"});\par
00328   uart_puts({\cf22 " --------- "});\par
00329   uart_puts({\cf22 "\\r\\n"});\par
00330 \par
00331   {\cf19 for}(i=0; i<512; i++) {\cf20 //send the block to UART}\par
00332   \{\par
00333      uart_putc(buffer[i]);\par
00334   \}\par
00335 \par
00336   uart_puts({\cf22 "\\r\\n"});\par
00337   uart_puts({\cf22 " --------- "});\par
00338   uart_puts({\cf22 "\\r\\n"});\par
00339   totalBlocks--;\par
00340 \}\par
00341 \par
00342 SD_sendCommand(STOP_TRANSMISSION, 0); {\cf20 //command to stop transmission}\par
00343 SD_CS_DEASSERT;\par
00344 SPI_receive(); {\cf20 //extra 8 clock pulses}\par
00345 \par
00346 {\cf19 return} 0;\par
00347 \}\par
00348 \par
00349 {\cf20 //***************************************************************************}\par
00350 {\cf20 //Function: to receive data from UART and write to multiple blocks of SD card}\par
00351 {\cf20 //Arguments: none}\par
00352 {\cf20 //return: unsigned char; will be 0 if no error,}\par
00353 {\cf20 // otherwise the response byte will be sent}\par
00354 {\cf20 //****************************************************************************}\par
00355 {\cf18 unsigned} {\cf18 char} SD_writeMultipleBlock({\cf18 unsigned} {\cf18 long} startBlock, {\cf18 unsigned} {\cf18 long} totalBlocks)\par
00356 \{\par
00357 {\cf18 unsigned} {\cf18 char} response, data;\par
00358 {\cf18 unsigned} {\cf18 int} i, retry=0;\par
00359 {\cf18 unsigned} {\cf18 long} blockCounter=0;\par
00360 \par
00361 response = SD_sendCommand(WRITE_MULTIPLE_BLOCKS, startBlock); {\cf20 //write a Block command}\par
00362 \par
00363 {\cf19 if}(response != 0x00) {\cf19 return} response; {\cf20 //check for SD status: 0x00 - OK (No flags set)}\par
00364 \par
00365 SD_CS_ASSERT;\par
00366 \par
00367 uart_puts({\cf22 "\\r\\n"});\par
00368 uart_puts({\cf22 " Enter text (End with ~): "});\par
00369 uart_puts({\cf22 "\\r\\n"});\par
00370 \par
00371 {\cf19 while}( blockCounter < totalBlocks )\par
00372 \{\par
00373    i=0;\par
00374    {\cf19 do}\par
00375    \{\par
00376       data = uart_getc();\par
00377       buffer[i++] = data;\par
00378      {\cf19 if}(i == 512) {\cf19 break};\par
00379    \}{\cf19 while} (data != {\cf23 '~'});\par
00380 \par
00381    uart_puts({\cf22 "\\r\\n"});\par
00382    uart_puts({\cf22 " ---- "});\par
00383    uart_puts({\cf22 "\\r\\n"});\par
00384 \par
00385    SPI_transmit(0xfc); {\cf20 //Send start block token 0xfc (0x11111100)}\par
00386 \par
00387    {\cf19 for}(i=0; i<512; i++) {\cf20 //send 512 bytes data}\par
00388       SPI_transmit(buffer[i]);\par
00389 \par
00390    SPI_transmit(0xff); {\cf20 //transmit dummy CRC (16-bit), CRC is ignored here}\par
00391    SPI_transmit(0xff);\par
00392 \par
00393    response = SPI_receive();\par
00394    {\cf19 if}((response & 0x1f) != 0x05)\par
00395    \{\par
00396       SD_CS_DEASSERT;\par
00397       {\cf19 return} response;\par
00398    \}\par
00399 \par
00400    {\cf19 while}(!SPI_receive())\par
00401       {\cf19 if}(retry++ > 0xfffe)\{SD_CS_DEASSERT; {\cf19 return} 1;\}\par
00402 \par
00403    blockCounter++;\par
00404 \}\par
00405 \par
00406 SPI_transmit(0xfd); {\cf20 //send 'stop transmission token'}\par
00407 \par
00408 retry = 0;\par
00409 \par
00410 {\cf19 while}(!SPI_receive()) {\cf20 //wait for SD card to complete writing and get idle}\par
00411    {\cf19 if}(retry++ > 0xfffe)\{SD_CS_DEASSERT; {\cf19 return} 1;\}\par
00412 \par
00413 SD_CS_DEASSERT;\par
00414 SPI_transmit(0xff); {\cf20 //just spend 8 clock cycle delay before reasserting the CS signal}\par
00415 SD_CS_ASSERT; {\cf20 //re assertion of the CS signal is required to verify if card is still busy}\par
00416 \par
00417 {\cf19 while}(!SPI_receive()) {\cf20 //wait for SD card to complete writing and get idle}\par
00418    {\cf19 if}(retry++ > 0xfffe)\{SD_CS_DEASSERT; {\cf19 return} 1;\}\par
00419 SD_CS_DEASSERT;\par
00420 \par
00421 {\cf19 return} 0;\par
00422 \}\par
00423 {\cf20 //*********************************************}\par
00424 \par
00425 {\cf21 #endif}\par
00426 \par
00427 {\cf20 //******** END ****** www.dharmanitech.com *****}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/sd/sd_routines.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/sd/sd_routines.h}
{\xe \v lib/sd/sd_routines.h}
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAT_TESTING_ONLY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SD_CS_ASSERT}\~ PORTD &= ~0x10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SD_CS_DEASSERT}\~ PORTD |= 0x10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GO_IDLE_STATE}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEND_OP_COND}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEND_IF_COND}\~ 8\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEND_CSD}\~ 9\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STOP_TRANSMISSION}\~ 12\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEND_STATUS}\~ 13\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SET_BLOCK_LEN}\~ 16\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b READ_SINGLE_BLOCK}\~ 17\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b READ_MULTIPLE_BLOCKS}\~ 18\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WRITE_SINGLE_BLOCK}\~ 24\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WRITE_MULTIPLE_BLOCKS}\~ 25\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ERASE_BLOCK_START_ADDR}\~ 32\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ERASE_BLOCK_END_ADDR}\~ 33\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ERASE_SELECTED_BLOCKS}\~ 38\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SD_SEND_OP_COND}\~ 41\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b APP_CMD}\~ 55\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b READ_OCR}\~ 58\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CRC_ON_OFF}\~ 59\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ON}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OFF}\~ 0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SD_init} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SD_sendCommand} (unsigned char cmd, unsigned long arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SD_readSingleBlock} (unsigned long {\b startBlock})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SD_writeSingleBlock} (unsigned long {\b startBlock})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SD_readMultipleBlock} (unsigned long {\b startBlock}, unsigned long {\b totalBlocks})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SD_writeMultipleBlock} (unsigned long {\b startBlock}, unsigned long {\b totalBlocks})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SD_erase} (unsigned long {\b startBlock}, unsigned long {\b totalBlocks})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned long {\b startBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned long {\b totalBlocks}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned char {\b SDHC_flag}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned char {\b cardType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned char {\b buffer} [512]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v APP_CMD\:sd_routines.h}
{\xe \v sd_routines.h\:APP_CMD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define APP_CMD\~ 55}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b sd_routines.h}.}\par
}
{\xe \v CRC_ON_OFF\:sd_routines.h}
{\xe \v sd_routines.h\:CRC_ON_OFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CRC_ON_OFF\~ 59}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b sd_routines.h}.}\par
}
{\xe \v ERASE_BLOCK_END_ADDR\:sd_routines.h}
{\xe \v sd_routines.h\:ERASE_BLOCK_END_ADDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ERASE_BLOCK_END_ADDR\~ 33}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b sd_routines.h}.}\par
}
{\xe \v ERASE_BLOCK_START_ADDR\:sd_routines.h}
{\xe \v sd_routines.h\:ERASE_BLOCK_START_ADDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ERASE_BLOCK_START_ADDR\~ 32}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b sd_routines.h}.}\par
}
{\xe \v ERASE_SELECTED_BLOCKS\:sd_routines.h}
{\xe \v sd_routines.h\:ERASE_SELECTED_BLOCKS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ERASE_SELECTED_BLOCKS\~ 38}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b sd_routines.h}.}\par
}
{\xe \v FAT_TESTING_ONLY\:sd_routines.h}
{\xe \v sd_routines.h\:FAT_TESTING_ONLY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAT_TESTING_ONLY}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b sd_routines.h}.}\par
}
{\xe \v GO_IDLE_STATE\:sd_routines.h}
{\xe \v sd_routines.h\:GO_IDLE_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GO_IDLE_STATE\~ 0}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b sd_routines.h}.}\par
}
{\xe \v OFF\:sd_routines.h}
{\xe \v sd_routines.h\:OFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OFF\~ 0}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b sd_routines.h}.}\par
}
{\xe \v ON\:sd_routines.h}
{\xe \v sd_routines.h\:ON}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ON\~ 1}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b sd_routines.h}.}\par
}
{\xe \v READ_MULTIPLE_BLOCKS\:sd_routines.h}
{\xe \v sd_routines.h\:READ_MULTIPLE_BLOCKS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define READ_MULTIPLE_BLOCKS\~ 18}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b sd_routines.h}.}\par
}
{\xe \v READ_OCR\:sd_routines.h}
{\xe \v sd_routines.h\:READ_OCR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define READ_OCR\~ 58}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b sd_routines.h}.}\par
}
{\xe \v READ_SINGLE_BLOCK\:sd_routines.h}
{\xe \v sd_routines.h\:READ_SINGLE_BLOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define READ_SINGLE_BLOCK\~ 17}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b sd_routines.h}.}\par
}
{\xe \v SD_CS_ASSERT\:sd_routines.h}
{\xe \v sd_routines.h\:SD_CS_ASSERT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SD_CS_ASSERT\~ PORTD &= ~0x10}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b sd_routines.h}.}\par
}
{\xe \v SD_CS_DEASSERT\:sd_routines.h}
{\xe \v sd_routines.h\:SD_CS_DEASSERT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SD_CS_DEASSERT\~ PORTD |= 0x10}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b sd_routines.h}.}\par
}
{\xe \v SD_SEND_OP_COND\:sd_routines.h}
{\xe \v sd_routines.h\:SD_SEND_OP_COND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SD_SEND_OP_COND\~ 41}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b sd_routines.h}.}\par
}
{\xe \v SEND_CSD\:sd_routines.h}
{\xe \v sd_routines.h\:SEND_CSD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEND_CSD\~ 9}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b sd_routines.h}.}\par
}
{\xe \v SEND_IF_COND\:sd_routines.h}
{\xe \v sd_routines.h\:SEND_IF_COND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEND_IF_COND\~ 8}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b sd_routines.h}.}\par
}
{\xe \v SEND_OP_COND\:sd_routines.h}
{\xe \v sd_routines.h\:SEND_OP_COND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEND_OP_COND\~ 1}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b sd_routines.h}.}\par
}
{\xe \v SEND_STATUS\:sd_routines.h}
{\xe \v sd_routines.h\:SEND_STATUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEND_STATUS\~ 13}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b sd_routines.h}.}\par
}
{\xe \v SET_BLOCK_LEN\:sd_routines.h}
{\xe \v sd_routines.h\:SET_BLOCK_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SET_BLOCK_LEN\~ 16}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b sd_routines.h}.}\par
}
{\xe \v STOP_TRANSMISSION\:sd_routines.h}
{\xe \v sd_routines.h\:STOP_TRANSMISSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STOP_TRANSMISSION\~ 12}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b sd_routines.h}.}\par
}
{\xe \v WRITE_MULTIPLE_BLOCKS\:sd_routines.h}
{\xe \v sd_routines.h\:WRITE_MULTIPLE_BLOCKS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WRITE_MULTIPLE_BLOCKS\~ 25}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b sd_routines.h}.}\par
}
{\xe \v WRITE_SINGLE_BLOCK\:sd_routines.h}
{\xe \v sd_routines.h\:WRITE_SINGLE_BLOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WRITE_SINGLE_BLOCK\~ 24}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b sd_routines.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v SD_erase\:sd_routines.h}
{\xe \v sd_routines.h\:SD_erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SD_erase (unsigned long startBlock, unsigned long totalBlocks)}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 191} of file {\b SD_routines.c}.}\par
}
{\xe \v SD_init\:sd_routines.h}
{\xe \v sd_routines.h\:SD_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SD_init (void )}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b SD_routines.c}.}\par
}
{\xe \v SD_readMultipleBlock\:sd_routines.h}
{\xe \v sd_routines.h\:SD_readMultipleBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SD_readMultipleBlock (unsigned long startBlock, unsigned long totalBlocks)}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SD_readSingleBlock\:sd_routines.h}
{\xe \v sd_routines.h\:SD_readSingleBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SD_readSingleBlock (unsigned long startBlock)}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 216} of file {\b SD_routines.c}.}\par
}
{\xe \v SD_sendCommand\:sd_routines.h}
{\xe \v sd_routines.h\:SD_sendCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SD_sendCommand (unsigned char cmd, unsigned long arg)}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b SD_routines.c}.}\par
}
{\xe \v SD_writeMultipleBlock\:sd_routines.h}
{\xe \v sd_routines.h\:SD_writeMultipleBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SD_writeMultipleBlock (unsigned long startBlock, unsigned long totalBlocks)}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SD_writeSingleBlock\:sd_routines.h}
{\xe \v sd_routines.h\:SD_writeSingleBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SD_writeSingleBlock (unsigned long startBlock)}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 251} of file {\b SD_routines.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v buffer\:sd_routines.h}
{\xe \v sd_routines.h\:buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned char buffer[512]}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b sd_routines.h}.}\par
}
{\xe \v cardType\:sd_routines.h}
{\xe \v sd_routines.h\:cardType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned char cardType}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b sd_routines.h}.}\par
}
{\xe \v SDHC_flag\:sd_routines.h}
{\xe \v sd_routines.h\:SDHC_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned char SDHC_flag}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b sd_routines.h}.}\par
}
{\xe \v startBlock\:sd_routines.h}
{\xe \v sd_routines.h\:startBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned long startBlock}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b sd_routines.h}.}\par
}
{\xe \v totalBlocks\:sd_routines.h}
{\xe \v sd_routines.h\:totalBlocks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned long totalBlocks}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b sd_routines.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sd_routines.h\par \pard\plain 
{\tc\tcl2 \v lib/sd/sd_routines.h}
{\xe \v lib/sd/sd_routines.h}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //**************************************************************}\par
00002 {\cf20 // ****** FUNCTIONS FOR SD RAW DATA TRANSFER *******}\par
00003 {\cf20 //**************************************************************}\par
00004 {\cf20 //Controller        : ATmega32 (Clock: 8 Mhz-internal)}\par
00005 {\cf20 //Compiler          : AVR-GCC (winAVR with AVRStudio-4)}\par
00006 {\cf20 //Project Version   : DL_1.0}\par
00007 {\cf20 //Author            : CC Dharmani, Chennai (India)}\par
00008 {\cf20 //                    www.dharmanitech.com}\par
00009 {\cf20 //Date              : 10 May 2011}\par
00010 {\cf20 //**************************************************************}\par
00011 \par
00012 {\cf20 //Link to the Post: http://www.dharmanitech.com/2009/01/sd-card-interfacing-with-atmega8-fat32.html}\par
00013 \par
00014 {\cf21 #ifndef _SD_ROUTINES_H_}\par
00015 {\cf21 #define _SD_ROUTINES_H_}\par
00016 \par
00017 {\cf20 //Use following macro if you don't want to activate the multiple block access functions}\par
00018 {\cf20 //those functions are not required for FAT32}\par
00019 \par
00020 {\cf21 #define FAT_TESTING_ONLY}\par
00021 \par
00022 {\cf20 //use following macros if PB1 pin is used for Chip Select of SD}\par
00023 {\cf20 //#define SD_CS_ASSERT     PORTB &= ~0x02}\par
00024 {\cf20 //#define SD_CS_DEASSERT   PORTB |= 0x02}\par
00025 \par
00026 {\cf20 //use following macros if SS (PB4) pin is used for Chip Select of SD}\par
00027 {\cf20 // #define SD_CS_ASSERT     PORTB &= ~0x10}\par
00028 {\cf20 // #define SD_CS_DEASSERT   PORTB |= 0x10}\par
00029 {\cf20 //use following macros if SS (PD4) pin is used for Chip Select of SD (Arduino Ethernet Shield)}\par
00030 {\cf21 #define SD_CS_ASSERT    PORTD &= ~0x10}\par
00031 {\cf21 #define SD_CS_DEASSERT  PORTD |= 0x10}\par
00032 {\cf20 //SD commands, many of these are not used here}\par
00033 {\cf21 #define GO_IDLE_STATE            0}\par
00034 {\cf21 #define SEND_OP_COND             1}\par
00035 {\cf21 #define SEND_IF_COND             8}\par
00036 {\cf21 #define SEND_CSD                 9}\par
00037 {\cf21 #define STOP_TRANSMISSION        12}\par
00038 {\cf21 #define SEND_STATUS              13}\par
00039 {\cf21 #define SET_BLOCK_LEN            16}\par
00040 {\cf21 #define READ_SINGLE_BLOCK        17}\par
00041 {\cf21 #define READ_MULTIPLE_BLOCKS     18}\par
00042 {\cf21 #define WRITE_SINGLE_BLOCK       24}\par
00043 {\cf21 #define WRITE_MULTIPLE_BLOCKS    25}\par
00044 {\cf21 #define ERASE_BLOCK_START_ADDR   32}\par
00045 {\cf21 #define ERASE_BLOCK_END_ADDR     33}\par
00046 {\cf21 #define ERASE_SELECTED_BLOCKS    38}\par
00047 {\cf21 #define SD_SEND_OP_COND          41   }{\cf20 //ACMD}\par
00048 {\cf21 #define APP_CMD                  55}\par
00049 {\cf21 #define READ_OCR                 58}\par
00050 {\cf21 #define CRC_ON_OFF               59}\par
00051 \par
00052 \par
00053 {\cf21 #define ON     1}\par
00054 {\cf21 #define OFF    0}\par
00055 \par
00056 {\cf17 volatile} {\cf18 unsigned} {\cf18 long} startBlock, totalBlocks; \par
00057 {\cf17 volatile} {\cf18 unsigned} {\cf18 char} SDHC_flag, cardType, buffer[512];\par
00058 \par
00059 {\cf18 unsigned} {\cf18 char} SD_init({\cf18 void});\par
00060 {\cf18 unsigned} {\cf18 char} SD_sendCommand({\cf18 unsigned} {\cf18 char} cmd, {\cf18 unsigned} {\cf18 long} arg);\par
00061 {\cf18 unsigned} {\cf18 char} SD_readSingleBlock({\cf18 unsigned} {\cf18 long} startBlock);\par
00062 {\cf18 unsigned} {\cf18 char} SD_writeSingleBlock({\cf18 unsigned} {\cf18 long} startBlock);\par
00063 {\cf18 unsigned} {\cf18 char} SD_readMultipleBlock ({\cf18 unsigned} {\cf18 long} startBlock, {\cf18 unsigned} {\cf18 long} totalBlocks);\par
00064 {\cf18 unsigned} {\cf18 char} SD_writeMultipleBlock({\cf18 unsigned} {\cf18 long} startBlock, {\cf18 unsigned} {\cf18 long} totalBlocks);\par
00065 {\cf18 unsigned} {\cf18 char} SD_erase ({\cf18 unsigned} {\cf18 long} startBlock, {\cf18 unsigned} {\cf18 long} totalBlocks);\par
00066 \par
00067 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/sgp41/SensirionI2CSgp41.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/sgp41/SensirionI2CSgp41.c}
{\xe \v lib/sgp41/SensirionI2CSgp41.c}
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "SensirionI2CSgp41.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <util/delay.h>}\par
{\f2 #include "twi.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SGP41_I2C_ADDRESS}\~ 0x59\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b sgp41_executeConditioning} (uint16_t defaultRh, uint16_t defaultT, uint16_t *srawVoc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b sgp41_measureRawSignals} (uint16_t relativeHumidity, uint16_t temperature, uint16_t *srawVoc, uint16_t *srawNox)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b sgp41_executeSelfTest} (uint16_t *testResult)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b sgp41_turnHeaterOff} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b sgp41_getSerialNumber} (uint16_t serialNumber[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v SGP41_I2C_ADDRESS\:SensirionI2CSgp41.c}
{\xe \v SensirionI2CSgp41.c\:SGP41_I2C_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SGP41_I2C_ADDRESS\~ 0x59}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b SensirionI2CSgp41.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sgp41_executeConditioning\:SensirionI2CSgp41.c}
{\xe \v SensirionI2CSgp41.c\:sgp41_executeConditioning}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t sgp41_executeConditioning (uint16_t defaultRh, uint16_t defaultT, uint16_t * srawVoc)}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b SensirionI2CSgp41.c}.}\par
}
{\xe \v sgp41_executeSelfTest\:SensirionI2CSgp41.c}
{\xe \v SensirionI2CSgp41.c\:sgp41_executeSelfTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t sgp41_executeSelfTest (uint16_t * testResult)}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b SensirionI2CSgp41.c}.}\par
}
{\xe \v sgp41_getSerialNumber\:SensirionI2CSgp41.c}
{\xe \v SensirionI2CSgp41.c\:sgp41_getSerialNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t sgp41_getSerialNumber (uint16_t serialNumber[])}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 176} of file {\b SensirionI2CSgp41.c}.}\par
}
{\xe \v sgp41_measureRawSignals\:SensirionI2CSgp41.c}
{\xe \v SensirionI2CSgp41.c\:sgp41_measureRawSignals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t sgp41_measureRawSignals (uint16_t relativeHumidity, uint16_t temperature, uint16_t * srawVoc, uint16_t * srawNox)}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b SensirionI2CSgp41.c}.}\par
}
{\xe \v sgp41_turnHeaterOff\:SensirionI2CSgp41.c}
{\xe \v SensirionI2CSgp41.c\:sgp41_turnHeaterOff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t sgp41_turnHeaterOff (void )}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b SensirionI2CSgp41.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SensirionI2CSgp41.c\par \pard\plain 
{\tc\tcl2 \v lib/sgp41/SensirionI2CSgp41.c}
{\xe \v lib/sgp41/SensirionI2CSgp41.c}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * THIS FILE IS AUTOMATICALLY GENERATED}\par
00003 {\cf20  *}\par
00004 {\cf20  * I2C-Generator: 0.3.0}\par
00005 {\cf20  * Yaml Version: 0.1.0}\par
00006 {\cf20  * Template Version: 0.7.0-62-g3d691f9}\par
00007 {\cf20  */}\par
00008 {\cf20 /*}\par
00009 {\cf20  * Copyright (c) 2021, Sensirion AG}\par
00010 {\cf20  * All rights reserved.}\par
00011 {\cf20  *}\par
00012 {\cf20  * Redistribution and use in source and binary forms, with or without}\par
00013 {\cf20  * modification, are permitted provided that the following conditions are met:}\par
00014 {\cf20  *}\par
00015 {\cf20  * * Redistributions of source code must retain the above copyright notice, this}\par
00016 {\cf20  *   list of conditions and the following disclaimer.}\par
00017 {\cf20  *}\par
00018 {\cf20  * * Redistributions in binary form must reproduce the above copyright notice,}\par
00019 {\cf20  *   this list of conditions and the following disclaimer in the documentation}\par
00020 {\cf20  *   and/or other materials provided with the distribution.}\par
00021 {\cf20  *}\par
00022 {\cf20  * * Neither the name of Sensirion AG nor the names of its}\par
00023 {\cf20  *   contributors may be used to endorse or promote products derived from}\par
00024 {\cf20  *   this software without specific prior written permission.}\par
00025 {\cf20  *}\par
00026 {\cf20  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}\par
00027 {\cf20  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}\par
00028 {\cf20  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}\par
00029 {\cf20  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE}\par
00030 {\cf20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}\par
00031 {\cf20  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}\par
00032 {\cf20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}\par
00033 {\cf20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}\par
00034 {\cf20  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}\par
00035 {\cf20  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}\par
00036 {\cf20  * POSSIBILITY OF SUCH DAMAGE.}\par
00037 {\cf20  */}\par
00038 \par
00039 {\cf20 /* Minimal SGP41 implementation using `twi` library.}\par
00040 {\cf20  * This implements basic commands used by the main program and}\par
00041 {\cf20  * performs CRC checks for received data. It avoids Arduino/Wire.}\par
00042 {\cf20  */}\par
00043 \par
00044 {\cf21 #include "SensirionI2CSgp41.h"}\par
00045 {\cf21 #include <stdint.h>}\par
00046 {\cf21 #include <stddef.h>}\par
00047 {\cf21 #include <util/delay.h>}\par
00048 {\cf21 #include "twi.h"}\par
00049 \par
00050 {\cf21 #define SGP41_I2C_ADDRESS 0x59}\par
00051 \par
00052 {\cf20 // CRC8 (Sensirion) polynomial 0x31 init 0xFF}\par
00053 {\cf17 static} uint8_t sensirion_crc({\cf17 const} uint8_t *data, {\cf18 size_t} count) \{\par
00054     uint8_t crc = 0xFF;\par
00055     {\cf19 for} ({\cf18 size_t} i = 0; i < count; ++i) \{\par
00056         crc ^= data[i];\par
00057         {\cf19 for} (uint8_t bit = 0; bit < 8; ++bit) \{\par
00058             {\cf19 if} (crc & 0x80)\par
00059                 crc = (uint8_t)((crc << 1) ^ 0x31);\par
00060             {\cf19 else}\par
00061                 crc <<= 1;\par
00062         \}\par
00063     \}\par
00064     {\cf19 return} crc;\par
00065 \}\par
00066 \par
00067 {\cf20 // write command (16-bit) and optional data words (each u16) with CRC per word}\par
00068 {\cf17 static} {\cf18 int} write_command_with_words(uint16_t command, {\cf17 const} uint16_t *words,\par
00069                                     {\cf18 size_t} words_count) \{\par
00070     twi_start();\par
00071     {\cf19 if} (twi_write((SGP41_I2C_ADDRESS << 1) | TWI_WRITE)) \{\par
00072         twi_stop();\par
00073         {\cf19 return} -1; {\cf20 // address NACK}\par
00074     \}\par
00075 \par
00076     {\cf20 /* command high, low */}\par
00077     uint8_t cmd_hi = (uint8_t)((command >> 8) & 0xFF);\par
00078     uint8_t cmd_lo = (uint8_t)(command & 0xFF);\par
00079     {\cf19 if} (twi_write(cmd_hi)) \{ twi_stop(); {\cf19 return} -2; \}\par
00080     {\cf19 if} (twi_write(cmd_lo)) \{ twi_stop(); {\cf19 return} -3; \}\par
00081 \par
00082     {\cf20 // send data words with CRC (each word = 2 bytes + 1 crc)}\par
00083     {\cf19 for} ({\cf18 size_t} i = 0; i < words_count; ++i) \{\par
00084         uint8_t b1 = (uint8_t)((words[i] >> 8) & 0xFF);\par
00085         uint8_t b2 = (uint8_t)(words[i] & 0xFF);\par
00086         {\cf19 if} (twi_write(b1)) \{ twi_stop(); {\cf19 return} -4; \}\par
00087         {\cf19 if} (twi_write(b2)) \{ twi_stop(); {\cf19 return} -5; \}\par
00088         uint8_t crc = sensirion_crc(({\cf17 const} uint8_t[])\{b1, b2\}, 2);\par
00089         {\cf19 if} (twi_write(crc)) \{ twi_stop(); {\cf19 return} -6; \}\par
00090     \}\par
00091 \par
00092     twi_stop();\par
00093     {\cf19 return} 0;\par
00094 \}\par
00095 \par
00096 {\cf20 // read num_bytes from device into buf; returns 0 on success}\par
00097 {\cf17 static} {\cf18 int} read_bytes(uint8_t *buf, {\cf18 size_t} num_bytes) \{\par
00098     twi_start();\par
00099     {\cf19 if} (twi_write((SGP41_I2C_ADDRESS << 1) | TWI_READ)) \{\par
00100         twi_stop();\par
00101         {\cf19 return} -1;\par
00102     \}\par
00103     {\cf19 for} ({\cf18 size_t} i = 0; i < num_bytes; ++i) \{\par
00104         uint8_t ack = (i + 1 < num_bytes) ? TWI_ACK : TWI_NACK;\par
00105         buf[i] = twi_read(ack);\par
00106     \}\par
00107     twi_stop();\par
00108     {\cf19 return} 0;\par
00109 \}\par
00110 \par
00111 {\cf20 // Helper to check CRCs in a buffer that contains N groups of [MSB,LSB,CRC]}\par
00112 {\cf17 static} {\cf18 int} check_and_extract_words({\cf17 const} uint8_t *buf, {\cf18 size_t} groups,\par
00113                                    uint16_t *out_words) \{\par
00114     {\cf19 for} ({\cf18 size_t} i = 0; i < groups; ++i) \{\par
00115         uint8_t b1 = buf[i * 3 + 0];\par
00116         uint8_t b2 = buf[i * 3 + 1];\par
00117         uint8_t crc = buf[i * 3 + 2];\par
00118         uint8_t expected = sensirion_crc(({\cf17 const} uint8_t[])\{b1, b2\}, 2);\par
00119         {\cf19 if} (crc != expected) \{\par
00120             {\cf19 return} -2; {\cf20 // CRC error}\par
00121         \}\par
00122         out_words[i] = (uint16_t)((b1 << 8) | b2);\par
00123     \}\par
00124     {\cf19 return} 0;\par
00125 \}\par
00126 \par
00127 uint16_t sgp41_executeConditioning(uint16_t defaultRh, uint16_t defaultT,\par
00128                                    uint16_t* srawVoc) \{\par
00129     uint16_t cmd = 0x2612;\par
00130     uint16_t args[2] = \{ defaultRh, defaultT \};\par
00131     {\cf19 if} (write_command_with_words(cmd, args, 2) != 0) {\cf19 return} 1;\par
00132     _delay_ms(50);\par
00133     uint8_t buf[3];\par
00134     {\cf19 if} (read_bytes(buf, 3) != 0) {\cf19 return} 2;\par
00135     uint16_t out;\par
00136     {\cf19 if} (check_and_extract_words(buf, 1, &out) != 0) {\cf19 return} 3;\par
00137     *srawVoc = out;\par
00138     {\cf19 return} 0;\par
00139 \}\par
00140 \par
00141 uint16_t sgp41_measureRawSignals(uint16_t relativeHumidity,\par
00142                                  uint16_t temperature, uint16_t* srawVoc,\par
00143                                  uint16_t* srawNox) \{\par
00144     uint16_t cmd = 0x2619;\par
00145     uint16_t args[2] = \{ relativeHumidity, temperature \};\par
00146     {\cf19 if} (write_command_with_words(cmd, args, 2) != 0) {\cf19 return} 1;\par
00147     _delay_ms(50);\par
00148     uint8_t buf[6];\par
00149     {\cf19 if} (read_bytes(buf, 6) != 0) {\cf19 return} 2;\par
00150     uint16_t out[2];\par
00151     {\cf19 if} (check_and_extract_words(buf, 2, out) != 0) {\cf19 return} 3;\par
00152     *srawVoc = out[0];\par
00153     *srawNox = out[1];\par
00154     {\cf19 return} 0;\par
00155 \}\par
00156 \par
00157 uint16_t sgp41_executeSelfTest(uint16_t* testResult) \{\par
00158     uint16_t cmd = 0x280E;\par
00159     {\cf19 if} (write_command_with_words(cmd, NULL, 0) != 0) {\cf19 return} 1;\par
00160     _delay_ms(320);\par
00161     uint8_t buf[3];\par
00162     {\cf19 if} (read_bytes(buf, 3) != 0) {\cf19 return} 2;\par
00163     uint16_t out;\par
00164     {\cf19 if} (check_and_extract_words(buf, 1, &out) != 0) {\cf19 return} 3;\par
00165     *testResult = out;\par
00166     {\cf19 return} 0;\par
00167 \}\par
00168 \par
00169 uint16_t sgp41_turnHeaterOff({\cf18 void}) \{\par
00170     uint16_t cmd = 0x3615;\par
00171     {\cf19 if} (write_command_with_words(cmd, NULL, 0) != 0) {\cf19 return} 1;\par
00172     _delay_ms(1);\par
00173     {\cf19 return} 0;\par
00174 \}\par
00175 \par
00176 uint16_t sgp41_getSerialNumber(uint16_t serialNumber[]) \{\par
00177     uint16_t cmd = 0x3682;\par
00178     {\cf19 if} (write_command_with_words(cmd, NULL, 0) != 0) {\cf19 return} 1;\par
00179     _delay_ms(1);\par
00180     uint8_t buf[9];\par
00181     {\cf19 if} (read_bytes(buf, 9) != 0) {\cf19 return} 2;\par
00182     {\cf19 if} (check_and_extract_words(buf, 3, serialNumber) != 0) {\cf19 return} 3;\par
00183     {\cf19 return} 0;\par
00184 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/sgp41/SensirionI2CSgp41.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/sgp41/SensirionI2CSgp41.h}
{\xe \v lib/sgp41/SensirionI2CSgp41.h}
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b sgp41_executeConditioning} (uint16_t defaultRh, uint16_t defaultT, uint16_t *srawVoc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b sgp41_measureRawSignals} (uint16_t relativeHumidity, uint16_t temperature, uint16_t *srawVoc, uint16_t *srawNox)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b sgp41_executeSelfTest} (uint16_t *testResult)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b sgp41_turnHeaterOff} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b sgp41_getSerialNumber} (uint16_t serialNumber[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sgp41_executeConditioning\:SensirionI2CSgp41.h}
{\xe \v SensirionI2CSgp41.h\:sgp41_executeConditioning}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t sgp41_executeConditioning (uint16_t defaultRh, uint16_t defaultT, uint16_t * srawVoc)}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b SensirionI2CSgp41.c}.}\par
}
{\xe \v sgp41_executeSelfTest\:SensirionI2CSgp41.h}
{\xe \v SensirionI2CSgp41.h\:sgp41_executeSelfTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t sgp41_executeSelfTest (uint16_t * testResult)}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b SensirionI2CSgp41.c}.}\par
}
{\xe \v sgp41_getSerialNumber\:SensirionI2CSgp41.h}
{\xe \v SensirionI2CSgp41.h\:sgp41_getSerialNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t sgp41_getSerialNumber (uint16_t serialNumber[])}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 176} of file {\b SensirionI2CSgp41.c}.}\par
}
{\xe \v sgp41_measureRawSignals\:SensirionI2CSgp41.h}
{\xe \v SensirionI2CSgp41.h\:sgp41_measureRawSignals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t sgp41_measureRawSignals (uint16_t relativeHumidity, uint16_t temperature, uint16_t * srawVoc, uint16_t * srawNox)}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b SensirionI2CSgp41.c}.}\par
}
{\xe \v sgp41_turnHeaterOff\:SensirionI2CSgp41.h}
{\xe \v SensirionI2CSgp41.h\:sgp41_turnHeaterOff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t sgp41_turnHeaterOff (void )}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b SensirionI2CSgp41.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SensirionI2CSgp41.h\par \pard\plain 
{\tc\tcl2 \v lib/sgp41/SensirionI2CSgp41.h}
{\xe \v lib/sgp41/SensirionI2CSgp41.h}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * THIS FILE IS AUTOMATICALLY GENERATED}\par
00003 {\cf20  *}\par
00004 {\cf20  * I2C-Generator: 0.3.0}\par
00005 {\cf20  * Yaml Version: 0.1.0}\par
00006 {\cf20  * Template Version: 0.7.0-62-g3d691f9}\par
00007 {\cf20  */}\par
00008 {\cf20 /*}\par
00009 {\cf20  * Copyright (c) 2021, Sensirion AG}\par
00010 {\cf20  * All rights reserved.}\par
00011 {\cf20  *}\par
00012 {\cf20  * Redistribution and use in source and binary forms, with or without}\par
00013 {\cf20  * modification, are permitted provided that the following conditions are met:}\par
00014 {\cf20  *}\par
00015 {\cf20  * * Redistributions of source code must retain the above copyright notice, this}\par
00016 {\cf20  *   list of conditions and the following disclaimer.}\par
00017 {\cf20  *}\par
00018 {\cf20  * * Redistributions in binary form must reproduce the above copyright notice,}\par
00019 {\cf20  *   this list of conditions and the following disclaimer in the documentation}\par
00020 {\cf20  *   and/or other materials provided with the distribution.}\par
00021 {\cf20  *}\par
00022 {\cf20  * * Neither the name of Sensirion AG nor the names of its}\par
00023 {\cf20  *   contributors may be used to endorse or promote products derived from}\par
00024 {\cf20  *   this software without specific prior written permission.}\par
00025 {\cf20  *}\par
00026 {\cf20  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}\par
00027 {\cf20  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}\par
00028 {\cf20  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}\par
00029 {\cf20  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE}\par
00030 {\cf20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}\par
00031 {\cf20  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}\par
00032 {\cf20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}\par
00033 {\cf20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}\par
00034 {\cf20  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}\par
00035 {\cf20  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}\par
00036 {\cf20  * POSSIBILITY OF SUCH DAMAGE.}\par
00037 {\cf20  */}\par
00038 \par
00039 {\cf21 #ifndef SENSIRIONI2CSGP41_H}\par
00040 {\cf21 #define SENSIRIONI2CSGP41_H}\par
00041 {\cf21  #include <stdint.h>}\par
00042 {\cf20 // Minimal SGP41 C interface using project's `twi` library (no Arduino/Wire)}\par
00043 \par
00044 {\cf21 #ifdef __cplusplus}\par
00045 {\cf17 extern} {\cf22 "C"} \{\par
00046 {\cf21 #endif}\par
00047 \par
00048 {\cf20 // Send conditioning command and return SRAW_VOC in *srawVoc}\par
00049 uint16_t sgp41_executeConditioning(uint16_t defaultRh, uint16_t defaultT,\par
00050                                    uint16_t* srawVoc);\par
00051 \par
00052 {\cf20 // Measure raw signals; returns SRAW_VOC and SRAW_NOX}\par
00053 uint16_t sgp41_measureRawSignals(uint16_t relativeHumidity,\par
00054                                  uint16_t temperature, uint16_t* srawVoc,\par
00055                                  uint16_t* srawNox);\par
00056 \par
00057 uint16_t sgp41_executeSelfTest(uint16_t* testResult);\par
00058 \par
00059 uint16_t sgp41_turnHeaterOff({\cf18 void});\par
00060 \par
00061 uint16_t sgp41_getSerialNumber(uint16_t serialNumber[]);\par
00062 \par
00063 {\cf21 #ifdef __cplusplus}\par
00064 \}\par
00065 {\cf21 #endif}\par
00066 \par
00067 {\cf21 #endif }{\cf20 /* SENSIRIONI2CSGP41_H */}{\cf21 }\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/SPI/SPI_routines.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/SPI/SPI_routines.c}
{\xe \v lib/SPI/SPI_routines.c}
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <avr/io.h>}\par
{\f2 #include "SPI_routines.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b spi_init} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SPI_transmit} (unsigned char {\b data})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SPI_receive} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v spi_init\:SPI_routines.c}
{\xe \v SPI_routines.c\:spi_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void spi_init (void )}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b SPI_routines.c}.}\par
}
{\xe \v SPI_receive\:SPI_routines.c}
{\xe \v SPI_routines.c\:SPI_receive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SPI_receive (void )}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b SPI_routines.c}.}\par
}
{\xe \v SPI_transmit\:SPI_routines.c}
{\xe \v SPI_routines.c\:SPI_transmit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SPI_transmit (unsigned char data)}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b SPI_routines.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SPI_routines.c\par \pard\plain 
{\tc\tcl2 \v lib/SPI/SPI_routines.c}
{\xe \v lib/SPI/SPI_routines.c}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //**************************************************************}\par
00002 {\cf20 // ****** FUNCTIONS FOR SPI COMMUNICATION *******}\par
00003 {\cf20 //**************************************************************}\par
00004 {\cf20 //Controller        : ATmega32 (Clock: 8 Mhz-internal)}\par
00005 {\cf20 //Compiler          : AVR-GCC (winAVR with AVRStudio-4)}\par
00006 {\cf20 //Project Version   : DL_1.0}\par
00007 {\cf20 //Author            : CC Dharmani, Chennai (India)}\par
00008 {\cf20 //                    www.dharmanitech.com}\par
00009 {\cf20 //Date              : 10 May 2011}\par
00010 {\cf20 //**************************************************************}\par
00011 \par
00012 {\cf21 #include <avr/io.h>}\par
00013 {\cf21 #include "SPI_routines.h"}\par
00014 \par
00015 {\cf20 //SPI initialize for SD card}\par
00016 {\cf20 //clock rate: 125Khz}\par
00017 {\cf18 void} spi_init({\cf18 void})\par
00018 \{\par
00019     \par
00020     {\cf20 // Enable SPI, Set as Master}\par
00021     {\cf20 //- Prescaler: Fosc/16, Enable Interrupts}\par
00022     {\cf20 //The MOSI, SCK pins}\par
00023     {\cf20 //SPCR=(1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPIE);}\par
00024     {\cf20 //SPR01 }\par
00025 SPCR = 0x52; {\cf20 //setup SPI: Master mode, MSB first, SCK phase low, SCK idle low}\par
00026 SPSR = 0x00;\par
00027 \}\par
00028 \par
00029 {\cf18 unsigned} {\cf18 char} SPI_transmit({\cf18 unsigned} {\cf18 char} data)\par
00030 \{\par
00031 {\cf20 // Start transmission}\par
00032 {\cf20 // uart_puts_P("T\\r\\n");}\par
00033 SPDR = data;\par
00034 \par
00035 {\cf20 // Wait for transmission complete}\par
00036 {\cf19 while}(!(SPSR & (1<<SPIF)));\par
00037 data = SPDR;\par
00038 \par
00039 {\cf19 return}(data);\par
00040 \}\par
00041 \par
00042 {\cf18 unsigned} {\cf18 char} SPI_receive({\cf18 void})\par
00043 \{\par
00044 {\cf18 unsigned} {\cf18 char} data;\par
00045 {\cf20 // Wait for reception complete}\par
00046 \par
00047 SPDR = 0xff;\par
00048 {\cf19 while}(!(SPSR & (1<<SPIF)));\par
00049 data = SPDR;\par
00050 \par
00051 {\cf20 // Return data register}\par
00052 {\cf19 return} data;\par
00053 \}\par
00054 \par
00055 {\cf20 //******** END ****** www.dharmanitech.com *****}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/SPI/SPI_routines.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/SPI/SPI_routines.h}
{\xe \v lib/SPI/SPI_routines.h}
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SPI_SD}\~ SPCR = 0x52\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SPI_HIGH_SPEED}\~ SPCR = 0x50; SPSR |= (1<<SPI2X)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b spi_init} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SPI_transmit} (unsigned char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b SPI_receive} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v SPI_HIGH_SPEED\:SPI_routines.h}
{\xe \v SPI_routines.h\:SPI_HIGH_SPEED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SPI_HIGH_SPEED\~ SPCR = 0x50; SPSR |= (1<<SPI2X)}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b SPI_routines.h}.}\par
}
{\xe \v SPI_SD\:SPI_routines.h}
{\xe \v SPI_routines.h\:SPI_SD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SPI_SD\~ SPCR = 0x52}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b SPI_routines.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v spi_init\:SPI_routines.h}
{\xe \v SPI_routines.h\:spi_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void spi_init (void )}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b SPI_routines.c}.}\par
}
{\xe \v SPI_receive\:SPI_routines.h}
{\xe \v SPI_routines.h\:SPI_receive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SPI_receive (void )}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b SPI_routines.c}.}\par
}
{\xe \v SPI_transmit\:SPI_routines.h}
{\xe \v SPI_routines.h\:SPI_transmit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char SPI_transmit (unsigned char data)}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b SPI_routines.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SPI_routines.h\par \pard\plain 
{\tc\tcl2 \v lib/SPI/SPI_routines.h}
{\xe \v lib/SPI/SPI_routines.h}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //**************************************************************}\par
00002 {\cf20 // ****** FUNCTIONS FOR SPI COMMUNICATION *******}\par
00003 {\cf20 //**************************************************************}\par
00004 {\cf20 //Controller        : ATmega32 (Clock: 8 Mhz-internal)}\par
00005 {\cf20 //Compiler          : AVR-GCC (winAVR with AVRStudio-4)}\par
00006 {\cf20 //Project Version   : DL_1.0}\par
00007 {\cf20 //Author            : CC Dharmani, Chennai (India)}\par
00008 {\cf20 //                    www.dharmanitech.com}\par
00009 {\cf20 //Date              : 10 May 2011}\par
00010 {\cf20 //**************************************************************}\par
00011 \par
00012 {\cf21 #ifndef _SPI_ROUTINES_H_}\par
00013 {\cf21 #define _SPI_ROUTINES_H_}\par
00014 \par
00015 {\cf21 #define SPI_SD             SPCR = 0x52}\par
00016 {\cf21 #define SPI_HIGH_SPEED     SPCR = 0x50; SPSR |= (1<<SPI2X)}\par
00017 \par
00018 \par
00019 {\cf18 void} spi_init({\cf18 void});\par
00020 {\cf18 unsigned} {\cf18 char} SPI_transmit({\cf18 unsigned} {\cf18 char});\par
00021 {\cf18 unsigned} {\cf18 char} SPI_receive({\cf18 void});\par
00022 \par
00023 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/twi/twi.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/twi/twi.c}
{\xe \v lib/twi/twi.c}
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <twi.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b twi_init} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize TWI unit, enable internal pull-ups, and set SCL frequency. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b twi_start} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start communication on I2C/TWI bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_write} (uint8_t {\b data})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write one byte to the I2C/TWI bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_read} (uint8_t ack)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read one byte from the I2C/TWI bus and acknowledge it by ACK or NACK. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b twi_stop} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generates Stop condition on I2C/TWI bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_test_address} (uint8_t addr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test presence of one I2C device on the bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b twi_readfrom_mem_into} (uint8_t addr, uint8_t memaddr, volatile uint8_t *buf, uint8_t nbytes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read into buf from the peripheral, starting from the memory address. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_writeto_mem} (uint8_t addr, uint8_t memaddr, uint8_t {\b data})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write into peripheral. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_writeto_mem_16b} (uint8_t addr, uint8_t memaddr, uint8_t dataUpperHalf, uint8_t dataLowerHalf)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write 16bit into peripheral. }{
}\par
}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
twi.c\par \pard\plain 
{\tc\tcl2 \v lib/twi/twi.c}
{\xe \v lib/twi/twi.c}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * I2C/TWI library for AVR-GCC.}\par
00003 {\cf20  * (c) 2018-2025 Tomas Fryza, MIT license}\par
00004 {\cf20  *}\par
00005 {\cf20  * Developed using PlatformIO and Atmel AVR platform.}\par
00006 {\cf20  * Tested on Arduino Uno board and ATmega328P, 16 MHz.}\par
00007 {\cf20  */}\par
00008 \par
00009 {\cf20 // -- Includes ---------------------------------------------}\par
00010 {\cf21 #include <twi.h>}\par
00011 \par
00012 \par
00013 {\cf20 // -- Functions --------------------------------------------}\par
00014 {\cf20 /*}\par
00015 {\cf20  * Function: twi_init()}\par
00016 {\cf20  * Purpose:  Initialize TWI unit, enable internal pull-ups, and set SCL}\par
00017 {\cf20  *           frequency.}\par
00018 {\cf20  * Returns:  none}\par
00019 {\cf20  */}\par
00020 {\cf18 void} twi_init({\cf18 void})\par
00021 \{\par
00022     {\cf20 /* Enable internal pull-up resistors */}\par
00023     DDR(TWI_PORT) &= ~((1<<TWI_SDA_PIN) | (1<<TWI_SCL_PIN));\par
00024     TWI_PORT |= (1<<TWI_SDA_PIN) | (1<<TWI_SCL_PIN);\par
00025 \par
00026     {\cf20 /* Set SCL frequency */}\par
00027     TWSR &= ~((1<<TWPS1) | (1<<TWPS0));\par
00028     TWBR = TWI_BIT_RATE_REG;\par
00029 \}\par
00030 \par
00031 \par
00032 {\cf20 /*}\par
00033 {\cf20  * Function: twi_start()}\par
00034 {\cf20  * Purpose:  Start communication on I2C/TWI bus.}\par
00035 {\cf20  * Returns:  none}\par
00036 {\cf20  */}\par
00037 {\cf18 void} twi_start({\cf18 void})\par
00038 \{\par
00039     {\cf20 /* Send Start condition */}\par
00040     TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);\par
00041     {\cf19 while} ((TWCR & (1<<TWINT)) == 0);\par
00042 \}\par
00043 \par
00044 \par
00045 {\cf20 /*}\par
00046 {\cf20  * Function: twi_write()}\par
00047 {\cf20  * Purpose:  Write one byte to the I2C/TWI bus.}\par
00048 {\cf20  * Input:    data Byte to be transmitted}\par
00049 {\cf20  * Returns:  ACK/NACK received value}\par
00050 {\cf20  */}\par
00051 uint8_t twi_write(uint8_t data)\par
00052 \{\par
00053     uint8_t twi_status;\par
00054 \par
00055     {\cf20 /* Send SLA+R, SLA+W, or data byte on I2C/TWI bus */}\par
00056     TWDR = data;\par
00057     TWCR = (1<<TWINT) | (1<<TWEN);\par
00058     {\cf19 while} ((TWCR & (1<<TWINT)) == 0);\par
00059 \par
00060     {\cf20 /* Check value of TWI status register */}\par
00061     twi_status = TWSR & 0xf8;\par
00062 \par
00063     {\cf20 /* Status Code:}\par
00064 {\cf20          - 0x18: SLA+W has been transmitted and ACK received}\par
00065 {\cf20          - 0x28: Data byte has been transmitted and ACK has been received}\par
00066 {\cf20          - 0x40: SLA+R has been transmitted and ACK received}\par
00067 {\cf20     */}\par
00068     {\cf19 if} (twi_status == 0x18 || twi_status == 0x28 || twi_status == 0x40)\par
00069         {\cf19 return} 0;   {\cf20 /* ACK received */}\par
00070     {\cf19 else}\par
00071         {\cf19 return} 1;   {\cf20 /* NACK received */}\par
00072 \}\par
00073 \par
00074 \par
00075 {\cf20 /*}\par
00076 {\cf20  * Function: twi_read()}\par
00077 {\cf20  * Purpose:  Read one byte from the I2C/TWI bus and acknowledge}\par
00078 {\cf20  *           it by ACK or NACK.}\par
00079 {\cf20  * Input:    ack ACK/NACK value to be transmitted}\par
00080 {\cf20  * Returns:  Received data byte}\par
00081 {\cf20  */}\par
00082 uint8_t twi_read(uint8_t ack)\par
00083 \{\par
00084     {\cf19 if} (ack == TWI_ACK)\par
00085         TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);\par
00086     {\cf19 else}\par
00087         TWCR = (1<<TWINT) | (1<<TWEN);\par
00088     {\cf19 while} ((TWCR & (1<<TWINT)) == 0);\par
00089 \par
00090     {\cf19 return} (TWDR);\par
00091 \}\par
00092 \par
00093 \par
00094 {\cf20 /*}\par
00095 {\cf20  * Function: twi_stop()}\par
00096 {\cf20  * Purpose:  Generates Stop condition on I2C/TWI bus.}\par
00097 {\cf20  * Returns:  none}\par
00098 {\cf20  */}\par
00099 {\cf18 void} twi_stop({\cf18 void})\par
00100 \{\par
00101     TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);\par
00102 \}\par
00103 \par
00104 \par
00105 {\cf20 /*}\par
00106 {\cf20  * Function: twi_test_address()}\par
00107 {\cf20  * Purpose:  Test presence of one I2C device on the bus.}\par
00108 {\cf20  * Input:    addr Slave address}\par
00109 {\cf20  * Returns:  ACK/NACK received value}\par
00110 {\cf20  */}\par
00111 uint8_t twi_test_address(uint8_t addr)\par
00112 \{\par
00113     uint8_t ack;  {\cf20 // ACK response from Slave}\par
00114 \par
00115     twi_start();\par
00116     ack = twi_write((addr<<1) | TWI_WRITE);\par
00117     twi_stop();\par
00118 \par
00119     {\cf19 return} ack;\par
00120 \}\par
00121 \par
00122 \par
00123 {\cf20 /*}\par
00124 {\cf20  * Function: twi_readfrom_mem_into()}\par
00125 {\cf20  * Purpose:  Read into buf from the peripheral starting from the memory address.}\par
00126 {\cf20  * Input:    addr Slave address}\par
00127 {\cf20  *           memaddr Starting address}\par
00128 {\cf20  *           buf Buffer to be read into}\par
00129 {\cf20  *           nbytes Number of bytes}\par
00130 {\cf20  * Returns:  None}\par
00131 {\cf20  */}\par
00132 {\cf18 void} twi_readfrom_mem_into(uint8_t addr, uint8_t memaddr, {\cf17 volatile} uint8_t *buf, uint8_t nbytes)\par
00133 \{\par
00134     twi_start();\par
00135     {\cf19 if} (twi_write((addr<<1) | TWI_WRITE) == 0)\par
00136     \{\par
00137         {\cf20 // Set starting address}\par
00138         twi_write(memaddr);\par
00139         twi_stop();\par
00140 \par
00141         {\cf20 // Read data into the buffer}\par
00142         twi_start();\par
00143         twi_write((addr<<1) | TWI_READ);\par
00144         {\cf19 if} (nbytes >= 2)\par
00145         \{\par
00146             {\cf19 for} (uint8_t i=0; i<(nbytes-1); i++)\par
00147             \{\par
00148                 *buf++ = twi_read(TWI_ACK);\par
00149             \}\par
00150         \}\par
00151         *buf = twi_read(TWI_NACK);\par
00152         twi_stop();\par
00153     \}\par
00154     {\cf19 else}\par
00155     \{\par
00156         twi_stop();\par
00157     \}\par
00158     \par
00159 \}\par
00160 uint8_t twi_writeto_mem(uint8_t addr, uint8_t memaddr, uint8_t data)\par
00161 \{\par
00162     twi_start();\par
00163     {\cf20 /* Send SLA+W and check ACK */}\par
00164     {\cf19 if} (twi_write((addr<<1) | TWI_WRITE) == 0)\par
00165     \{\par
00166         {\cf20 /* Send memory address */}\par
00167         {\cf19 if} (twi_write(memaddr) == 0)\par
00168         \{\par
00169             {\cf20 /* Send data byte */}\par
00170             {\cf19 if} (twi_write(data) == 0)\par
00171             \{\par
00172                 twi_stop();\par
00173                 {\cf19 return} 0; {\cf20 /* success (ACKs received) */}\par
00174             \}\par
00175         \}\par
00176     \}\par
00177     twi_stop();\par
00178     {\cf19 return} 1; {\cf20 /* failure (NACK or other error) */}\par
00179 \}\par
00180 \par
00181 uint8_t twi_writeto_mem_16b(uint8_t addr, uint8_t memaddr, uint8_t dataUpperHalf,uint8_t dataLowerHalf)\par
00182 \{\par
00183     twi_start();\par
00184     {\cf20 /* Send SLA+W and check ACK */}\par
00185     {\cf19 if} (twi_write((addr<<1) | TWI_WRITE) == 0) {\cf20 //vyzva na komunikaciu}\par
00186     \{\par
00187         {\cf20 /* Send memory address */}\par
00188         {\cf19 if} (twi_write(memaddr) == 0)    {\cf20 //zapis adresy pociatocnej}\par
00189         \{\par
00190             {\cf20 /* Send data byte */}\par
00191             {\cf19 if} (twi_write(dataUpperHalf) == 0) {\cf20 //zapis upperHalf bytu}\par
00192             \{\par
00193                 {\cf19 if} (twi_write(dataLowerHalf) == 0) {\cf20 //zapis lowerHalf bytu}\par
00194                 \{\par
00195                     twi_stop();\par
00196                     {\cf19 return} 0; {\cf20 /* success (ACKs received) */}\par
00197                 \}\par
00198             \par
00199             \}\par
00200         \}\par
00201     \}\par
00202     twi_stop();\par
00203     {\cf19 return} 1; {\cf20 /* failure (NACK or other error) */}\par
00204 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/twi/twi.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/twi/twi.h}
{\xe \v lib/twi/twi.h}
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <avr/io.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Definition of frequencies\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b F_CPU}\~ 16000000\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CPU frequency in Hz required TWI_BIT_RATE_REG. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b F_SCL}\~ 100000\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
I2C/TWI bit rate. Must be greater than 31000. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_BIT_RATE_REG}\~ (({\b F_CPU}/{\b F_SCL} - 16) / 2)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TWI bit rate register value. }{
}\par
}\par}
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Definition of ports and pins\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_PORT}\~ PORTC\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Port of TWI unit. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_SDA_PIN}\~ 4\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SDA pin of TWI unit. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_SCL_PIN}\~ 5\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCL pin of TWI unit. }{
}\par
}\par}
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_writeto_mem_16b} (uint8_t addr, uint8_t memaddr, uint8_t dataUpperHalf, uint8_t dataLowerHalf)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write 16bit into peripheral. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Other definitions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_WRITE}\~ 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mode for writing to I2C/TWI device. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_READ}\~ 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mode for reading from I2C/TWI device. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_ACK}\~ 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ACK value for writing to I2C/TWI bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWI_NACK}\~ 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NACK value for writing to I2C/TWI bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DDR}(_x)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Address of Data Direction Register of port _x. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIN}(_x)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Address of input register of port _x. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b twi_init} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize TWI unit, enable internal pull-ups, and set SCL frequency. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b twi_start} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start communication on I2C/TWI bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_write} (uint8_t {\b data})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write one byte to the I2C/TWI bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_read} (uint8_t ack)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read one byte from the I2C/TWI bus and acknowledge it by ACK or NACK. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b twi_stop} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generates Stop condition on I2C/TWI bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_test_address} (uint8_t addr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test presence of one I2C device on the bus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b twi_readfrom_mem_into} (uint8_t addr, uint8_t memaddr, volatile uint8_t *buf, uint8_t nbytes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read into buf from the peripheral, starting from the memory address. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b twi_writeto_mem} (uint8_t addr, uint8_t memaddr, uint8_t {\b data})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write into peripheral. }{
}\par
}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
twi.h\par \pard\plain 
{\tc\tcl2 \v lib/twi/twi.h}
{\xe \v lib/twi/twi.h}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef TWI_H}\par
00002 {\cf21 #define TWI_H}\par
00003 \par
00004 {\cf20 /*}\par
00005 {\cf20  * I2C/TWI library for AVR-GCC.}\par
00006 {\cf20  * (c) 2018-2025 Tomas Fryza, MIT license}\par
00007 {\cf20  *}\par
00008 {\cf20  * Developed using PlatformIO and Atmel AVR platform.}\par
00009 {\cf20  * Tested on Arduino Uno board and ATmega328P, 16 MHz.}\par
00010 {\cf20  */}\par
00011 \par
00026 \par
00027 {\cf20 // -- Includes ---------------------------------------------}\par
00028 {\cf21  #include <avr/io.h>}\par
00029 \par
00030 \par
00031 {\cf20 // -- Defines ----------------------------------------------}\par
00035 {\cf21 #ifndef F_CPU}\par
00036 {\cf21 #define F_CPU 16000000 }{\cf21 }\par
00037 {\cf21 #endif}\par
00038 {\cf21 #define F_SCL 100000 }{\cf21 }\par
00039 {\cf21 #define TWI_BIT_RATE_REG ((F_CPU/F_SCL - 16) / 2) }{\cf21 }\par
00040 \par
00041 \par
00045 {\cf21 #define TWI_PORT PORTC }{\cf21 }\par
00046 {\cf21 #define TWI_SDA_PIN 4 }{\cf21 }\par
00047 {\cf21 #define TWI_SCL_PIN 5 }{\cf21 }\par
00048 \par
00049 \par
00053 {\cf21 #define TWI_WRITE 0 }{\cf21 }\par
00054 {\cf21 #define TWI_READ 1 }{\cf21 }\par
00055 {\cf21 #define TWI_ACK 0 }{\cf21 }\par
00056 {\cf21 #define TWI_NACK 1 }{\cf21 }\par
00057 {\cf21 #define DDR(_x) (*(&_x - 1)) }{\cf21 }\par
00058 {\cf21 #define PIN(_x) (*(&_x - 2)) }{\cf21 }\par
00059 \par
00060 \par
00061 {\cf20 // -- Function prototypes ----------------------------------}\par
00071 {\cf18 void} twi_init({\cf18 void});\par
00072 \par
00073 \par
00078 {\cf18 void} twi_start({\cf18 void});\par
00079 \par
00080 \par
00092 uint8_t twi_write(uint8_t data);\par
00093 \par
00094 \par
00101 uint8_t twi_read(uint8_t ack);\par
00102 \par
00103 \par
00108 {\cf18 void} twi_stop({\cf18 void});\par
00109 \par
00110 \par
00118 uint8_t twi_test_address(uint8_t addr);\par
00119 \par
00120 \par
00129 {\cf18 void} twi_readfrom_mem_into(uint8_t addr, uint8_t memaddr, {\cf17 volatile} uint8_t *buf, uint8_t nbytes);\par
00130 \par
00138 uint8_t twi_writeto_mem(uint8_t addr, uint8_t memaddr, uint8_t data);\par
00139 \par
00149 uint8_t twi_writeto_mem_16b(uint8_t addr, uint8_t memaddr, uint8_t dataUpperHalf,uint8_t dataLowerHalf);\par
00150 \par
00151 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/uart/uart.c File Reference\par \pard\plain 
{\tc\tcl2 \v lib/uart/uart.c}
{\xe \v lib/uart/uart.c}
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <avr/io.h>}\par
{\f2 #include <avr/interrupt.h>}\par
{\f2 #include <avr/pgmspace.h>}\par
{\f2 #include "uart.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_RX_BUFFER_MASK}\~ ( {\b UART_RX_BUFFER_SIZE} - 1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_TX_BUFFER_MASK}\~ ( {\b UART_TX_BUFFER_SIZE} - 1)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b if} ({\b tmphead}==UART_RxTail)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b if} (UART_TxHead !=UART_TxTail)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart_init} (unsigned int baudrate)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize UART and set baudrate. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b uart_getc} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get received byte from ringbuffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart_putc} (unsigned char {\b data})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put byte to ringbuffer for transmitting via UART. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart_puts} (const char *s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put string to ringbuffer for transmitting via UART. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart_puts_p} (const char *progmem_s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put string from program memory to ringbuffer for transmitting via UART. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b data}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b usr} = UART0_STATUS\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b lastRxError} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b tmphead} = ( UART_RxHead + 1) & {\b UART_RX_BUFFER_MASK}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b else}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v UART_RX_BUFFER_MASK\:uart.c}
{\xe \v uart.c\:UART_RX_BUFFER_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UART_RX_BUFFER_MASK\~ ( {\b UART_RX_BUFFER_SIZE} - 1)}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b uart.c}.}\par
}
{\xe \v UART_TX_BUFFER_MASK\:uart.c}
{\xe \v uart.c\:UART_TX_BUFFER_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UART_TX_BUFFER_MASK\~ ( {\b UART_TX_BUFFER_SIZE} - 1)}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b uart.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v if\:uart.c}
{\xe \v uart.c\:if}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
if ({\b tmphead}  = {\f2 =\~ UART_RxTail})}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 391} of file {\b uart.c}.}\par
}
{\xe \v if\:uart.c}
{\xe \v uart.c\:if}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
if (UART_TxHead !  = {\f2 UART_TxTail})}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 417} of file {\b uart.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v data\:uart.c}
{\xe \v uart.c\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
data}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
    {\cf18 unsigned} {\cf18 char} tmphead\par
}
{
Definition at line {\b 368} of file {\b uart.c}.}\par
}
{\xe \v else\:uart.c}
{\xe \v uart.c\:else}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
else}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        \par
        UART_RxHead = tmphead\par
}
{
Definition at line {\b 396} of file {\b uart.c}.}\par
}
{\xe \v lastRxError\:uart.c}
{\xe \v uart.c\:lastRxError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char lastRxError = 0}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 370} of file {\b uart.c}.}\par
}
{\xe \v tmphead\:uart.c}
{\xe \v uart.c\:tmphead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
tmphead = ( UART_RxHead + 1) & {\b UART_RX_BUFFER_MASK}}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 389} of file {\b uart.c}.}\par
}
{\xe \v usr\:uart.c}
{\xe \v uart.c\:usr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
usr = UART0_STATUS}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 369} of file {\b uart.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
uart.c\par \pard\plain 
{\tc\tcl2 \v lib/uart/uart.c}
{\xe \v lib/uart/uart.c}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*************************************************************************}\par
00002 {\cf20 *  Title:    Interrupt UART library with receive/transmit circular buffers}\par
00003 {\cf20 *  Author:   Peter Fleury <pfleury@gmx.ch>   http://tinyurl.com/peterfleury}\par
00004 {\cf20 *  File:     $Id: uart.c,v 1.15.2.4 2015/09/05 18:33:32 peter Exp $}\par
00005 {\cf20 *  Software: AVR-GCC 4.x}\par
00006 {\cf20 *  Hardware: any AVR with built-in UART,}\par
00007 {\cf20 *  License:  GNU General Public License}\par
00008 {\cf20 *}\par
00009 {\cf20 *  DESCRIPTION:}\par
00010 {\cf20 *   An interrupt is generated when the UART has finished transmitting or}\par
00011 {\cf20 *   receiving a byte. The interrupt handling routines use circular buffers}\par
00012 {\cf20 *   for buffering received and transmitted data.}\par
00013 {\cf20 *}\par
00014 {\cf20 *   The UART_RX_BUFFER_SIZE and UART_TX_BUFFER_SIZE variables define}\par
00015 {\cf20 *   the buffer size in bytes. Note that these variables must be a}\par
00016 {\cf20 *   power of 2.}\par
00017 {\cf20 *}\par
00018 {\cf20 *  USAGE:}\par
00019 {\cf20 *   Refere to the header file uart.h for a description of the routines.}\par
00020 {\cf20 *   See also example test_uart.c.}\par
00021 {\cf20 *}\par
00022 {\cf20 *  NOTES:}\par
00023 {\cf20 *   Based on Atmel Application Note AVR306}\par
00024 {\cf20 *}\par
00025 {\cf20 *  LICENSE:}\par
00026 {\cf20 *   Copyright (C) 2015 Peter Fleury, GNU General Public License Version 3}\par
00027 {\cf20 *}\par
00028 {\cf20 *   This program is free software; you can redistribute it and/or modify}\par
00029 {\cf20 *   it under the terms of the GNU General Public License as published by}\par
00030 {\cf20 *   the Free Software Foundation; either version 2 of the License, or}\par
00031 {\cf20 *   any later version.}\par
00032 {\cf20 *}\par
00033 {\cf20 *   This program is distributed in the hope that it will be useful,}\par
00034 {\cf20 *   but WITHOUT ANY WARRANTY; without even the implied warranty of}\par
00035 {\cf20 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}\par
00036 {\cf20 *   GNU General Public License for more details.}\par
00037 {\cf20 *}\par
00038 {\cf20 *************************************************************************/}\par
00039 {\cf21 #include <avr/io.h>}\par
00040 {\cf21 #include <avr/interrupt.h>}\par
00041 {\cf21 #include <avr/pgmspace.h>}\par
00042 {\cf21 #include "uart.h"}\par
00043 \par
00044 \par
00045 {\cf20 /*}\par
00046 {\cf20  *  constants and macros}\par
00047 {\cf20  */}\par
00048 \par
00049 {\cf20 /* size of RX/TX buffers */}\par
00050 {\cf21 #define UART_RX_BUFFER_MASK ( UART_RX_BUFFER_SIZE - 1)}\par
00051 {\cf21 #define UART_TX_BUFFER_MASK ( UART_TX_BUFFER_SIZE - 1)}\par
00052 \par
00053 {\cf21 #if ( UART_RX_BUFFER_SIZE & UART_RX_BUFFER_MASK )}\par
00054 {\cf21 # error RX buffer size is not a power of 2}\par
00055 {\cf21 #endif}\par
00056 {\cf21 #if ( UART_TX_BUFFER_SIZE & UART_TX_BUFFER_MASK )}\par
00057 {\cf21 # error TX buffer size is not a power of 2}\par
00058 {\cf21 #endif}\par
00059 \par
00060 \par
00061 {\cf21 #if defined(__AVR_AT90S2313__) || defined(__AVR_AT90S4414__) || defined(__AVR_AT90S8515__) || \\}\par
00062 {\cf21     defined(__AVR_AT90S4434__) || defined(__AVR_AT90S8535__) || \\}\par
00063 {\cf21     defined(__AVR_ATmega103__)}\par
00064 {\cf20 /* old AVR classic or ATmega103 with one UART */}\par
00065 {\cf21 # define UART0_RECEIVE_INTERRUPT  UART_RX_vect}\par
00066 {\cf21 # define UART0_TRANSMIT_INTERRUPT UART_UDRE_vect}\par
00067 {\cf21 # define UART0_STATUS             USR}\par
00068 {\cf21 # define UART0_CONTROL            UCR}\par
00069 {\cf21 # define UART0_DATA               UDR}\par
00070 {\cf21 # define UART0_UDRIE              UDRIE}\par
00071 {\cf21 # define UART0_UBRRL              UBRR}\par
00072 {\cf21 # define UART0_BIT_U2X            U2X}\par
00073 {\cf21 # define UART0_BIT_RXCIE          RXCIE}\par
00074 {\cf21 # define UART0_BIT_RXEN           RXEN}\par
00075 {\cf21 # define UART0_BIT_TXEN           TXEN}\par
00076 {\cf21 #elif defined(__AVR_AT90S2333__) || defined(__AVR_AT90S4433__)}\par
00077 {\cf20 /* old AVR classic with one UART */}\par
00078 {\cf21 # define UART0_RECEIVE_INTERRUPT  UART_RX_vect}\par
00079 {\cf21 # define UART0_TRANSMIT_INTERRUPT UART_UDRE_vect}\par
00080 {\cf21 # define UART0_STATUS             UCSRA}\par
00081 {\cf21 # define UART0_CONTROL            UCSRB}\par
00082 {\cf21 # define UART0_DATA               UDR}\par
00083 {\cf21 # define UART0_UDRIE              UDRIE}\par
00084 {\cf21 # define UART0_UBRRL              UBRR}\par
00085 {\cf21 # define UART0_BIT_U2X            U2X}\par
00086 {\cf21 # define UART0_BIT_RXCIE          RXCIE}\par
00087 {\cf21 # define UART0_BIT_RXEN           RXEN}\par
00088 {\cf21 # define UART0_BIT_TXEN           TXEN}\par
00089 {\cf21 #elif defined(__AVR_AT90PWM216__) || defined(__AVR_AT90PWM316__)}\par
00090 {\cf20 /* AT90PWN216/316 with one USART */}\par
00091 {\cf21 # define UART0_RECEIVE_INTERRUPT  USART_RX_vect}\par
00092 {\cf21 # define UART0_TRANSMIT_INTERRUPT USART_UDRE_vect}\par
00093 {\cf21 # define UART0_STATUS             UCSRA}\par
00094 {\cf21 # define UART0_CONTROL            UCSRB}\par
00095 {\cf21 # define UART0_CONTROLC           UCSRC}\par
00096 {\cf21 # define UART0_DATA               UDR}\par
00097 {\cf21 # define UART0_UDRIE              UDRIE}\par
00098 {\cf21 # define UART0_UBRRL              UBRRL}\par
00099 {\cf21 # define UART0_UBRRH              UBRRH}\par
00100 {\cf21 # define UART0_BIT_U2X            U2X}\par
00101 {\cf21 # define UART0_BIT_RXCIE          RXCIE}\par
00102 {\cf21 # define UART0_BIT_RXEN           RXEN}\par
00103 {\cf21 # define UART0_BIT_TXEN           TXEN}\par
00104 {\cf21 # define UART0_BIT_UCSZ0          UCSZ0}\par
00105 {\cf21 # define UART0_BIT_UCSZ1          UCSZ1}\par
00106 {\cf21 #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega8A__) || \\}\par
00107 {\cf21     defined(__AVR_ATmega16__) || defined(__AVR_ATmega16A__) || \\}\par
00108 {\cf21     defined(__AVR_ATmega32__) || defined(__AVR_ATmega32A__) || \\}\par
00109 {\cf21     defined(__AVR_ATmega323__)}\par
00110 {\cf20 /* ATmega with one USART */}\par
00111 {\cf21 # define UART0_RECEIVE_INTERRUPT  USART_RXC_vect}\par
00112 {\cf21 # define UART0_TRANSMIT_INTERRUPT USART_UDRE_vect}\par
00113 {\cf21 # define UART0_STATUS             UCSRA}\par
00114 {\cf21 # define UART0_CONTROL            UCSRB}\par
00115 {\cf21 # define UART0_CONTROLC           UCSRC}\par
00116 {\cf21 # define UART0_DATA               UDR}\par
00117 {\cf21 # define UART0_UDRIE              UDRIE}\par
00118 {\cf21 # define UART0_UBRRL              UBRRL}\par
00119 {\cf21 # define UART0_UBRRH              UBRRH}\par
00120 {\cf21 # define UART0_BIT_U2X            U2X}\par
00121 {\cf21 # define UART0_BIT_RXCIE          RXCIE}\par
00122 {\cf21 # define UART0_BIT_RXEN           RXEN}\par
00123 {\cf21 # define UART0_BIT_TXEN           TXEN}\par
00124 {\cf21 # define UART0_BIT_UCSZ0          UCSZ0}\par
00125 {\cf21 # define UART0_BIT_UCSZ1          UCSZ1}\par
00126 {\cf21 # define UART0_BIT_URSEL          URSEL}\par
00127 {\cf21 #elif defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)}\par
00128 {\cf21 # define UART0_RECEIVE_INTERRUPT  USART_RX_vect}\par
00129 {\cf21 # define UART0_TRANSMIT_INTERRUPT USART_UDRE_vect}\par
00130 {\cf21 # define UART0_STATUS             UCSRA}\par
00131 {\cf21 # define UART0_CONTROL            UCSRB}\par
00132 {\cf21 # define UART0_CONTROLC           UCSRC}\par
00133 {\cf21 # define UART0_DATA               UDR}\par
00134 {\cf21 # define UART0_UDRIE              UDRIE}\par
00135 {\cf21 # define UART0_UBRRL              UBRRL}\par
00136 {\cf21 # define UART0_UBRRH              UBRRH}\par
00137 {\cf21 # define UART0_BIT_U2X            U2X}\par
00138 {\cf21 # define UART0_BIT_RXCIE          RXCIE}\par
00139 {\cf21 # define UART0_BIT_RXEN           RXEN}\par
00140 {\cf21 # define UART0_BIT_TXEN           TXEN}\par
00141 {\cf21 # define UART0_BIT_UCSZ0          UCSZ0}\par
00142 {\cf21 # define UART0_BIT_UCSZ1          UCSZ1}\par
00143 {\cf21 # define UART0_BIT_URSEL          URSEL}\par
00144 {\cf21 #elif defined(__AVR_ATmega163__)}\par
00145 {\cf20 /* ATmega163 with one UART */}\par
00146 {\cf21 # define UART0_RECEIVE_INTERRUPT  UART_RX_vect}\par
00147 {\cf21 # define UART0_TRANSMIT_INTERRUPT UART_UDRE_vect}\par
00148 {\cf21 # define UART0_STATUS             UCSRA}\par
00149 {\cf21 # define UART0_CONTROL            UCSRB}\par
00150 {\cf21 # define UART0_DATA               UDR}\par
00151 {\cf21 # define UART0_UDRIE              UDRIE}\par
00152 {\cf21 # define UART0_UBRRL              UBRR}\par
00153 {\cf21 # define UART0_UBRRH              UBRRHI}\par
00154 {\cf21 # define UART0_BIT_U2X            U2X}\par
00155 {\cf21 # define UART0_BIT_RXCIE          RXCIE}\par
00156 {\cf21 # define UART0_BIT_RXEN           RXEN}\par
00157 {\cf21 # define UART0_BIT_TXEN           TXEN}\par
00158 {\cf21 #elif defined(__AVR_ATmega162__)}\par
00159 {\cf20 /* ATmega with two USART */}\par
00160 {\cf21 # define ATMEGA_USART1}\par
00161 {\cf21 # define UART0_RECEIVE_INTERRUPT  USART0_RXC_vect}\par
00162 {\cf21 # define UART1_RECEIVE_INTERRUPT  USART1_RXC_vect}\par
00163 {\cf21 # define UART0_TRANSMIT_INTERRUPT USART0_UDRE_vect}\par
00164 {\cf21 # define UART1_TRANSMIT_INTERRUPT USART1_UDRE_vect}\par
00165 {\cf21 # define UART0_STATUS             UCSR0A}\par
00166 {\cf21 # define UART0_CONTROL            UCSR0B}\par
00167 {\cf21 # define UART0_CONTROLC           UCSR0C}\par
00168 {\cf21 # define UART0_DATA               UDR0}\par
00169 {\cf21 # define UART0_UDRIE              UDRIE0}\par
00170 {\cf21 # define UART0_UBRRL              UBRR0L}\par
00171 {\cf21 # define UART0_UBRRH              UBRR0H}\par
00172 {\cf21 # define UART0_BIT_URSEL          URSEL0}\par
00173 {\cf21 # define UART0_BIT_U2X            U2X0}\par
00174 {\cf21 # define UART0_BIT_RXCIE          RXCIE0}\par
00175 {\cf21 # define UART0_BIT_RXEN           RXEN0}\par
00176 {\cf21 # define UART0_BIT_TXEN           TXEN0}\par
00177 {\cf21 # define UART0_BIT_UCSZ0          UCSZ00}\par
00178 {\cf21 # define UART0_BIT_UCSZ1          UCSZ01}\par
00179 {\cf21 # define UART1_STATUS             UCSR1A}\par
00180 {\cf21 # define UART1_CONTROL            UCSR1B}\par
00181 {\cf21 # define UART1_CONTROLC           UCSR1C}\par
00182 {\cf21 # define UART1_DATA               UDR1}\par
00183 {\cf21 # define UART1_UDRIE              UDRIE1}\par
00184 {\cf21 # define UART1_UBRRL              UBRR1L}\par
00185 {\cf21 # define UART1_UBRRH              UBRR1H}\par
00186 {\cf21 # define UART1_BIT_URSEL          URSEL1}\par
00187 {\cf21 # define UART1_BIT_U2X            U2X1}\par
00188 {\cf21 # define UART1_BIT_RXCIE          RXCIE1}\par
00189 {\cf21 # define UART1_BIT_RXEN           RXEN1}\par
00190 {\cf21 # define UART1_BIT_TXEN           TXEN1}\par
00191 {\cf21 # define UART1_BIT_UCSZ0          UCSZ10}\par
00192 {\cf21 # define UART1_BIT_UCSZ1          UCSZ11}\par
00193 {\cf21 #elif defined(__AVR_ATmega161__)}\par
00194 {\cf20 /* ATmega with UART */}\par
00195 {\cf21 # error "AVR ATmega161 currently not supported by this libaray !"}\par
00196 {\cf21 #elif defined(__AVR_ATmega169__)}\par
00197 {\cf20 /* ATmega with one USART */}\par
00198 {\cf21 # define UART0_RECEIVE_INTERRUPT  USART0_RX_vect}\par
00199 {\cf21 # define UART0_TRANSMIT_INTERRUPT USART0_UDRE_vect}\par
00200 {\cf21 # define UART0_STATUS             UCSRA}\par
00201 {\cf21 # define UART0_CONTROL            UCSRB}\par
00202 {\cf21 # define UART0_CONTROLC           UCSRC}\par
00203 {\cf21 # define UART0_DATA               UDR}\par
00204 {\cf21 # define UART0_UDRIE              UDRIE}\par
00205 {\cf21 # define UART0_UBRRL              UBRRL}\par
00206 {\cf21 # define UART0_UBRRH              UBRRH}\par
00207 {\cf21 # define UART0_BIT_U2X            U2X}\par
00208 {\cf21 # define UART0_BIT_RXCIE          RXCIE}\par
00209 {\cf21 # define UART0_BIT_RXEN           RXEN}\par
00210 {\cf21 # define UART0_BIT_TXEN           TXEN}\par
00211 {\cf21 # define UART0_BIT_UCSZ0          UCSZ0}\par
00212 {\cf21 # define UART0_BIT_UCSZ1          UCSZ1}\par
00213 {\cf21 #elif defined(__AVR_ATmega48__) || defined(__AVR_ATmega48A__) || defined(__AVR_ATmega48P__) || defined(__AVR_ATmega48PA__) || defined(__AVR_ATmega48PB__) || \\}\par
00214 {\cf21     defined(__AVR_ATmega88__) || defined(__AVR_ATmega88A__) || defined(__AVR_ATmega88P__) || defined(__AVR_ATmega88PA__) || defined(__AVR_ATmega88PB__) || \\}\par
00215 {\cf21     defined(__AVR_ATmega168__) || defined(__AVR_ATmega168A__) || defined(__AVR_ATmega168P__) || defined(__AVR_ATmega168PA__) || defined(__AVR_ATmega168PB__) || \\}\par
00216 {\cf21     defined(__AVR_ATmega328__) || defined(__AVR_ATmega328P__) || \\}\par
00217 {\cf21     defined(__AVR_ATmega3250__) || defined(__AVR_ATmega3290__) || defined(__AVR_ATmega6450__) || defined(__AVR_ATmega6490__)}\par
00218 {\cf20 /* ATmega with one USART */}\par
00219 {\cf21 # define UART0_RECEIVE_INTERRUPT  USART_RX_vect}\par
00220 {\cf21 # define UART0_TRANSMIT_INTERRUPT USART_UDRE_vect}\par
00221 {\cf21 # define UART0_STATUS             UCSR0A}\par
00222 {\cf21 # define UART0_CONTROL            UCSR0B}\par
00223 {\cf21 # define UART0_CONTROLC           UCSR0C}\par
00224 {\cf21 # define UART0_DATA               UDR0}\par
00225 {\cf21 # define UART0_UDRIE              UDRIE0}\par
00226 {\cf21 # define UART0_UBRRL              UBRR0L}\par
00227 {\cf21 # define UART0_UBRRH              UBRR0H}\par
00228 {\cf21 # define UART0_BIT_U2X            U2X0}\par
00229 {\cf21 # define UART0_BIT_RXCIE          RXCIE0}\par
00230 {\cf21 # define UART0_BIT_RXEN           RXEN0}\par
00231 {\cf21 # define UART0_BIT_TXEN           TXEN0}\par
00232 {\cf21 # define UART0_BIT_UCSZ0          UCSZ00}\par
00233 {\cf21 # define UART0_BIT_UCSZ1          UCSZ01}\par
00234 {\cf21 #elif defined(__AVR_ATtiny2313__) || defined(__AVR_ATtiny2313A__) || defined(__AVR_ATtiny4313__)}\par
00235 {\cf20 /* ATtiny with one USART */}\par
00236 {\cf21 # define UART0_RECEIVE_INTERRUPT  USART_RX_vect}\par
00237 {\cf21 # define UART0_TRANSMIT_INTERRUPT USART_UDRE_vect}\par
00238 {\cf21 # define UART0_STATUS             UCSRA}\par
00239 {\cf21 # define UART0_CONTROL            UCSRB}\par
00240 {\cf21 # define UART0_CONTROLC           UCSRC}\par
00241 {\cf21 # define UART0_DATA               UDR}\par
00242 {\cf21 # define UART0_UDRIE              UDRIE}\par
00243 {\cf21 # define UART0_UBRRL              UBRRL}\par
00244 {\cf21 # define UART0_UBRRH              UBRRH}\par
00245 {\cf21 # define UART0_BIT_U2X            U2X}\par
00246 {\cf21 # define UART0_BIT_RXCIE          RXCIE}\par
00247 {\cf21 # define UART0_BIT_RXEN           RXEN}\par
00248 {\cf21 # define UART0_BIT_TXEN           TXEN}\par
00249 {\cf21 # define UART0_BIT_UCSZ0          UCSZ0}\par
00250 {\cf21 # define UART0_BIT_UCSZ1          UCSZ1}\par
00251 {\cf21 #elif defined(__AVR_ATmega329__) || defined(__AVR_ATmega649__) || defined(__AVR_ATmega3290__) || defined(__AVR_ATmega6490__) || \\}\par
00252 {\cf21     defined(__AVR_ATmega169A__) || defined(__AVR_ATmega169PA__) || \\}\par
00253 {\cf21     defined(__AVR_ATmega329A__) || defined(__AVR_ATmega329PA__) || defined(__AVR_ATmega3290A__) || defined(__AVR_ATmega3290PA__) || \\}\par
00254 {\cf21     defined(__AVR_ATmega649A__) || defined(__AVR_ATmega649P__) || defined(__AVR_ATmega6490A__) || defined(__AVR_ATmega6490P__) || \\}\par
00255 {\cf21     defined(__AVR_ATmega165__) || defined(__AVR_ATmega325__) || defined(__AVR_ATmega645__) || defined(__AVR_ATmega3250__) || defined(__AVR_ATmega6450__) || \\}\par
00256 {\cf21     defined(__AVR_ATmega165A__) || defined(__AVR_ATmega165PA__) || \\}\par
00257 {\cf21     defined(__AVR_ATmega325A__) || defined(__AVR_ATmega325PA__) || defined(__AVR_ATmega3250A__) || defined(__AVR_ATmega3250PA__) || \\}\par
00258 {\cf21     defined(__AVR_ATmega645A__) || defined(__AVR_ATmega645PA__) || defined(__AVR_ATmega6450A__) || defined(__AVR_ATmega6450PA__) || \\}\par
00259 {\cf21     defined(__AVR_ATmega644__)}\par
00260 {\cf20 /* ATmega with one USART */}\par
00261 {\cf21 # define UART0_RECEIVE_INTERRUPT  USART0_RX_vect}\par
00262 {\cf21 # define UART0_TRANSMIT_INTERRUPT USART0_UDRE_vect}\par
00263 {\cf21 # define UART0_STATUS             UCSR0A}\par
00264 {\cf21 # define UART0_CONTROL            UCSR0B}\par
00265 {\cf21 # define UART0_CONTROLC           UCSR0C}\par
00266 {\cf21 # define UART0_DATA               UDR0}\par
00267 {\cf21 # define UART0_UDRIE              UDRIE0}\par
00268 {\cf21 # define UART0_UBRRL              UBRR0L}\par
00269 {\cf21 # define UART0_UBRRH              UBRR0H}\par
00270 {\cf21 # define UART0_BIT_U2X            U2X0}\par
00271 {\cf21 # define UART0_BIT_RXCIE          RXCIE0}\par
00272 {\cf21 # define UART0_BIT_RXEN           RXEN0}\par
00273 {\cf21 # define UART0_BIT_TXEN           TXEN0}\par
00274 {\cf21 # define UART0_BIT_UCSZ0          UCSZ00}\par
00275 {\cf21 # define UART0_BIT_UCSZ1          UCSZ01}\par
00276 {\cf21 #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega128A__) || \\}\par
00277 {\cf21     defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) || \\}\par
00278 {\cf21     defined(__AVR_ATmega164P__) || defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) ||  \\}\par
00279 {\cf21     defined(__AVR_ATmega164A__) || defined(__AVR_ATmega164PA__) || defined(__AVR_ATmega324A__) || defined(__AVR_ATmega324PA__) || \\}\par
00280 {\cf21     defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) || \\}\par
00281 {\cf21     defined(__AVR_ATtiny1634__)}\par
00282 {\cf20 /* ATmega with two USART */}\par
00283 {\cf21 # define ATMEGA_USART1}\par
00284 {\cf21 # define UART0_RECEIVE_INTERRUPT  USART0_RX_vect}\par
00285 {\cf21 # define UART1_RECEIVE_INTERRUPT  USART1_RX_vect}\par
00286 {\cf21 # define UART0_TRANSMIT_INTERRUPT USART0_UDRE_vect}\par
00287 {\cf21 # define UART1_TRANSMIT_INTERRUPT USART1_UDRE_vect}\par
00288 {\cf21 # define UART0_STATUS             UCSR0A}\par
00289 {\cf21 # define UART0_CONTROL            UCSR0B}\par
00290 {\cf21 # define UART0_CONTROLC           UCSR0C}\par
00291 {\cf21 # define UART0_DATA               UDR0}\par
00292 {\cf21 # define UART0_UDRIE              UDRIE0}\par
00293 {\cf21 # define UART0_UBRRL              UBRR0L}\par
00294 {\cf21 # define UART0_UBRRH              UBRR0H}\par
00295 {\cf21 # define UART0_BIT_U2X            U2X0}\par
00296 {\cf21 # define UART0_BIT_RXCIE          RXCIE0}\par
00297 {\cf21 # define UART0_BIT_RXEN           RXEN0}\par
00298 {\cf21 # define UART0_BIT_TXEN           TXEN0}\par
00299 {\cf21 # define UART0_BIT_UCSZ0          UCSZ00}\par
00300 {\cf21 # define UART0_BIT_UCSZ1          UCSZ01}\par
00301 {\cf21 # define UART1_STATUS             UCSR1A}\par
00302 {\cf21 # define UART1_CONTROL            UCSR1B}\par
00303 {\cf21 # define UART1_CONTROLC           UCSR1C}\par
00304 {\cf21 # define UART1_DATA               UDR1}\par
00305 {\cf21 # define UART1_UDRIE              UDRIE1}\par
00306 {\cf21 # define UART1_UBRRL              UBRR1L}\par
00307 {\cf21 # define UART1_UBRRH              UBRR1H}\par
00308 {\cf21 # define UART1_BIT_U2X            U2X1}\par
00309 {\cf21 # define UART1_BIT_RXCIE          RXCIE1}\par
00310 {\cf21 # define UART1_BIT_RXEN           RXEN1}\par
00311 {\cf21 # define UART1_BIT_TXEN           TXEN1}\par
00312 {\cf21 # define UART1_BIT_UCSZ0          UCSZ10}\par
00313 {\cf21 # define UART1_BIT_UCSZ1          UCSZ11}\par
00314 {\cf21 #elif defined(__AVR_ATmega8U2__) || defined(__AVR_ATmega16U2__) || defined(__AVR_ATmega32U2__) || \\}\par
00315 {\cf21     defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__) || \\}\par
00316 {\cf21     defined(__AVR_AT90USB82__) || defined(__AVR_AT90USB162__) || \\}\par
00317 {\cf21     defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB647__) || defined(__AVR_AT90USB1287__)}\par
00318 {\cf21 # define UART0_RECEIVE_INTERRUPT  USART1_RX_vect}\par
00319 {\cf21 # define UART0_TRANSMIT_INTERRUPT USART1_UDRE_vect}\par
00320 {\cf21 # define UART0_STATUS             UCSR1A}\par
00321 {\cf21 # define UART0_CONTROL            UCSR1B}\par
00322 {\cf21 # define UART0_CONTROLC           UCSR1C}\par
00323 {\cf21 # define UART0_DATA               UDR1}\par
00324 {\cf21 # define UART0_UDRIE              UDRIE1}\par
00325 {\cf21 # define UART0_UBRRL              UBRR1L}\par
00326 {\cf21 # define UART0_UBRRH              UBRR1H}\par
00327 {\cf21 # define UART0_BIT_U2X            U2X1}\par
00328 {\cf21 # define UART0_BIT_RXCIE          RXCIE1}\par
00329 {\cf21 # define UART0_BIT_RXEN           RXEN1}\par
00330 {\cf21 # define UART0_BIT_TXEN           TXEN1}\par
00331 {\cf21 # define UART0_BIT_UCSZ0          UCSZ10}\par
00332 {\cf21 # define UART0_BIT_UCSZ1          UCSZ11}\par
00333 {\cf21 #else  }{\cf20 /* if defined(__AVR_AT90S2313__) || defined(__AVR_AT90S4414__) || defined(__AVR_AT90S8515__) || defined(__AVR_AT90S4434__) || defined(__AVR_AT90S8535__) || defined(__AVR_ATmega103__) */}{\cf21 }\par
00334 {\cf21 # error "no UART definition for MCU available"}\par
00335 {\cf21 #endif }{\cf20 /* if defined(__AVR_AT90S2313__) || defined(__AVR_AT90S4414__) || defined(__AVR_AT90S8515__) || defined(__AVR_AT90S4434__) || defined(__AVR_AT90S8535__) || defined(__AVR_ATmega103__) */}{\cf21 }\par
00336 \par
00337 \par
00338 {\cf20 /*}\par
00339 {\cf20  *  module global variables}\par
00340 {\cf20  */}\par
00341 {\cf17 static} {\cf17 volatile} {\cf18 unsigned} {\cf18 char} UART_TxBuf[UART_TX_BUFFER_SIZE];\par
00342 {\cf17 static} {\cf17 volatile} {\cf18 unsigned} {\cf18 char} UART_RxBuf[UART_RX_BUFFER_SIZE];\par
00343 {\cf17 static} {\cf17 volatile} {\cf18 unsigned} {\cf18 char} UART_TxHead;\par
00344 {\cf17 static} {\cf17 volatile} {\cf18 unsigned} {\cf18 char} UART_TxTail;\par
00345 {\cf17 static} {\cf17 volatile} {\cf18 unsigned} {\cf18 char} UART_RxHead;\par
00346 {\cf17 static} {\cf17 volatile} {\cf18 unsigned} {\cf18 char} UART_RxTail;\par
00347 {\cf17 static} {\cf17 volatile} {\cf18 unsigned} {\cf18 char} UART_LastRxError;\par
00348 \par
00349 {\cf21 #if defined( ATMEGA_USART1 )}\par
00350 {\cf17 static} {\cf17 volatile} {\cf18 unsigned} {\cf18 char} UART1_TxBuf[UART_TX_BUFFER_SIZE];\par
00351 {\cf17 static} {\cf17 volatile} {\cf18 unsigned} {\cf18 char} UART1_RxBuf[UART_RX_BUFFER_SIZE];\par
00352 {\cf17 static} {\cf17 volatile} {\cf18 unsigned} {\cf18 char} UART1_TxHead;\par
00353 {\cf17 static} {\cf17 volatile} {\cf18 unsigned} {\cf18 char} UART1_TxTail;\par
00354 {\cf17 static} {\cf17 volatile} {\cf18 unsigned} {\cf18 char} UART1_RxHead;\par
00355 {\cf17 static} {\cf17 volatile} {\cf18 unsigned} {\cf18 char} UART1_RxTail;\par
00356 {\cf17 static} {\cf17 volatile} {\cf18 unsigned} {\cf18 char} UART1_LastRxError;\par
00357 {\cf21 #endif}\par
00358 \par
00359 \par
00360 ISR(UART0_RECEIVE_INTERRUPT)\par
00361 \par
00362 {\cf20 /*************************************************************************}\par
00363 {\cf20  * Function: UART Receive Complete interrupt}\par
00364 {\cf20  * Purpose:  called when the UART has received a character}\par
00365 {\cf20  **************************************************************************/}\par
00366 \{\par
00367     {\cf18 unsigned} {\cf18 char} tmphead;\par
00368     {\cf18 unsigned} {\cf18 char} data;\par
00369     {\cf18 unsigned} {\cf18 char} usr;\par
00370     {\cf18 unsigned} {\cf18 char} lastRxError = 0;\par
00371 \par
00372 \par
00373     {\cf20 /* read UART status register and UART data register */}\par
00374     usr  = UART0_STATUS;\par
00375     data = UART0_DATA;\par
00376 \par
00377     {\cf20 /* get FEn (Frame Error) DORn (Data OverRun) UPEn (USART Parity Error) bits */}\par
00378 {\cf21     #if defined(FE) && defined(DOR) && defined(UPE)}\par
00379     lastRxError = usr & (_BV(FE) | _BV(DOR) | _BV(UPE) );\par
00380 {\cf21     #elif defined(FE0) && defined(DOR0) && defined(UPE0)}\par
00381     lastRxError = usr & (_BV(FE0) | _BV(DOR0) | _BV(UPE0) );\par
00382 {\cf21     #elif defined(FE1) && defined(DOR1) && defined(UPE1)}\par
00383     lastRxError = usr & (_BV(FE1) | _BV(DOR1) | _BV(UPE1) );\par
00384 {\cf21     #elif defined(FE) && defined(DOR)}\par
00385     lastRxError = usr & (_BV(FE) | _BV(DOR) );\par
00386 {\cf21     #endif}\par
00387 \par
00388     {\cf20 /* calculate buffer index */}\par
00389     tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;\par
00390 \par
00391     {\cf19 if} (tmphead == UART_RxTail)\par
00392     \{\par
00393         {\cf20 /* error: receive buffer overflow */}\par
00394         lastRxError = UART_BUFFER_OVERFLOW >> 8;\par
00395     \}\par
00396     {\cf19 else}\par
00397     \{\par
00398         {\cf20 /* store new index */}\par
00399         UART_RxHead = tmphead;\par
00400         {\cf20 /* store received data in buffer */}\par
00401         UART_RxBuf[tmphead] = data;\par
00402     \}\par
00403     UART_LastRxError |= lastRxError;\par
00404 \}\par
00405 \par
00406 \par
00407 ISR(UART0_TRANSMIT_INTERRUPT)\par
00408 \par
00409 {\cf20 /*************************************************************************}\par
00410 {\cf20  * Function: UART Data Register Empty interrupt}\par
00411 {\cf20  * Purpose:  called when the UART is ready to transmit the next byte}\par
00412 {\cf20  **************************************************************************/}\par
00413 \{\par
00414     {\cf18 unsigned} {\cf18 char} tmptail;\par
00415 \par
00416 \par
00417     {\cf19 if} (UART_TxHead != UART_TxTail)\par
00418     \{\par
00419         {\cf20 /* calculate and store new buffer index */}\par
00420         tmptail     = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;\par
00421         UART_TxTail = tmptail;\par
00422         {\cf20 /* get one byte from buffer and write it to UART */}\par
00423         UART0_DATA = UART_TxBuf[tmptail]; {\cf20 /* start transmission */}\par
00424     \}\par
00425     {\cf19 else}\par
00426     \{\par
00427         {\cf20 /* tx buffer empty, disable UDRE interrupt */}\par
00428         UART0_CONTROL &= ~_BV(UART0_UDRIE);\par
00429     \}\par
00430 \}\par
00431 \par
00432 \par
00433 {\cf20 /*************************************************************************}\par
00434 {\cf20  * Function: uart_init()}\par
00435 {\cf20  * Purpose:  initialize UART and set baudrate}\par
00436 {\cf20  * Input:    baudrate using macro UART_BAUD_SELECT()}\par
00437 {\cf20  * Returns:  none}\par
00438 {\cf20  **************************************************************************/}\par
00439 {\cf18 void} uart_init({\cf18 unsigned} {\cf18 int} baudrate)\par
00440 \{\par
00441     UART_TxHead = 0;\par
00442     UART_TxTail = 0;\par
00443     UART_RxHead = 0;\par
00444     UART_RxTail = 0;\par
00445 \par
00446 {\cf21     #ifdef UART_TEST}\par
00447 {\cf21     # ifndef UART0_BIT_U2X}\par
00448 {\cf21     #  warning "UART0_BIT_U2X not defined"}\par
00449 {\cf21     # endif}\par
00450 {\cf21     # ifndef UART0_UBRRH}\par
00451 {\cf21     #  warning "UART0_UBRRH not defined"}\par
00452 {\cf21     # endif}\par
00453 {\cf21     # ifndef UART0_CONTROLC}\par
00454 {\cf21     #  warning "UART0_CONTROLC not defined"}\par
00455 {\cf21     # endif}\par
00456 {\cf21     # if defined(URSEL) || defined(URSEL0)}\par
00457 {\cf21     #  ifndef UART0_BIT_URSEL}\par
00458 {\cf21     #   warning "UART0_BIT_URSEL not defined"}\par
00459 {\cf21     #  endif}\par
00460 {\cf21     # endif}\par
00461 {\cf21     #endif }{\cf20 /* ifdef UART_TEST */}{\cf21 }\par
00462 \par
00463     {\cf20 /* Set baud rate */}\par
00464     {\cf19 if} (baudrate & 0x8000)\par
00465     \{\par
00466 {\cf21         #if UART0_BIT_U2X}\par
00467         UART0_STATUS = (1 << UART0_BIT_U2X); {\cf20 // Enable 2x speed}\par
00468 {\cf21         #endif}\par
00469     \}\par
00470 {\cf21     #if defined(UART0_UBRRH)}\par
00471     UART0_UBRRH = ({\cf18 unsigned} char) ((baudrate >> 8) & 0x80);\par
00472 {\cf21     #endif}\par
00473     UART0_UBRRL = ({\cf18 unsigned} char) (baudrate & 0x00FF);\par
00474 \par
00475     {\cf20 /* Enable USART receiver and transmitter and receive complete interrupt */}\par
00476     UART0_CONTROL = _BV(UART0_BIT_RXCIE) | (1 << UART0_BIT_RXEN) | (1 << UART0_BIT_TXEN);\par
00477 \par
00478     {\cf20 /* Set frame format: asynchronous, 8data, no parity, 1stop bit */}\par
00479 {\cf21     #ifdef UART0_CONTROLC}\par
00480 {\cf21     # ifdef UART0_BIT_URSEL}\par
00481     UART0_CONTROLC = (1 << UART0_BIT_URSEL) | (1 << UART0_BIT_UCSZ1) | (1 << UART0_BIT_UCSZ0);\par
00482 {\cf21     # else}\par
00483     UART0_CONTROLC = (1 << UART0_BIT_UCSZ1) | (1 << UART0_BIT_UCSZ0);\par
00484 {\cf21     # endif}\par
00485 {\cf21     #endif}\par
00486 \}{\cf20 /* uart_init */}\par
00487 \par
00488 {\cf20 /*************************************************************************}\par
00489 {\cf20  * Function: uart_getc()}\par
00490 {\cf20  * Purpose:  return byte from ringbuffer}\par
00491 {\cf20  * Returns:  lower byte:  received byte from ringbuffer}\par
00492 {\cf20  *        higher byte: last receive error}\par
00493 {\cf20  **************************************************************************/}\par
00494 {\cf18 unsigned} {\cf18 int} uart_getc({\cf18 void})\par
00495 \{\par
00496     {\cf18 unsigned} {\cf18 char} tmptail;\par
00497     {\cf18 unsigned} {\cf18 char} data;\par
00498     {\cf18 unsigned} {\cf18 char} lastRxError;\par
00499 \par
00500 \par
00501     {\cf19 if} (UART_RxHead == UART_RxTail)\par
00502     \{\par
00503         {\cf19 return} UART_NO_DATA; {\cf20 /* no data available */}\par
00504     \}\par
00505 \par
00506     {\cf20 /* calculate buffer index */}\par
00507     tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;\par
00508 \par
00509     {\cf20 /* get data from receive buffer */}\par
00510     data        = UART_RxBuf[tmptail];\par
00511     lastRxError = UART_LastRxError;\par
00512 \par
00513     {\cf20 /* store buffer index */}\par
00514     UART_RxTail = tmptail;\par
00515 \par
00516     UART_LastRxError = 0;\par
00517     {\cf19 return} (lastRxError << 8) + data;\par
00518 \}{\cf20 /* uart_getc */}\par
00519 \par
00520 {\cf20 /*************************************************************************}\par
00521 {\cf20  * Function: uart_putc()}\par
00522 {\cf20  * Purpose:  write byte to ringbuffer for transmitting via UART}\par
00523 {\cf20  * Input:    byte to be transmitted}\par
00524 {\cf20  * Returns:  none}\par
00525 {\cf20  **************************************************************************/}\par
00526 {\cf18 void} uart_putc({\cf18 unsigned} {\cf18 char} data)\par
00527 \{\par
00528     {\cf18 unsigned} {\cf18 char} tmphead;\par
00529 \par
00530 \par
00531     tmphead = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;\par
00532 \par
00533     {\cf19 while} (tmphead == UART_TxTail)\par
00534     \{\par
00535         ;{\cf20 /* wait for free space in buffer */}\par
00536     \}\par
00537 \par
00538     UART_TxBuf[tmphead] = data;\par
00539     UART_TxHead         = tmphead;\par
00540 \par
00541     {\cf20 /* enable UDRE interrupt */}\par
00542     UART0_CONTROL |= _BV(UART0_UDRIE);\par
00543 \}{\cf20 /* uart_putc */}\par
00544 \par
00545 {\cf20 /*************************************************************************}\par
00546 {\cf20  * Function: uart_puts()}\par
00547 {\cf20  * Purpose:  transmit string to UART}\par
00548 {\cf20  * Input:    string to be transmitted}\par
00549 {\cf20  * Returns:  none}\par
00550 {\cf20  **************************************************************************/}\par
00551 {\cf18 void} uart_puts({\cf17 const} {\cf18 char} *s)\par
00552 \{\par
00553     {\cf19 while} (*s)\par
00554         uart_putc(*s++);\par
00555 \}{\cf20 /* uart_puts */}\par
00556 \par
00557 {\cf20 /*************************************************************************}\par
00558 {\cf20  * Function: uart_puts_p()}\par
00559 {\cf20  * Purpose:  transmit string from program memory to UART}\par
00560 {\cf20  * Input:    program memory string to be transmitted}\par
00561 {\cf20  * Returns:  none}\par
00562 {\cf20  **************************************************************************/}\par
00563 {\cf18 void} uart_puts_p({\cf17 const} {\cf18 char} *progmem_s)\par
00564 \{\par
00565     {\cf17 register} {\cf18 char} c;\par
00566 \par
00567     {\cf19 while} ( (c = pgm_read_byte(progmem_s++)) )\par
00568         uart_putc(c);\par
00569 \}{\cf20 /* uart_puts_p */}\par
00570 \par
00571 {\cf20 /*}\par
00572 {\cf20  * these functions are only for ATmegas with two USART}\par
00573 {\cf20  */}\par
00574 {\cf21 #if defined( ATMEGA_USART1 )}\par
00575 \par
00576 ISR(UART1_RECEIVE_INTERRUPT)\par
00577 \par
00578 {\cf20 /*************************************************************************}\par
00579 {\cf20  * Function: UART1 Receive Complete interrupt}\par
00580 {\cf20  * Purpose:  called when the UART1 has received a character}\par
00581 {\cf20  **************************************************************************/}\par
00582 \{\par
00583     {\cf18 unsigned} {\cf18 char} tmphead;\par
00584     {\cf18 unsigned} {\cf18 char} data;\par
00585     {\cf18 unsigned} {\cf18 char} usr;\par
00586     {\cf18 unsigned} {\cf18 char} lastRxError;\par
00587 \par
00588 \par
00589     {\cf20 /* read UART status register and UART data register */}\par
00590     usr  = UART1_STATUS;\par
00591     data = UART1_DATA;\par
00592 \par
00593     {\cf20 /* get FEn (Frame Error) DORn (Data OverRun) UPEn (USART Parity Error) bits */}\par
00594     lastRxError = usr & (_BV(FE1) | _BV(DOR1) | _BV(UPE1) );\par
00595 \par
00596     {\cf20 /* calculate buffer index */}\par
00597     tmphead = ( UART1_RxHead + 1) & UART_RX_BUFFER_MASK;\par
00598 \par
00599     {\cf19 if} (tmphead == UART1_RxTail)\par
00600     \{\par
00601         {\cf20 /* error: receive buffer overflow */}\par
00602         lastRxError = UART_BUFFER_OVERFLOW >> 8;\par
00603     \}\par
00604     {\cf19 else}\par
00605     \{\par
00606         {\cf20 /* store new index */}\par
00607         UART1_RxHead = tmphead;\par
00608         {\cf20 /* store received data in buffer */}\par
00609         UART1_RxBuf[tmphead] = data;\par
00610     \}\par
00611     UART1_LastRxError |= lastRxError;\par
00612 \}\par
00613 \par
00614 \par
00615 ISR(UART1_TRANSMIT_INTERRUPT)\par
00616 \par
00617 {\cf20 /*************************************************************************}\par
00618 {\cf20  * Function: UART1 Data Register Empty interrupt}\par
00619 {\cf20  * Purpose:  called when the UART1 is ready to transmit the next byte}\par
00620 {\cf20  **************************************************************************/}\par
00621 \{\par
00622     {\cf18 unsigned} {\cf18 char} tmptail;\par
00623 \par
00624 \par
00625     {\cf19 if} (UART1_TxHead != UART1_TxTail)\par
00626     \{\par
00627         {\cf20 /* calculate and store new buffer index */}\par
00628         tmptail      = (UART1_TxTail + 1) & UART_TX_BUFFER_MASK;\par
00629         UART1_TxTail = tmptail;\par
00630         {\cf20 /* get one byte from buffer and write it to UART */}\par
00631         UART1_DATA = UART1_TxBuf[tmptail]; {\cf20 /* start transmission */}\par
00632     \}\par
00633     {\cf19 else}\par
00634     \{\par
00635         {\cf20 /* tx buffer empty, disable UDRE interrupt */}\par
00636         UART1_CONTROL &= ~_BV(UART1_UDRIE);\par
00637     \}\par
00638 \}\par
00639 \par
00640 \par
00641 {\cf20 /*************************************************************************}\par
00642 {\cf20  * Function: uart1_init()}\par
00643 {\cf20  * Purpose:  initialize UART1 and set baudrate}\par
00644 {\cf20  * Input:    baudrate using macro UART_BAUD_SELECT()}\par
00645 {\cf20  * Returns:  none}\par
00646 {\cf20  **************************************************************************/}\par
00647 {\cf18 void} uart1_init({\cf18 unsigned} {\cf18 int} baudrate)\par
00648 \{\par
00649     UART1_TxHead = 0;\par
00650     UART1_TxTail = 0;\par
00651     UART1_RxHead = 0;\par
00652     UART1_RxTail = 0;\par
00653 \par
00654 {\cf21     # ifdef UART_TEST}\par
00655 {\cf21     #  ifndef UART1_BIT_U2X}\par
00656 {\cf21     #   warning "UART1_BIT_U2X not defined"}\par
00657 {\cf21     #  endif}\par
00658 {\cf21     #  ifndef UART1_UBRRH}\par
00659 {\cf21     #   warning "UART1_UBRRH not defined"}\par
00660 {\cf21     #  endif}\par
00661 {\cf21     #  ifndef UART1_CONTROLC}\par
00662 {\cf21     #   warning "UART1_CONTROLC not defined"}\par
00663 {\cf21     #  endif}\par
00664 {\cf21     #  if defined(URSEL) || defined(URSEL1)}\par
00665 {\cf21     #   ifndef UART1_BIT_URSEL}\par
00666 {\cf21     #    warning "UART1_BIT_URSEL not defined"}\par
00667 {\cf21     #   endif}\par
00668 {\cf21     #  endif}\par
00669 {\cf21     # endif }{\cf20 /* ifdef UART_TEST */}{\cf21 }\par
00670 \par
00671     {\cf20 /* Set baud rate */}\par
00672     {\cf19 if} (baudrate & 0x8000)\par
00673     \{\par
00674 {\cf21         # if UART1_BIT_U2X}\par
00675         UART1_STATUS = (1 << UART1_BIT_U2X); {\cf20 // Enable 2x speed}\par
00676 {\cf21         # endif}\par
00677     \}\par
00678     UART1_UBRRH = ({\cf18 unsigned} char) ((baudrate >> 8) & 0x80);\par
00679     UART1_UBRRL = ({\cf18 unsigned} char) baudrate;\par
00680 \par
00681     {\cf20 /* Enable USART receiver and transmitter and receive complete interrupt */}\par
00682     UART1_CONTROL = _BV(UART1_BIT_RXCIE) | (1 << UART1_BIT_RXEN) | (1 << UART1_BIT_TXEN);\par
00683 \par
00684     {\cf20 /* Set frame format: asynchronous, 8data, no parity, 1stop bit */}\par
00685 {\cf21     # ifdef UART1_BIT_URSEL}\par
00686     UART1_CONTROLC = (1 << UART1_BIT_URSEL) | (1 << UART1_BIT_UCSZ1) | (1 << UART1_BIT_UCSZ0);\par
00687 {\cf21     # else}\par
00688     UART1_CONTROLC = (1 << UART1_BIT_UCSZ1) | (1 << UART1_BIT_UCSZ0);\par
00689 {\cf21     # endif}\par
00690 \}{\cf20 /* uart_init */}\par
00691 \par
00692 {\cf20 /*************************************************************************}\par
00693 {\cf20  * Function: uart1_getc()}\par
00694 {\cf20  * Purpose:  return byte from ringbuffer}\par
00695 {\cf20  * Returns:  lower byte:  received byte from ringbuffer}\par
00696 {\cf20  *        higher byte: last receive error}\par
00697 {\cf20  **************************************************************************/}\par
00698 {\cf18 unsigned} {\cf18 int} uart1_getc({\cf18 void})\par
00699 \{\par
00700     {\cf18 unsigned} {\cf18 char} tmptail;\par
00701     {\cf18 unsigned} {\cf18 int} data;\par
00702     {\cf18 unsigned} {\cf18 char} lastRxError;\par
00703 \par
00704 \par
00705     {\cf19 if} (UART1_RxHead == UART1_RxTail)\par
00706     \{\par
00707         {\cf19 return} UART_NO_DATA; {\cf20 /* no data available */}\par
00708     \}\par
00709 \par
00710     {\cf20 /* calculate buffer index */}\par
00711     tmptail = (UART1_RxTail + 1) & UART_RX_BUFFER_MASK;\par
00712 \par
00713     {\cf20 /* get data from receive buffer */}\par
00714     data        = UART1_RxBuf[tmptail];\par
00715     lastRxError = UART1_LastRxError;\par
00716 \par
00717     {\cf20 /* store buffer index */}\par
00718     UART1_RxTail = tmptail;\par
00719 \par
00720     UART1_LastRxError = 0;\par
00721     {\cf19 return} (lastRxError << 8) + data;\par
00722 \}{\cf20 /* uart1_getc */}\par
00723 \par
00724 {\cf20 /*************************************************************************}\par
00725 {\cf20  * Function: uart1_putc()}\par
00726 {\cf20  * Purpose:  write byte to ringbuffer for transmitting via UART}\par
00727 {\cf20  * Input:    byte to be transmitted}\par
00728 {\cf20  * Returns:  none}\par
00729 {\cf20  **************************************************************************/}\par
00730 {\cf18 void} uart1_putc({\cf18 unsigned} {\cf18 char} data)\par
00731 \{\par
00732     {\cf18 unsigned} {\cf18 char} tmphead;\par
00733 \par
00734 \par
00735     tmphead = (UART1_TxHead + 1) & UART_TX_BUFFER_MASK;\par
00736 \par
00737     {\cf19 while} (tmphead == UART1_TxTail)\par
00738     \{\par
00739         ;{\cf20 /* wait for free space in buffer */}\par
00740     \}\par
00741 \par
00742     UART1_TxBuf[tmphead] = data;\par
00743     UART1_TxHead         = tmphead;\par
00744 \par
00745     {\cf20 /* enable UDRE interrupt */}\par
00746     UART1_CONTROL |= _BV(UART1_UDRIE);\par
00747 \}{\cf20 /* uart1_putc */}\par
00748 \par
00749 {\cf20 /*************************************************************************}\par
00750 {\cf20  * Function: uart1_puts()}\par
00751 {\cf20  * Purpose:  transmit string to UART1}\par
00752 {\cf20  * Input:    string to be transmitted}\par
00753 {\cf20  * Returns:  none}\par
00754 {\cf20  **************************************************************************/}\par
00755 {\cf18 void} uart1_puts({\cf17 const} {\cf18 char} *s)\par
00756 \{\par
00757     {\cf19 while} (*s)\par
00758         uart1_putc(*s++);\par
00759 \}{\cf20 /* uart1_puts */}\par
00760 \par
00761 {\cf20 /*************************************************************************}\par
00762 {\cf20  * Function: uart1_puts_p()}\par
00763 {\cf20  * Purpose:  transmit string from program memory to UART1}\par
00764 {\cf20  * Input:    program memory string to be transmitted}\par
00765 {\cf20  * Returns:  none}\par
00766 {\cf20  **************************************************************************/}\par
00767 {\cf18 void} uart1_puts_p({\cf17 const} {\cf18 char} *progmem_s)\par
00768 \{\par
00769     {\cf17 register} {\cf18 char} c;\par
00770 \par
00771     {\cf19 while} ( (c = pgm_read_byte(progmem_s++)) )\par
00772         uart1_putc(c);\par
00773 \}{\cf20 /* uart1_puts_p */}\par
00774 \par
00775 {\cf21 #endif }{\cf20 /* if defined( ATMEGA_USART1 ) */}{\cf21 }\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/uart/uart.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/uart/uart.h}
{\xe \v lib/uart/uart.h}
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <avr/pgmspace.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_BAUD_SELECT}(baudRate,  xtalCpu)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
UART Baudrate Expression. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_BAUD_SELECT_DOUBLE_SPEED}(baudRate,  xtalCpu)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
UART Baudrate Expression for ATmega double speed mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_RX_BUFFER_SIZE}\~ 128\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of the circular receive buffer, must be power of 2. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_TX_BUFFER_SIZE}\~ 128\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of the circular transmit buffer, must be power of 2. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_FRAME_ERROR}\~ 0x1000\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Framing Error by UART. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_OVERRUN_ERROR}\~ 0x0800\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overrun condition by UART. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_PARITY_ERROR}\~ 0x0400\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parity Error by UART. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_BUFFER_OVERFLOW}\~ 0x0200\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
receive ringbuffer overflow }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_NO_DATA}\~ 0x0100\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
no receive data available }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b uart_puts_P}(__s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macro to automatically put a string constant into program memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b uart1_puts_P}(__s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macro to automatically put a string constant into program memory. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart_init} (unsigned int baudrate)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize UART and set baudrate. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b uart_getc} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get received byte from ringbuffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart_putc} (unsigned char {\b data})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put byte to ringbuffer for transmitting via UART. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart_puts} (const char *s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put string to ringbuffer for transmitting via UART. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart_puts_p} (const char *s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put string from program memory to ringbuffer for transmitting via UART. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart1_init} (unsigned int baudrate)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize USART1 (only available on selected ATmegas). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b uart1_getc} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get received byte of USART1 from ringbuffer. (only available on selected ATmega). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart1_putc} (unsigned char {\b data})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put byte to ringbuffer for transmitting via USART1 (only available on selected ATmega). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart1_puts} (const char *s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put string to ringbuffer for transmitting via USART1 (only available on selected ATmega). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uart1_puts_p} (const char *s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put string from program memory to ringbuffer for transmitting via USART1 (only available on selected ATmega). }{
}\par
}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
uart.h\par \pard\plain 
{\tc\tcl2 \v lib/uart/uart.h}
{\xe \v lib/uart/uart.h}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef UART_H}\par
00002 {\cf21 # define UART_H}\par
00003 \par
00004 {\cf20 /************************************************************************}\par
00005 {\cf20 *  Title:    Interrupt UART library with receive/transmit circular buffers}\par
00006 {\cf20 *  Author:   Peter Fleury <pfleury@gmx.ch>  http://tinyurl.com/peterfleury}\par
00007 {\cf20 *  File:     $Id: uart.h,v 1.13 2015/01/11 13:53:25 peter Exp $}\par
00008 {\cf20 *  Software: AVR-GCC 4.x, AVR Libc 1.4 or higher}\par
00009 {\cf20 *  Hardware: any AVR with built-in UART/USART}\par
00010 {\cf20 *  Usage:    see Doxygen manual}\par
00011 {\cf20 *}\par
00012 {\cf20 *  LICENSE:}\par
00013 {\cf20 *   Copyright (C) 2015 Peter Fleury, GNU General Public License Version 3}\par
00014 {\cf20 *}\par
00015 {\cf20 *   This program is free software; you can redistribute it and/or modify}\par
00016 {\cf20 *   it under the terms of the GNU General Public License as published by}\par
00017 {\cf20 *   the Free Software Foundation; either version 3 of the License, or}\par
00018 {\cf20 *   any later version.}\par
00019 {\cf20 *}\par
00020 {\cf20 *   This program is distributed in the hope that it will be useful,}\par
00021 {\cf20 *   but WITHOUT ANY WARRANTY; without even the implied warranty of}\par
00022 {\cf20 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}\par
00023 {\cf20 *   GNU General Public License for more details.}\par
00024 {\cf20 *}\par
00025 {\cf20 ************************************************************************/}\par
00026 \par
00049 \par
00050 \par
00051 {\cf21 #include <avr/pgmspace.h>}\par
00052 \par
00053 {\cf21 #if (__GNUC__ * 100 + __GNUC_MINOR__) < 405}\par
00054 {\cf21 # error "This library requires AVR-GCC 4.5 or later, update to newer AVR-GCC compiler !"}\par
00055 {\cf21 #endif}\par
00056 \par
00057 \par
00059 \par
00060 \par
00061 {\cf20 /*}\par
00062 {\cf20 ** constants and macros}\par
00063 {\cf20 */}\par
00064 \par
00065 \par
00070 {\cf21 #define UART_BAUD_SELECT(baudRate, xtalCpu) (((xtalCpu) + 8UL * (baudRate)) / (16UL * (baudRate)) - 1UL)}\par
00071 \par
00076 {\cf21 #define UART_BAUD_SELECT_DOUBLE_SPEED(baudRate, xtalCpu) ( ((((xtalCpu) + 4UL * (baudRate)) / (8UL * (baudRate)) - 1UL)) | 0x8000)}\par
00077 \par
00083 {\cf21 #ifndef UART_RX_BUFFER_SIZE}\par
00084 {\cf21 # define UART_RX_BUFFER_SIZE 128}\par
00085 {\cf21 #endif}\par
00086 \par
00092 {\cf21 #ifndef UART_TX_BUFFER_SIZE}\par
00093 {\cf21 # define UART_TX_BUFFER_SIZE 128}\par
00094 {\cf21 #endif}\par
00095 {\cf20 // #define TX_NEWLINE \{transmitByte(0x0d); transmitByte(0x0a);\}}\par
00096 {\cf20 /* test if the size of the circular buffers fits into SRAM */}\par
00097 {\cf21 #if ( (UART_RX_BUFFER_SIZE + UART_TX_BUFFER_SIZE) >= (RAMEND - 0x60 ) )}\par
00098 {\cf21 # error "size of UART_RX_BUFFER_SIZE + UART_TX_BUFFER_SIZE larger than size of SRAM"}\par
00099 {\cf21 #endif}\par
00100 \par
00101 {\cf20 /*}\par
00102 {\cf20 ** high byte error return code of uart_getc()}\par
00103 {\cf20 */}\par
00104 {\cf21 #define UART_FRAME_ERROR     0x1000 }{\cf21 }\par
00105 {\cf21 #define UART_OVERRUN_ERROR   0x0800 }{\cf21 }\par
00106 {\cf21 #define UART_PARITY_ERROR    0x0400 }{\cf21 }\par
00107 {\cf21 #define UART_BUFFER_OVERFLOW 0x0200 }{\cf21 }\par
00108 {\cf21 #define UART_NO_DATA         0x0100 }{\cf21 }\par
00109 \par
00110 \par
00111 {\cf20 /*}\par
00112 {\cf20 ** function prototypes}\par
00113 {\cf20 */}\par
00114 \par
00120 {\cf17 extern} {\cf18 void} uart_init({\cf18 unsigned} {\cf18 int} baudrate);\par
00121 \par
00122 \par
00147 {\cf17 extern} {\cf18 unsigned} {\cf18 int} uart_getc({\cf18 void});\par
00148 \par
00149 \par
00155 {\cf17 extern} {\cf18 void} uart_putc({\cf18 unsigned} {\cf18 char} data);\par
00156 \par
00157 \par
00168 {\cf17 extern} {\cf18 void} uart_puts({\cf17 const} {\cf18 char} *s);\par
00169 \par
00170 \par
00182 {\cf17 extern} {\cf18 void} uart_puts_p({\cf17 const} {\cf18 char} *s);\par
00183 \par
00187 {\cf21 #define uart_puts_P(__s) uart_puts_p(PSTR(__s))}\par
00188 \par
00189 \par
00191 {\cf17 extern} {\cf18 void} uart1_init({\cf18 unsigned} {\cf18 int} baudrate);\par
00193 {\cf17 extern} {\cf18 unsigned} {\cf18 int} uart1_getc({\cf18 void});\par
00195 {\cf17 extern} {\cf18 void} uart1_putc({\cf18 unsigned} {\cf18 char} data);\par
00197 {\cf17 extern} {\cf18 void} uart1_puts({\cf17 const} {\cf18 char} *s);\par
00199 {\cf17 extern} {\cf18 void} uart1_puts_p({\cf17 const} {\cf18 char} *s);\par
00201 {\cf21 #define uart1_puts_P(__s) uart1_puts_p(PSTR(__s))}\par
00202 \par
00204 \par
00205 \par
00206 {\cf21 #endif }{\cf20 // UART_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/uart/uart_compat.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/uart/uart_compat.h}
{\xe \v lib/uart/uart_compat.h}
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <avr/pgmspace.h>}\par
{\f2 #include <uart.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b transmitByte}({\b data})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compatibility layer for old UART function names Maps transmitByte/transmitString to Peter Fleury UART library. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b transmitString}(str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TX_NEWLINE}\~ {\b uart_puts}("\\r\\n")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BYTE}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INT}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LONG}\~ 2\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BYTE\:uart_compat.h}
{\xe \v uart_compat.h\:BYTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BYTE\~ 0}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b uart_compat.h}.}\par
}
{\xe \v INT\:uart_compat.h}
{\xe \v uart_compat.h\:INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INT\~ 1}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b uart_compat.h}.}\par
}
{\xe \v LONG\:uart_compat.h}
{\xe \v uart_compat.h\:LONG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LONG\~ 2}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b uart_compat.h}.}\par
}
{\xe \v transmitByte\:uart_compat.h}
{\xe \v uart_compat.h\:transmitByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define transmitByte( {\b data})}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid uart_putc(data)\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compatibility layer for old UART function names Maps transmitByte/transmitString to Peter Fleury UART library. }}\par
{
Definition at line {\b 13} of file {\b uart_compat.h}.}\par
}
{\xe \v transmitString\:uart_compat.h}
{\xe \v uart_compat.h\:transmitString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define transmitString( str)}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid uart_puts(({\cf18 char}*)(str))\par
}
{
Definition at line {\b 16} of file {\b uart_compat.h}.}\par
}
{\xe \v TX_NEWLINE\:uart_compat.h}
{\xe \v uart_compat.h\:TX_NEWLINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TX_NEWLINE\~ {\b uart_puts}("\\r\\n")}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b uart_compat.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
uart_compat.h\par \pard\plain 
{\tc\tcl2 \v lib/uart/uart_compat.h}
{\xe \v lib/uart/uart_compat.h}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef UART_COMPAT_H}\par
00002 {\cf21 #define UART_COMPAT_H}\par
00003 \par
00004 {\cf21 #include <avr/pgmspace.h>}\par
00005 {\cf21 #include <uart.h>}\par
00006 \par
00011 \par
00012 {\cf20 // Single byte transmission}\par
00013 {\cf21 #define transmitByte(data) uart_putc(data)}\par
00014 \par
00015 {\cf20 // String transmission from RAM}\par
00016 {\cf21 #define transmitString(str) uart_puts((char*)(str))}\par
00017 \par
00018 {\cf20 // Newline transmission}\par
00019 {\cf21 #define TX_NEWLINE uart_puts("\\r\\n")}\par
00020 \par
00025 {\cf17 static} {\cf17 inline} {\cf18 void} transmitString_P({\cf17 const} {\cf18 char}* {\cf18 string})\par
00026 \{\par
00027     {\cf18 char} c;\par
00028     {\cf19 while} ((c = pgm_read_byte({\cf18 string}++)))\par
00029         uart_putc(c);\par
00030 \}\par
00031 \par
00036 {\cf17 static} {\cf17 inline} {\cf18 void} transmitHex({\cf18 unsigned} {\cf18 char} type, {\cf18 unsigned} {\cf18 long} value)\par
00037 \{\par
00038     {\cf18 char} hex_string[12];\par
00039     {\cf18 char} *ptr = hex_string;\par
00040     {\cf18 unsigned} {\cf18 char} nibble;\par
00041     {\cf18 unsigned} {\cf18 char} i;\par
00042     {\cf18 unsigned} {\cf18 char} digits;\par
00043     \par
00044     {\cf20 // Determine number of digits based on type}\par
00045     {\cf19 if}(type == 0) {\cf20 // BYTE}\par
00046         digits = 2;\par
00047     {\cf19 else} {\cf19 if}(type == 1) {\cf20 // INT/WORD}\par
00048         digits = 4;\par
00049     {\cf19 else} {\cf20 // LONG}\par
00050         digits = 8;\par
00051     \par
00052     uart_puts({\cf22 "0x"});\par
00053     \par
00054     {\cf20 // Convert to hex string}\par
00055     {\cf19 for}(i = 0; i < digits; i++)\par
00056     \{\par
00057         nibble = (value >> ((digits - 1 - i) * 4)) & 0x0F;\par
00058         {\cf19 if}(nibble < 10)\par
00059             uart_putc({\cf23 '0'} + nibble);\par
00060         {\cf19 else}\par
00061             uart_putc({\cf23 'A'} + nibble - 10);\par
00062     \}\par
00063 \}\par
00064 \par
00065 {\cf20 // Type definitions for transmitHex}\par
00066 {\cf21 #define BYTE 0}\par
00067 {\cf21 #define INT  1}\par
00068 {\cf21 #define LONG 2}\par
00069 \par
00070 {\cf21 #endif }{\cf20 // UART_COMPAT_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/bme.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/bme.c}
{\xe \v src/bme.c}
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <avr/io.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <util/delay.h>}\par
{\f2 #include "twi.h"}\par
{\f2 #include "bme280.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bme_init_simple} (struct {\b bme280_dev} *dev, uint8_t *dev_addr_ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bme_read_once} (struct {\b bme280_dev} *dev, int32_t *t100, uint32_t *press_pa, uint32_t *hum_x1024)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v bme_init_simple\:bme.c}
{\xe \v bme.c\:bme_init_simple}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int bme_init_simple (struct {\b bme280_dev} * dev, uint8_t * dev_addr_ptr)}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b bme.c}.}\par
}
{\xe \v bme_read_once\:bme.c}
{\xe \v bme.c\:bme_read_once}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int bme_read_once (struct {\b bme280_dev} * dev, int32_t * t100, uint32_t * press_pa, uint32_t * hum_x1024)}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b bme.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bme.c\par \pard\plain 
{\tc\tcl2 \v src/bme.c}
{\xe \v src/bme.c}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <avr/io.h>}\par
00002 {\cf21 #include <stdio.h>}\par
00003 {\cf21 #include <math.h>}\par
00004 {\cf21 #include <util/delay.h>}\par
00005 {\cf21 #include "twi.h"}\par
00006 {\cf21 #include "bme280.h"}\par
00007 \par
00008 {\cf20 /* Expose simple init + single-measure API for integration into a combined main}\par
00009 {\cf20  * The file provides:}\par
00010 {\cf20  *  - int bme_init_simple(struct bme280_dev *dev, uint8_t dev_addr)}\par
00011 {\cf20  *  - int bme_read_once(struct bme280_dev *dev, int32_t *t100, uint32_t *press_pa, uint32_t *hum_x1024)}\par
00012 {\cf20  *}\par
00013 {\cf20  * Note: this module uses the project's TWI helper functions (twi.h) for I2C}\par
00014 {\cf20  * callbacks. The caller must call `twi_init()` before `bme_init_simple()` and}\par
00015 {\cf20  * is responsible for UART output.}\par
00016 {\cf20  */}\par
00017 \par
00018 {\cf20 /* Manufacturer integer compensation functions (from Bosch Sensortec). Returns:}\par
00019 {\cf20  *  - Temperature: int32 in 0.01 degC}\par
00020 {\cf20  *  - Pressure: uint32 in Q24.8 (Pa * 256)}\par
00021 {\cf20  *  - Humidity: uint32 in Q22.10 (percent * 1024)}\par
00022 {\cf20  */}\par
00023 \par
00024 {\cf17 static} int32_t BME280_compensate_T_int32(int32_t adc_T, {\cf17 struct} bme280_calib_data *calib)\par
00025 \{\par
00026     int32_t var1, var2, T;\par
00027     var1 = ((((adc_T >> 3) - ((int32_t)calib->dig_t1 << 1))) * ((int32_t)calib->dig_t2)) >> 11;\par
00028     var2 = (((((adc_T >> 4) - ((int32_t)calib->dig_t1)) * ((adc_T >> 4) - ((int32_t)calib->dig_t1))) >> 12) *\par
00029             ((int32_t)calib->dig_t3)) >> 14;\par
00030     calib->t_fine = var1 + var2;\par
00031     T = (calib->t_fine * 5 + 128) >> 8;\par
00032     {\cf19 return} T;\par
00033 \}\par
00034 \par
00035 {\cf17 static} uint32_t BME280_compensate_P_int64(int32_t adc_P, {\cf17 struct} bme280_calib_data *calib)\par
00036 \{\par
00037     int64_t var1, var2, p;\par
00038     var1 = ((int64_t)calib->t_fine) - 128000;\par
00039     var2 = var1 * var1 * (int64_t)calib->dig_p6;\par
00040     var2 = var2 + ((var1 * (int64_t)calib->dig_p5) << 17);\par
00041     var2 = var2 + (((int64_t)calib->dig_p4) << 35);\par
00042     var1 = ((var1 * var1 * (int64_t)calib->dig_p3) >> 8) + ((var1 * (int64_t)calib->dig_p2) << 12);\par
00043     var1 = (((((int64_t)1) << 47) + var1) * ((int64_t)calib->dig_p1)) >> 33;\par
00044     {\cf19 if} (var1 == 0)\par
00045     \{\par
00046         {\cf19 return} 0; {\cf20 /* avoid exception caused by division by zero */}\par
00047     \}\par
00048     p = 1048576 - adc_P;\par
00049     p = (((p << 31) - var2) * 3125) / var1;\par
00050     var1 = (((int64_t)calib->dig_p9) * (p >> 13) * (p >> 13)) >> 25;\par
00051     var2 = (((int64_t)calib->dig_p8) * p) >> 19;\par
00052     p = ((p + var1 + var2) >> 8) + (((int64_t)calib->dig_p7) << 4);\par
00053     {\cf19 return} (uint32_t)p;\par
00054 \}\par
00055 \par
00056 {\cf17 static} uint32_t bme280_compensate_H_int32(int32_t adc_H, {\cf17 struct} bme280_calib_data *calib)\par
00057 \{\par
00058     int32_t v_x1_u32r;\par
00059     v_x1_u32r = (calib->t_fine - ((int32_t)76800));\par
00060     v_x1_u32r = (((((adc_H << 14) - (((int32_t)calib->dig_h4) << 20) - (((int32_t)calib->dig_h5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *\par
00061                  (((((((v_x1_u32r * ((int32_t)calib->dig_h6)) >> 10) * (((v_x1_u32r * ((int32_t)calib->dig_h3)) >> 11) + ((int32_t)32768))) >> 10) + ((int32_t)2097152)) * ((int32_t)calib->dig_h2) + 8192) >> 14));\par
00062     v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((int32_t)calib->dig_h1)) >> 4));\par
00063     v_x1_u32r = (v_x1_u32r < 0 ? 0 : v_x1_u32r);\par
00064     v_x1_u32r = (v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r);\par
00065     {\cf19 return} (uint32_t)(v_x1_u32r >> 12);\par
00066 \}\par
00067 \par
00068 {\cf20 /* Adapter callbacks for Bosch driver (use dev->intf_ptr as pointer to 7-bit I2C address)}\par
00069 {\cf20  * These are file-local and used by bme_init_simple/bme_read_once.}\par
00070 {\cf20  */}\par
00071 {\cf17 static} BME280_INTF_RET_TYPE user_i2c_read(uint8_t reg_addr, uint8_t *reg_data, uint32_t len, {\cf18 void} *intf_ptr)\par
00072 \{\par
00073     uint8_t dev_addr = *((uint8_t *)intf_ptr);\par
00074     {\cf19 if} (len == 0 || reg_data == NULL)\par
00075         {\cf19 return} BME280_E_INVALID_LEN;\par
00076 \par
00077     twi_readfrom_mem_into(dev_addr, reg_addr, ({\cf17 volatile} uint8_t *)reg_data, (uint8_t)len);\par
00078     {\cf19 return} BME280_INTF_RET_SUCCESS;\par
00079 \}\par
00080 \par
00081 {\cf17 static} BME280_INTF_RET_TYPE user_i2c_write(uint8_t reg_addr, {\cf17 const} uint8_t *reg_data, uint32_t len, {\cf18 void} *intf_ptr)\par
00082 \{\par
00083     uint8_t dev_addr = *((uint8_t *)intf_ptr);\par
00084     twi_start();\par
00085     {\cf19 if} (twi_write((dev_addr << 1) | TWI_WRITE) != 0) \{ twi_stop(); {\cf19 return} BME280_E_COMM_FAIL; \}\par
00086     {\cf19 if} (twi_write(reg_addr) != 0) \{ twi_stop(); {\cf19 return} BME280_E_COMM_FAIL; \}\par
00087     {\cf19 for} (uint32_t i = 0; i < len; i++)\par
00088     \{\par
00089         {\cf19 if} (twi_write(reg_data[i]) != 0) \{ twi_stop(); {\cf19 return} BME280_E_COMM_FAIL; \}\par
00090     \}\par
00091     twi_stop();\par
00092     {\cf19 return} BME280_INTF_RET_SUCCESS;\par
00093 \}\par
00094 \par
00095 {\cf17 static} {\cf18 void} user_delay_us(uint32_t period, {\cf18 void} *intf_ptr)\par
00096 \{\par
00097     (void)intf_ptr;\par
00098     {\cf19 while} (period >= 1000)\par
00099     \{\par
00100         _delay_ms(1);\par
00101         period -= 1000;\par
00102     \}\par
00103     {\cf19 while} (period--)\par
00104         _delay_us(1);\par
00105 \}\par
00106 \par
00107 {\cf20 /* Initialize BME280 device and basic settings. Caller must call `twi_init()` first.}\par
00108 {\cf20  * dev_addr: 7-bit I2C address (e.g. BME280_I2C_ADDR_PRIM)}\par
00109 {\cf20  * Returns BME280_OK (0) on success or negative error code.}\par
00110 {\cf20  */}\par
00111 {\cf18 int} bme_init_simple({\cf17 struct} bme280_dev *dev, uint8_t *dev_addr_ptr)\par
00112 \{\par
00113     dev->intf = BME280_I2C_INTF;\par
00114     dev->intf_ptr = dev_addr_ptr; {\cf20 /* use caller-owned address storage */}\par
00115     dev->read = user_i2c_read;\par
00116     dev->write = user_i2c_write;\par
00117     dev->delay_us = user_delay_us;\par
00118 \par
00119     int8_t rslt = bme280_init(dev);\par
00120     {\cf19 if} (rslt != BME280_OK)\par
00121     \{\par
00122         {\cf19 return} rslt;\par
00123     \}\par
00124 \par
00125     {\cf20 /* Configure sensor: oversampling x1 for T/P/H */}\par
00126     {\cf17 struct }bme280_settings settings;\par
00127     settings.osr_h = BME280_OVERSAMPLING_1X;\par
00128     settings.osr_p = BME280_OVERSAMPLING_1X;\par
00129     settings.osr_t = BME280_OVERSAMPLING_1X;\par
00130     settings.filter = BME280_FILTER_COEFF_OFF;\par
00131     settings.standby_time = BME280_STANDBY_TIME_125_MS;\par
00132 \par
00133     rslt = bme280_set_sensor_settings(BME280_SEL_ALL_SETTINGS, &settings, dev);\par
00134     {\cf19 if} (rslt != BME280_OK)\par
00135     \{\par
00136         {\cf19 return} rslt;\par
00137     \}\par
00138     {\cf19 return} BME280_OK;\par
00139 \}\par
00140 \par
00141 {\cf20 /* Perform one forced measurement and return compensated values.}\par
00142 {\cf20  * t100: temperature in 0.01 degC}\par
00143 {\cf20  * press_pa: pressure in Pa}\par
00144 {\cf20  * hum_x1024: humidity in percent * 1024}\par
00145 {\cf20  * Returns 0 on success, non-zero on failure.}\par
00146 {\cf20  */}\par
00147 {\cf18 int} bme_read_once({\cf17 struct} bme280_dev *dev, int32_t *t100, uint32_t *press_pa, uint32_t *hum_x1024)\par
00148 \{\par
00149     {\cf20 /* Trigger one-shot measurement (forced) */}\par
00150     int8_t rslt = bme280_set_sensor_mode(BME280_POWERMODE_FORCED, dev);\par
00151     {\cf19 if} (rslt != BME280_OK) {\cf19 return} -1;\par
00152 \par
00153     {\cf20 /* Wait required measurement time */}\par
00154     {\cf17 struct }bme280_settings settings;\par
00155     {\cf20 /* read back current settings to compute delay}\par
00156 {\cf20      * If reading settings fails, fall back to a conservative delay}\par
00157 {\cf20      */}\par
00158     rslt = bme280_get_sensor_settings(&settings, dev);\par
00159     uint32_t meas_delay_us = 0;\par
00160     {\cf19 if} (rslt == BME280_OK)\par
00161         bme280_cal_meas_delay(&meas_delay_us, &settings);\par
00162     {\cf19 else}\par
00163         meas_delay_us = 10000; {\cf20 /* 10 ms conservative */}\par
00164 \par
00165     user_delay_us(meas_delay_us, dev->intf_ptr);\par
00166 \par
00167     {\cf20 /* Read raw measurement registers (8 bytes: press(3), temp(3), hum(2)) */}\par
00168     uint8_t data[8];\par
00169     rslt = bme280_get_regs(BME280_REG_DATA, data, BME280_LEN_P_T_H_DATA, dev);\par
00170     {\cf19 if} (rslt != BME280_OK)\par
00171     \{\par
00172         {\cf19 return} -2;\par
00173     \}\par
00174 \par
00175     uint32_t adc_P = ((uint32_t)data[0] << 12) | ((uint32_t)data[1] << 4) | ((uint32_t)data[2] >> 4);\par
00176     uint32_t adc_T = ((uint32_t)data[3] << 12) | ((uint32_t)data[4] << 4) | ((uint32_t)data[5] >> 4);\par
00177     uint32_t adc_H = ((uint32_t)data[6] << 8) | (uint32_t)data[7];\par
00178 \par
00179     {\cf20 /* Compensate using manufacturer's integer routines */}\par
00180     *t100 = BME280_compensate_T_int32((int32_t)adc_T, &dev->calib_data); {\cf20 /* 0.01 degC */}\par
00181     uint32_t p_q24_8 = BME280_compensate_P_int64((int32_t)adc_P, &dev->calib_data); {\cf20 /* Q24.8 */}\par
00182     *hum_x1024 = bme280_compensate_H_int32((int32_t)adc_H, &dev->calib_data); {\cf20 /* Q22.10 */}\par
00183 \par
00184     {\cf20 /* Convert pressure Q24.8 -> Pa (divide by 256) */}\par
00185     *press_pa = (uint32_t)((uint64_t)p_q24_8 / 256ULL);\par
00186 \par
00187     {\cf19 return} 0;\par
00188 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/main.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/main.c}
{\xe \v src/main.c}
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <avr/io.h>}\par
{\f2 #include <avr/interrupt.h>}\par
{\f2 #include "timer.h"}\par
{\f2 #include <uart.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "SPI_routines.h"}\par
{\f2 #include "sd_routines.h"}\par
{\f2 #include "FAT32.h"}\par
{\f2 #include "gpio.h"}\par
{\f2 #include "rtc.h"}\par
{\f2 #include <twi.h>}\par
{\f2 #include "bme280.h"}\par
{\f2 #include "SensirionI2CSgp41.h"}\par
{\f2 #include <math.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <util/delay.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UART_ON}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SD_write}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ACTIVITY_LED_PORT}\~ PORTC\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b L_ACT}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STATUS_LED_PORT}\~ PORTC\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b L_STATUS}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ERROR_LED_PORT}\~ PORTC\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b L_ERROR}\~ 0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bme_init_simple} (struct {\b bme280_dev} *dev, uint8_t *dev_addr_ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bme_read_once} (struct {\b bme280_dev} *dev, int32_t *t100, uint32_t *press_pa, uint32_t *hum_x1024)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sgp41_init_simple} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sgp41_measure_once} (int32_t *voc_index, int32_t *nox_index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b get_month_from_ascii_sum} (uint16_t sum)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_interrupt_source} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_time_uart} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ISR} (TIMER1_OVF_vect)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ISR} (INT0_vect)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ISR} (INT1_vect)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint8_t {\b printRTC} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint8_t {\b counterTim1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b SD_OK}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b FS_OK}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b BM_OK}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b SGP_OK}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b RTC_OK} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint8_t {\b measurement_flag} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ACTIVITY_LED_PORT\:main.c}
{\xe \v main.c\:ACTIVITY_LED_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ACTIVITY_LED_PORT\~ PORTC}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b main.c}.}\par
}
{\xe \v ERROR_LED_PORT\:main.c}
{\xe \v main.c\:ERROR_LED_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ERROR_LED_PORT\~ PORTC}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b main.c}.}\par
}
{\xe \v L_ACT\:main.c}
{\xe \v main.c\:L_ACT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define L_ACT\~ 2}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b main.c}.}\par
}
{\xe \v L_ERROR\:main.c}
{\xe \v main.c\:L_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define L_ERROR\~ 0}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b main.c}.}\par
}
{\xe \v L_STATUS\:main.c}
{\xe \v main.c\:L_STATUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define L_STATUS\~ 1}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b main.c}.}\par
}
{\xe \v SD_write\:main.c}
{\xe \v main.c\:SD_write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SD_write}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b main.c}.}\par
}
{\xe \v STATUS_LED_PORT\:main.c}
{\xe \v main.c\:STATUS_LED_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STATUS_LED_PORT\~ PORTC}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b main.c}.}\par
}
{\xe \v UART_ON\:main.c}
{\xe \v main.c\:UART_ON}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UART_ON}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b main.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v bme_init_simple\:main.c}
{\xe \v main.c\:bme_init_simple}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int bme_init_simple (struct {\b bme280_dev} * dev, uint8_t * dev_addr_ptr)}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b bme.c}.}\par
}
{\xe \v bme_read_once\:main.c}
{\xe \v main.c\:bme_read_once}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int bme_read_once (struct {\b bme280_dev} * dev, int32_t * t100, uint32_t * press_pa, uint32_t * hum_x1024)}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b bme.c}.}\par
}
{\xe \v get_month_from_ascii_sum\:main.c}
{\xe \v main.c\:get_month_from_ascii_sum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t get_month_from_ascii_sum (uint16_t sum)}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b main.c}.}\par
}
{\xe \v ISR\:main.c}
{\xe \v main.c\:ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ISR (INT0_vect )}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 499} of file {\b main.c}.}\par
}
{\xe \v ISR\:main.c}
{\xe \v main.c\:ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ISR (INT1_vect )}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 521} of file {\b main.c}.}\par
}
{\xe \v ISR\:main.c}
{\xe \v main.c\:ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ISR (TIMER1_OVF_vect )}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 469} of file {\b main.c}.}\par
}
{\xe \v main\:main.c}
{\xe \v main.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (void )}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b main.c}.}\par
}
{\xe \v set_interrupt_source\:main.c}
{\xe \v main.c\:set_interrupt_source}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void set_interrupt_source (void )}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b main.c}.}\par
}
{\xe \v set_time_uart\:main.c}
{\xe \v main.c\:set_time_uart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void set_time_uart (void )}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b main.c}.}\par
}
{\xe \v sgp41_init_simple\:main.c}
{\xe \v main.c\:sgp41_init_simple}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sgp41_init_simple (void )}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b sgp41.c}.}\par
}
{\xe \v sgp41_measure_once\:main.c}
{\xe \v main.c\:sgp41_measure_once}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sgp41_measure_once (int32_t * voc_index, int32_t * nox_index)}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b sgp41.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v BM_OK\:main.c}
{\xe \v main.c\:BM_OK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t BM_OK}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b main.c}.}\par
}
{\xe \v counterTim1\:main.c}
{\xe \v main.c\:counterTim1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint8_t counterTim1 = 0}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b main.c}.}\par
}
{\xe \v FS_OK\:main.c}
{\xe \v main.c\:FS_OK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t FS_OK}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b main.c}.}\par
}
{\xe \v measurement_flag\:main.c}
{\xe \v main.c\:measurement_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint8_t measurement_flag = 0}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b main.c}.}\par
}
{\xe \v printRTC\:main.c}
{\xe \v main.c\:printRTC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint8_t printRTC = 0}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b main.c}.}\par
}
{\xe \v RTC_OK\:main.c}
{\xe \v main.c\:RTC_OK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t RTC_OK = 0}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b main.c}.}\par
}
{\xe \v SD_OK\:main.c}
{\xe \v main.c\:SD_OK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SD_OK}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b main.c}.}\par
}
{\xe \v SGP_OK\:main.c}
{\xe \v main.c\:SGP_OK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SGP_OK}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b main.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main.c\par \pard\plain 
{\tc\tcl2 \v src/main.c}
{\xe \v src/main.c}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * Use USART unit and transmit data between ATmega328P and computer.}\par
00003 {\cf20  * (c) 2018-2025 Tomas Fryza, MIT license}\par
00004 {\cf20  *}\par
00005 {\cf20  * Developed using PlatformIO and Atmel AVR platform.}\par
00006 {\cf20  * Tested on Arduino Uno board and ATmega328P, 16 MHz.}\par
00007 {\cf20  */}\par
00008 \par
00009 {\cf20 // -- Includes ---------------------------------------------}\par
00010 {\cf21 #include <avr/io.h>}         {\cf20 // AVR device-specific IO definitions}\par
00011 {\cf21 #include <avr/interrupt.h>}  {\cf20 // Interrupts standard C library for AVR-GCC}\par
00012 {\cf21 #include "timer.h"}          {\cf20 // Timer library for AVR-GCC}\par
00013 {\cf21 #include <uart.h>}           {\cf20 // Peter Fleury's UART library}\par
00014 {\cf21 #include <stdlib.h>}         {\cf20 // C library. Needed for number conversions}\par
00015 {\cf21 #include "SPI_routines.h"}\par
00016 {\cf21 #include "sd_routines.h"}\par
00017 {\cf21 #include "FAT32.h"}\par
00018 {\cf21 #include "gpio.h"}\par
00019 {\cf21 #include "rtc.h"}\par
00020 {\cf21 #include <twi.h>}\par
00021 {\cf21 #include "bme280.h"}\par
00022 {\cf21 #include "SensirionI2CSgp41.h"}\par
00023 {\cf21 #include <math.h>}\par
00024 {\cf21 #include <string.h>}\par
00025 {\cf21 #include <util/delay.h>}\par
00026 {\cf21 #include <stdio.h>}\par
00027 \par
00028 {\cf21 #define UART_ON}\par
00029 {\cf21 #define SD_write}\par
00030 {\cf21 #define ACTIVITY_LED_PORT   PORTC}\par
00031 {\cf21 #define L_ACT    2}\par
00032 {\cf21 #define STATUS_LED_PORT     PORTC}\par
00033 {\cf21 #define L_STATUS      1}\par
00034 {\cf21 #define ERROR_LED_PORT      PORTC}\par
00035 {\cf21 #define L_ERROR       0}\par
00036 {\cf17 volatile} uint8_t printRTC = 0;\par
00037 {\cf17 volatile} uint8_t counterTim1 = 0;\par
00038 \par
00039 uint8_t SD_OK, FS_OK, BM_OK, SGP_OK, RTC_OK = 0;\par
00040 \par
00041 {\cf18 int} bme_init_simple({\cf17 struct} bme280_dev *dev, uint8_t *dev_addr_ptr);\par
00042 {\cf18 int} bme_read_once({\cf17 struct} bme280_dev *dev, int32_t *t100, uint32_t *press_pa, uint32_t *hum_x1024);\par
00043 {\cf18 int} sgp41_init_simple({\cf18 void});\par
00044 {\cf18 int} sgp41_measure_once(int32_t *voc_index, int32_t *nox_index);\par
00045 \par
00046 {\cf17 volatile} uint8_t measurement_flag = 0;\par
00047 uint8_t get_month_from_ascii_sum(uint16_t sum) \{\par
00048     {\cf19 switch}(sum) \{\par
00049         {\cf19 case} 268: {\cf19 return} 12; {\cf20 // Dec}\par
00050         {\cf19 case} 269: {\cf19 return} 2;  {\cf20 // Feb}\par
00051         {\cf19 case} 281: {\cf19 return} 1;  {\cf20 // Jan}\par
00052         {\cf19 case} 285: {\cf19 return} 8;  {\cf20 // Aug}\par
00053         {\cf19 case} 288: {\cf19 return} 3;  {\cf20 // Mar}\par
00054         {\cf19 case} 291: {\cf19 return} 4;  {\cf20 // Apr}\par
00055         {\cf19 case} 294: {\cf19 return} 10; {\cf20 // Oct}\par
00056         {\cf19 case} 295: {\cf19 return} 5;  {\cf20 // May}\par
00057         {\cf19 case} 296: {\cf19 return} 9;  {\cf20 // Sep}\par
00058         {\cf19 case} 299: {\cf19 return} 7;  {\cf20 // Jul}\par
00059         {\cf19 case} 301: {\cf19 return} 6;  {\cf20 // Jun}\par
00060         {\cf19 case} 307: {\cf19 return} 11; {\cf20 // Nov}\par
00061         {\cf19 default}: {\cf19 return} 0;   {\cf20 // Error}\par
00062     \}\par
00063 \}\par
00064 \par
00065 {\cf17 static} {\cf18 void} setup_ext_int({\cf18 void})\par
00066 \{\par
00067     {\cf20 // PD2 = INT0}\par
00068     gpio_mode_input_nopull(&DDRD, 2); {\cf20 // nastav PD2 ako vstup s pull-up (pouzi gpio.h)}\par
00069     EICRA &= ~((1 << ISC00)); {\cf20 // vycistit bity pre INT0/INT1 v EICRA}\par
00070     EICRA |= (1 << ISC01);\par
00071     {\cf20 // EICRA |= (1 << ISC01); // ISC01 = 1, ISC00 = 0 -> falling edge}\par
00072     EIMSK |= (1 << INT0); {\cf20 // povolit externy interrupt INT0}\par
00073 \par
00074     {\cf20 // PCICR |= (1 << PCIE0); // povolit pin change interrupt pre PCINT[7:0] (PORTB)}\par
00075     {\cf20 // PCMSK0 |= (1 << PCINT2); // povolit pin change interrupt}\par
00076 \}\par
00077 \par
00078 {\cf18 void} set_interrupt_source({\cf18 void})\par
00079 \{\par
00080     {\cf19 if} (RTC_OK == 0)\par
00081     \{\par
00082         {\cf20 // RTC is OK, use external interrupt on PD2}\par
00083         tim1_ovf_disable();\par
00084         rtc_write_reg(0x0e, 0x00); {\cf20 // Enable square-wave output}\par
00085         setup_ext_int();\par
00086     \}\par
00087     {\cf19 else}\par
00088     \{   \par
00089         {\cf20 // RTC not OK, use Timer1 interrupt}\par
00090         EIMSK &= ~(1 << INT0);  {\cf20 // Disable INT0}\par
00091         tim1_ovf_enable();\par
00092     \}\par
00093 \}\par
00094 {\cf18 void} set_time_uart({\cf18 void})\par
00095 \{\par
00096     uart_puts({\cf22 "Waiting for time data (YYYY,MM,DD,HH,MM,SS,DOW)...\\r\\n"});\par
00097     \par
00098     {\cf18 char} time_buffer[30];\par
00099     uint8_t idx = 0;\par
00100     \par
00101     {\cf19 while}(1) \{\par
00102         uint16_t data = uart_getc();\par
00103         {\cf19 if}(data & UART_NO_DATA) {\cf19 continue};\par
00104         \par
00105         {\cf18 char} ch = (char)(data & 0xFF);\par
00106         \par
00107         {\cf19 if}(ch == {\cf23 '\\r'} || ch == {\cf23 '\\n'}) {\cf19 break};\par
00108         \par
00109         time_buffer[idx++] = ch;\par
00110         {\cf19 if}(idx >= 29) {\cf19 break};\par
00111     \}\par
00112     time_buffer[idx] = {\cf23 '\\0'};\par
00113     \par
00114     {\cf20 // Parse: YYYY,MM,DD,HH,MM,SS,DOW}\par
00115     {\cf18 int} year, month, day, hour, minute, second, dow;\par
00116     {\cf19 if}(sscanf(time_buffer, {\cf22 "%d,%d,%d,%d,%d,%d,%d"}, \par
00117               &year, &month, &day, &hour, &minute, &second, &dow) == 7) \{\par
00118         rtc_set_time(hour, minute, second);\par
00119         rtc_set_date(dow, day, month, (year % 100));\par
00120         {\cf20 // rtc_set_day(dow);  // 1=Sunday ... 7=Saturday}\par
00121         \par
00122         {\cf17 const} {\cf18 char}* days[] = \{{\cf22 ""}, {\cf22 "Sun"}, {\cf22 "Mon"}, {\cf22 "Tue"}, {\cf22 "Wed"}, {\cf22 "Thu"}, {\cf22 "Fri"}, {\cf22 "Sat"}\};\par
00123         {\cf18 char} msg[60];\par
00124         sprintf(msg, {\cf22 "Time set: %04d-%02d-%02d (%s) %02d:%02d:%02d\\r\\n"}, \par
00125                 year, month, day, days[dow], hour, minute, second);\par
00126         uart_puts(msg);\par
00127     \} {\cf19 else} \{\par
00128         uart_puts({\cf22 "Error parsing time!\\r\\n"});\par
00129     \}\par
00130 \}\par
00131 {\cf18 int} main({\cf18 void})\par
00132 \{\par
00133     tim1_ovf_1sec();\par
00134     uint8_t hour, minute, second; \par
00135     uint8_t day, date, month, year;\par
00136     \par
00137     {\cf20 // unsigned char error;}\par
00138     {\cf20 // unsigned char fileName[] = "DATA.TXT";}\par
00139     \par
00140     {\cf20 // Initialize UART}\par
00141     uart_init(UART_BAUD_SELECT(115200, F_CPU));\par
00142     twi_init();\par
00143     {\cf20 // Configure SPI pins for ATmega328P}\par
00144     gpio_mode_output(&DDRB, PB3);  {\cf20 // MOSI}\par
00145     gpio_mode_output(&DDRB, PB5);  {\cf20 // SCK}\par
00146     gpio_mode_output(&DDRD, PD4);  {\cf20 // SS (Chip Select)}\par
00147     gpio_mode_input_nopull(&DDRB, PB4);  {\cf20 // MISO as input}\par
00148     \par
00149     {\cf20 // Set SS high initially (SD card deselected)}\par
00150     gpio_write_high(&PORTD, PIND4);\par
00151 \par
00152     gpio_mode_output(&DDRC, 0); {\cf20 //led red   ERROR}\par
00153     gpio_mode_output(&DDRC, 1); {\cf20 //led green STATUS}\par
00154     gpio_mode_output(&DDRC, 2); {\cf20 //led yellow ACT}\par
00155     gpio_write_high(&PORTC, 0);\par
00156     gpio_write_high(&PORTC, 1);\par
00157     gpio_write_high(&PORTC, 2);\par
00158     \par
00159     sei();\par
00160     \par
00161     gpio_write_low(&ACTIVITY_LED_PORT, L_ACT); {\cf20 // ACT ON}\par
00162     {\cf20 // gpio_write_low(&STATUS_LED_PORT, L_STATUS); // STATUS ON}\par
00163     gpio_write_low(&ERROR_LED_PORT, L_ERROR); {\cf20 // ERROR ON}\par
00164 \par
00165 {\cf21     #ifdef UART_ON}\par
00166         uart_puts_P({\cf22 "\\r\\n=== SD Card FAT32 Test ===\\r\\n"});\par
00167 {\cf21     #endif}\par
00168     {\cf20 // Initialize SPI}\par
00169 {\cf21     #ifdef SD_write}\par
00170     spi_init();\par
00171 {\cf21     #ifdef UART_ON}\par
00172     uart_puts_P({\cf22 "SPI initialized\\r\\n"});\par
00173 {\cf21     #endif}\par
00174     \par
00175     {\cf20 // Step 1: Initialize SD card}\par
00176 {\cf21     #ifdef UART_ON}\par
00177     uart_puts_P({\cf22 "Initializing SD card...\\r\\n"});\par
00178 {\cf21     #endif}\par
00179     {\cf20 // error = SD_init();}\par
00180     \par
00181     {\cf19 if}(SD_init())\par
00182     \{\par
00183 {\cf21         #ifdef UART_ON}\par
00184             uart_puts_P({\cf22 "SD Card Initialization Error!\\r\\n"});\par
00185             uart_puts_P({\cf22 "System continuing without SD card...\\r\\n"});\par
00186 {\cf21         #endif}\par
00187         SD_OK = 1;\par
00188         {\cf20 // while(1);  // Stop execution}\par
00189     \}\par
00190 {\cf21     #ifdef UART_ON}\par
00191         uart_puts_P({\cf22 "SD card initialized successfully!\\r\\n"});\par
00192         {\cf20 // Step 2: Initialize FAT32}\par
00193         uart_puts_P({\cf22 "Reading boot sector...\\r\\n"});\par
00194 {\cf21     #endif}\par
00195     \par
00196     {\cf19 if}(getBootSectorData())\par
00197     \{\par
00198 {\cf21         #ifdef UART_ON}\par
00199             uart_puts_P({\cf22 "FAT32 initialization failed!\\r\\n"});\par
00200             uart_puts_P({\cf22 "System continuing without SD card...\\r\\n"});\par
00201 {\cf21         #endif}\par
00202         FS_OK = 1;\par
00203         {\cf20 // while(1);  // Stop execution}\par
00204     \}\par
00205     {\cf19 else}\par
00206     \{\par
00207 {\cf21         #ifdef UART_ON}\par
00208             uart_puts_P({\cf22 "FAT32 initialized successfully!\\r\\n"});\par
00209 {\cf21         #endif}\par
00210         {\cf20 // uart_puts_P("\\r\\n");}\par
00211         FS_OK = 0;\par
00212     \}\par
00213 {\cf21     #endif}\par
00214      {\cf20 /* Initialize BME280 */}\par
00215     {\cf17 struct }bme280_dev bme_dev;\par
00216     uint8_t bme_addr = BME280_I2C_ADDR_PRIM;\par
00217     {\cf19 if} (bme_init_simple(&bme_dev, &bme_addr) != BME280_OK) \{\par
00218         \par
00219 {\cf21         #ifdef UART_ON}\par
00220             uart_puts_P({\cf22 "BME init failed\\r\\n"});\par
00221 {\cf21         #endif}\par
00222         BM_OK = 1;\par
00223         {\cf20 // while (1);}\par
00224     \}\par
00225     _delay_ms(100);\par
00226     {\cf20 /* Initialize SGP41 */}\par
00227     {\cf19 if} (sgp41_init_simple() != 0) \par
00228     \{\par
00229 {\cf21         #ifdef UART_ON}\par
00230             uart_puts_P({\cf22 "SGP41 init warning\\r\\n"});\par
00231 {\cf21         #endif}\par
00232         SGP_OK = 1;\par
00233         {\cf20 // while (1);}\par
00234     \}\par
00235     {\cf19 if} (twi_test_address(RTC_ADDRESS))\par
00236     \{\par
00237 {\cf21         #ifdef UART_ON}\par
00238             uart_puts_P({\cf22 "RTC not found!\\r\\n"});\par
00239             uart_puts_P({\cf22 "System using Compile time\\r\\n"});\par
00240 {\cf21         #endif}\par
00241         RTC_OK = 1;\par
00242         {\cf20 // Set compile time to local variables (RTC not available)}\par
00243         {\cf18 int} hour_comp, minute_comp, second_comp;\par
00244         sscanf(__TIME__, {\cf22 "%d:%d:%d"}, &hour_comp, &minute_comp, &second_comp);\par
00245         hour = (uint8_t)hour_comp;\par
00246         minute = (uint8_t)minute_comp;\par
00247         second = (uint8_t)second_comp;\par
00248 \par
00249         {\cf18 int} year_comp, month_comp, day_comp;\par
00250         {\cf18 char} month_str[4];\par
00251         sscanf(__DATE__, {\cf22 "%s %d %d"}, month_str, &day_comp, &year_comp);\par
00252         uint16_t month_sum = month_str[0] + month_str[1] + month_str[2];\par
00253         month_comp = get_month_from_ascii_sum(month_sum);\par
00254         \par
00255         date = (uint8_t)day_comp;\par
00256         month = (uint8_t)month_comp;\par
00257         year = (uint8_t)(year_comp % 100);\par
00258     \}\par
00259     {\cf19 else}\par
00260     \{\par
00261 {\cf21         #ifdef UART_ON}\par
00262             uart_puts_P({\cf22 "RTC found!\\r\\n"});\par
00263 {\cf21         #endif}\par
00264         {\cf20 // RTC_OK = 0;}\par
00265         rtc_write_reg(0x0e, 0x00); {\cf20 // Enable square-wave output}\par
00266     \}\par
00267     {\cf19 if} (RTC_OK & SGP_OK & SD_OK & FS_OK & BM_OK)\par
00268     \{\par
00269 {\cf21         #ifdef UART_ON}\par
00270             uart_puts_P({\cf22 "No sensors and SD card available, system halted!\\r\\n"});\par
00271 {\cf21         #endif}\par
00272         gpio_write_low(&ACTIVITY_LED_PORT, L_ACT); {\cf20 // ACT ON}\par
00273         {\cf19 while}(1);\par
00274     \}\par
00275     {\cf19 else} {\cf19 if} (RTC_OK | SGP_OK | BM_OK | SD_OK | FS_OK)\par
00276     \{\par
00277 {\cf21         #ifdef UART_ON}\par
00278             uart_puts_P({\cf22 "System initialized with warnings!\\r\\n"});\par
00279 {\cf21         #endif}\par
00280         gpio_write_low(&ERROR_LED_PORT, L_ERROR); {\cf20 // ERROR ON}\par
00281     \}\par
00282     \par
00283     {\cf19 else}\par
00284     \{\par
00285 {\cf21         #ifdef UART_ON}\par
00286             uart_puts_P({\cf22 "System initialized successfully!\\r\\n"});\par
00287 {\cf21         #endif}\par
00288         gpio_write_high(&ERROR_LED_PORT, L_ERROR); {\cf20 // ERROR OFF}\par
00289         gpio_write_high(&STATUS_LED_PORT, L_ACT); {\cf20 // ACT OFF}\par
00290         gpio_write_low(&STATUS_LED_PORT, L_STATUS); {\cf20 // STATUS ON}\par
00291     \}\par
00292 \par
00293     \par
00294     {\cf20 // sprintf(buffer, "Date: %02d/%02d/%04d\\r\\n", day, month, year);}\par
00295     {\cf20 // uart_puts(buffer);}\par
00296     {\cf20 // sprintf(buffer, "Time COMPILE: %02d:%02d:%02d\\r\\n", hour, minute, second);}\par
00297     {\cf20 // uart_puts(buffer);}\par
00298     {\cf20 // rtc_get_time(&hour, &minute, &second);}\par
00299     {\cf20 // sprintf(buffer, "Time RTC: %02d:%02d:%02d\\r\\n", hour, minute, second);}\par
00300     {\cf20 // uart_puts(buffer);}\par
00301     {\cf20 // _delay_ms(100);}\par
00302     {\cf20 // int hour_comp, minute_comp, second_comp;}\par
00303     {\cf20 // sscanf(__TIME__, "%d:%d:%d", &hour_comp, &minute_comp, &second_comp);}\par
00304     {\cf20 // rtc_set_time((uint8_t)hour_comp, (uint8_t)minute_comp, (uint8_t)second_comp); // Set time to compile time}\par
00305     {\cf20 // rtc_set_date(7, 29, 11, 25);}\par
00306     set_interrupt_source();\par
00307     {\cf18 char} buffer[50];\par
00308     {\cf19 while} (1)\par
00309     \{   \par
00310 {\cf21         #ifdef UART_ON}\par
00311         {\cf19 if}(printRTC == 1)\par
00312         \{\par
00313             printRTC = 0;\par
00314             {\cf19 if} (!(twi_test_address(RTC_ADDRESS)))\par
00315             \{\par
00316                 rtc_get_time(&hour, &minute, &second);\par
00317                 sprintf(buffer, {\cf22 "Time RTC: %02d:%02d:%02d\\r\\n"}, hour, minute, second);\par
00318                 uart_puts(buffer);\par
00319                 rtc_get_date(&date, &month, &year);\par
00320                 sprintf(buffer, {\cf22 "Date RTC: %02d/%02d/20%02d\\r\\n"}, date, month, year);\par
00321                 uart_puts(buffer);\par
00322                 {\cf20 // gpio_write_high(&ERROR_LED_PORT, L_ERROR); // ERROR OFF}\par
00323                 RTC_OK = 0;\par
00324             \}\par
00325             {\cf19 else}\par
00326             \{\par
00327                 {\cf20 // #ifdef UART_ON}\par
00328                 uart_puts_P({\cf22 "RTC not found, using Compile time\\r\\n"});\par
00329                 {\cf20 // #endif}\par
00330                 gpio_write_low(&ERROR_LED_PORT, L_ERROR); {\cf20 // ERROR ON}\par
00331             \}\par
00332             \par
00333             \par
00334             \par
00335         \}\par
00336 {\cf21         #endif}\par
00337 \par
00338         {\cf20 // if(RTC_OK | SGP_OK | BM_OK | SD_OK | FS_OK)}\par
00339         {\cf20 // \{}\par
00340         {\cf20 //     gpio_write_low(&ERROR_LED_PORT, L_ERROR); // ERROR ON}\par
00341         {\cf20 // \}}\par
00342         {\cf20 // else}\par
00343         {\cf20 // \{}\par
00344         {\cf20 //     gpio_write_high(&ERROR_LED_PORT, L_ERROR); // ERROR OFF}\par
00345         {\cf20 // \}}\par
00346 \par
00347         {\cf19 if} (measurement_flag)\par
00348         \{\par
00349             measurement_flag = 0;\par
00350             {\cf20 // uart_puts_P("Starting measurement...\\r\\n");}\par
00351             \par
00352 \par
00353             {\cf20 /* Read sensors */}\par
00354             {\cf18 char} sdString[100];\par
00355             memset(sdString, 0, {\cf17 sizeof}(sdString));  {\cf20 // Vynulujte na za\'C4\'8Diatku}\par
00356             \par
00357             int32_t t100 = 0;\par
00358             uint32_t press_pa = 0;\par
00359             uint32_t hum_x1024 = 0;\par
00360             \par
00361             {\cf19 if}(twi_test_address(RTC_ADDRESS))\par
00362             \{\par
00363                 RTC_OK = 1;\par
00364                 set_interrupt_source();\par
00365             \}\par
00366             {\cf19 else}\par
00367             \{\par
00368                 RTC_OK = 0;\par
00369                 rtc_get_time(&hour, &minute, &second);\par
00370                 rtc_get_date(&date, &month, &year);\par
00371                 set_interrupt_source();\par
00372             \}\par
00373             \par
00374             snprintf(sdString, {\cf17 sizeof}(sdString), {\cf22 "%02d:%02d:%02d,%02d/%02d/20%02d,"},\par
00375                      hour, minute, second, date, month, year);\par
00376             \par
00377             {\cf19 if} (bme_read_once(&bme_dev, &t100, &press_pa, &hum_x1024) == 0) \{\par
00378                 int32_t temp_int = t100 / 100;\par
00379                 int32_t temp_frac = (t100 >= 0) ? (t100 % 100) : ((-t100) % 100);\par
00380                 \par
00381                 uint32_t press_hpa_int = press_pa / 100;\par
00382                 uint32_t press_hpa_frac = press_pa % 100;\par
00383                 \par
00384                 uint32_t hum_percent_x100 = (hum_x1024 * 100 + 512) / 1024;\par
00385                 uint32_t hum_int = hum_percent_x100 / 100;\par
00386                 uint32_t hum_frac = hum_percent_x100 % 100;\par
00387                 \par
00388                 {\cf18 double} P = (double)press_pa;\par
00389                 {\cf18 double} alt = 44330.0 * (1.0 - pow(P / 101325.0, 0.19029495718363465));\par
00390                 int32_t alt_int = (int32_t)alt;\par
00391                 int32_t alt_frac = (int32_t)(fabs(alt - ({\cf18 double})alt_int) * 100.0 + 0.5);\par
00392                 \par
00393                 {\cf18 char} temp_buf[64];\par
00394                 snprintf(temp_buf, {\cf17 sizeof}(temp_buf), {\cf22 "%02ld.%02ld,%03lu.%02lu,%02lu.%02lu,%03ld.%02ld,"},\par
00395                          ({\cf18 long})temp_int, ({\cf18 long})temp_frac,\par
00396                          ({\cf18 unsigned} {\cf18 long})press_hpa_int, ({\cf18 unsigned} {\cf18 long})press_hpa_frac,\par
00397                          ({\cf18 unsigned} {\cf18 long})hum_int, ({\cf18 unsigned} {\cf18 long})hum_frac,\par
00398                          ({\cf18 long})alt_int, ({\cf18 long})alt_frac);\par
00399                 strncat(sdString, temp_buf, {\cf17 sizeof}(sdString) - strlen(sdString) - 1);\par
00400                 BM_OK = 0;\par
00401             \} {\cf19 else} \{\par
00402                 gpio_write_low(&ERROR_LED_PORT, L_ERROR); {\cf20 // ERROR ON}\par
00403                 strncat(sdString, {\cf22 "ERR,ERR,ERR,ERR,"}, {\cf17 sizeof}(sdString) - strlen(sdString) - 1);\par
00404                 BM_OK = 1;\par
00405             \}\par
00406             \par
00407             {\cf20 /* Read SGP41 */}\par
00408             int32_t voc_idx = 0;\par
00409             int32_t nox_idx = 0;\par
00410             {\cf19 if} (sgp41_measure_once(&voc_idx, &nox_idx) == 0) \{\par
00411                 {\cf18 char} temp_buf[32];\par
00412                 snprintf(temp_buf, {\cf17 sizeof}(temp_buf), {\cf22 "%ld,%ld\\n"}, ({\cf18 long})voc_idx, ({\cf18 long})nox_idx);\par
00413                 strncat(sdString, temp_buf, {\cf17 sizeof}(sdString) - strlen(sdString) - 1);\par
00414                 SGP_OK = 0;\par
00415             \} {\cf19 else} \{\par
00416                 strncat(sdString, {\cf22 "ERR,ERR\\n"}, {\cf17 sizeof}(sdString) - strlen(sdString) - 1);\par
00417                 SGP_OK = 1;\par
00418             \}\par
00419             \par
00420 {\cf21             #ifdef UART_ON}\par
00421             {\cf20 // uart_puts(sdString);}\par
00422 {\cf21             #endif}\par
00423             uint8_t write_error = 0;\par
00424             {\cf20 /* Write to SD card */}\par
00425             {\cf20 // uart_puts("Writing data to SD card...\\r\\n");}\par
00426             {\cf20 // _delay_ms(100); // Small delay before SD write}\par
00427             {\cf20 // uart_puts("FR");}\par
00428             {\cf19 if} (1)\par
00429             \{\par
00430                 {\cf20 // Vynulujte dataString PRED kop\'EDrovan\'EDm}\par
00431                 {\cf20 // uart_puts("in condition\\r\\n");}\par
00432                 {\cf20 // _delay_ms(50);}\par
00433                 {\cf20 // cli();}\par
00434                 memset(dataString, 0, MAX_STRING_SIZE);\par
00435                 \par
00436                 {\cf20 // Skop\'EDrujte sdString do dataString}\par
00437                 strncpy(({\cf18 char}*)dataString, sdString, MAX_STRING_SIZE - 1);\par
00438                 {\cf20 // dataString[MAX_STRING_SIZE - 1] = '\\0';}\par
00439                 \par
00440                 {\cf20 // Vytvorte nov\'FA k\'F3piu n\'E1zvu s\'FAboru}\par
00441                 {\cf18 unsigned} {\cf18 char} fileName[12];\par
00442                 strcpy(({\cf18 char}*)fileName, {\cf22 "data1.csv"});\par
00443                 \par
00444                 gpio_write_low(&ACTIVITY_LED_PORT, L_ACT);\par
00445 {\cf21                 #ifdef SD_write}\par
00446                 write_error = writeFile(fileName);\par
00447 {\cf21                 #endif}\par
00448                 {\cf20 // #ifndef SD_write}\par
00449                 {\cf20 // write_error = 0;}\par
00450                 {\cf20 // #endif}\par
00451                  {\cf19 if} (write_error) \{\par
00452                     uart_puts_P({\cf22 "SD write error!\\r\\n"});\par
00453                     gpio_write_low(&ERROR_LED_PORT, L_ERROR);\par
00454                 \} {\cf19 else} \{\par
00455                     uart_puts_P({\cf22 "Data saved.\\r\\n"});\par
00456                 \}\par
00457                 gpio_write_high(&ACTIVITY_LED_PORT, L_ACT);\par
00458                 \par
00459             \}\par
00460             \par
00461             {\cf20 // Re-enable INT0}\par
00462             \par
00463         \}\par
00464         \par
00465     \}\par
00466     {\cf19 return} 0;\par
00467 \}\par
00468 \par
00469 ISR(TIMER1_OVF_vect)\par
00470 \{    \par
00471     {\cf20 // counterTim1++;}\par
00472     {\cf20 // if (counterTim1>=5)}\par
00473     {\cf20 // \{}\par
00474     {\cf20 //     measurement_flag = 1;}\par
00475     {\cf20 // \}}\par
00476     \par
00477 {\cf20 //     if(counterTim1 >= 10)  // Every 10 seconds}\par
00478 {\cf20 //     \{}\par
00479 {\cf20 //         counterTim1 = 0;}\par
00480 {\cf20 //         // printRTC = 1;}\par
00481 {\cf20 //     \}}\par
00482     {\cf20 // cli();}\par
00483     {\cf20 // Check if PC2 (PCINT10) caused the interrupt}\par
00484     {\cf20 // if (PINC & (1 << PC2)) \{}\par
00485     {\cf20 //     // Rising edge detected}\par
00486     {\cf20 //     measurement_flag = 1;}\par
00487     {\cf20 // \}}\par
00488     counterTim1++;\par
00489     {\cf19 if} (counterTim1 >= 10) {\cf20 // Every 5 SQW pulses (5 seconds)}\par
00490     \{\par
00491         counterTim1 = 0;    \par
00492         measurement_flag = 1;\par
00493         {\cf20 // uart_puts_P("SQW Interrupt Triggered\\r\\n");}\par
00494         {\cf20 // gpio_toggle(&ACTIVITY_LED_PORT, L_ERROR);}\par
00495     \}\par
00496     {\cf20 // sei();}\par
00497     {\cf20 // uart_puts_P("Timer1 Interrupt Triggered\\r\\n");}\par
00498 \}\par
00499 ISR(INT0_vect)\par
00500 \{\par
00501     {\cf20 // cli();}\par
00502     {\cf20 // Check if PC2 (PCINT10) caused the interrupt}\par
00503     {\cf20 // if (PINC & (1 << PC2)) \{}\par
00504     {\cf20 //     // Rising edge detected}\par
00505     {\cf20 //     measurement_flag = 1;}\par
00506     {\cf20 // \}}\par
00507     gpio_toggle(&ACTIVITY_LED_PORT, L_ERROR);\par
00508     counterTim1++;\par
00509     {\cf19 if} (counterTim1 >= 10) {\cf20 // Every 5 SQW pulses (5 seconds)}\par
00510     \{\par
00511         counterTim1 = 0;    \par
00512         measurement_flag = 1;\par
00513         {\cf20 // printRTC = 1;}\par
00514         {\cf20 // uart_puts_P("SQW Interrupt Triggered\\r\\n");}\par
00515         {\cf20 // gpio_toggle(&ACTIVITY_LED_PORT, L_ERROR);}\par
00516     \}\par
00517    \par
00518     {\cf20 // sei();}\par
00519     {\cf20 // uart_puts_P("SQW Interrupt Triggered\\r\\n");}\par
00520 \}\par
00521 ISR(INT1_vect)\par
00522 \{\par
00523     {\cf20 // uart_puts_P("INT1 (PD3) Triggered\\r\\n");}\par
00524 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/sgp41.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/sgp41.c}
{\xe \v src/sgp41.c}
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <util/delay.h>}\par
{\f2 #include "twi.h"}\par
{\f2 #include "uart.h"}\par
{\f2 #include "SensirionI2CSgp41.h"}\par
{\f2 #include <avr/interrupt.h>}\par
{\f2 #include "timer.h"}\par
{\f2 #include "sensirion_gas_index_algorithm.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sgp41_init_simple} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sgp41_measure_once} (int32_t *voc_index, int32_t *nox_index)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sgp41_init_simple\:sgp41.c}
{\xe \v sgp41.c\:sgp41_init_simple}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sgp41_init_simple (void )}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b sgp41.c}.}\par
}
{\xe \v sgp41_measure_once\:sgp41.c}
{\xe \v sgp41.c\:sgp41_measure_once}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sgp41_measure_once (int32_t * voc_index, int32_t * nox_index)}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b sgp41.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sgp41.c\par \pard\plain 
{\tc\tcl2 \v src/sgp41.c}
{\xe \v src/sgp41.c}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * I2C-Generator: 0.3.0}\par
00003 {\cf20  * Yaml Version: 0.1.0}\par
00004 {\cf20  * Template Version: 0.7.0-62-g3d691f9}\par
00005 {\cf20  */}\par
00006 {\cf20 /*}\par
00007 {\cf20  * Copyright (c) 2021, Sensirion AG}\par
00008 {\cf20  * All rights reserved.}\par
00009 {\cf20  *}\par
00010 {\cf20  * Redistribution and use in source and binary forms, with or without}\par
00011 {\cf20  * modification, are permitted provided that the following conditions are met:}\par
00012 {\cf20  *}\par
00013 {\cf20  * * Redistributions of source code must retain the above copyright notice, this}\par
00014 {\cf20  *   list of conditions and the following disclaimer.}\par
00015 {\cf20  *}\par
00016 {\cf20  * * Redistributions in binary form must reproduce the above copyright notice,}\par
00017 {\cf20  *   this list of conditions and the following disclaimer in the documentation}\par
00018 {\cf20  *   and/or other materials provided with the distribution.}\par
00019 {\cf20  *}\par
00020 {\cf20  * * Neither the name of Sensirion AG nor the names of its}\par
00021 {\cf20  *   contributors may be used to endorse or promote products derived from}\par
00022 {\cf20  *   this software without specific prior written permission.}\par
00023 {\cf20  *}\par
00024 {\cf20  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}\par
00025 {\cf20  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}\par
00026 {\cf20  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}\par
00027 {\cf20  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE}\par
00028 {\cf20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}\par
00029 {\cf20  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}\par
00030 {\cf20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}\par
00031 {\cf20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}\par
00032 {\cf20  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}\par
00033 {\cf20  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}\par
00034 {\cf20  * POSSIBILITY OF SUCH DAMAGE.}\par
00035 {\cf20  */}\par
00036 \par
00037 {\cf20 // Use project's TWI and UART libraries (no Arduino)}\par
00038 {\cf21 #include <stdint.h>}\par
00039 {\cf21 #include <stdio.h>}\par
00040 {\cf21 #include <util/delay.h>}\par
00041 {\cf21 #include "twi.h"}\par
00042 {\cf21 #include "uart.h"}\par
00043 {\cf21 #include "SensirionI2CSgp41.h"}\par
00044 {\cf21 #include <avr/interrupt.h>}\par
00045 {\cf21 #include "timer.h"}\par
00046 {\cf21 #include "sensirion_gas_index_algorithm.h"}\par
00047 \par
00048 {\cf20 /* Refactored SGP41 wrapper: provide init + single-measure interface so main.c}\par
00049 {\cf20  * can control timing and UART output. The module keeps internal state for the}\par
00050 {\cf20  * gas index algorithms between measurements.}\par
00051 {\cf20  */}\par
00052 \par
00053 {\cf20 // Time in seconds needed for NOx conditioning (do not exceed 10s)}\par
00054 {\cf17 static} uint16_t conditioning_s = 10;\par
00055 \par
00056 {\cf17 static} GasIndexAlgorithmParams voc_params;\par
00057 {\cf17 static} GasIndexAlgorithmParams nox_params;\par
00058 {\cf17 static} {\cf18 int} initialized = 0;\par
00059 \par
00060 {\cf20 /* Initialize SGP41 algorithm state and perform optional self-test.}\par
00061 {\cf20  * Caller must call `twi_init()` before this function.}\par
00062 {\cf20  * Returns 0 on success, non-zero on error.}\par
00063 {\cf20  */}\par
00064 {\cf18 int} sgp41_init_simple({\cf18 void})\par
00065 \{\par
00066     {\cf19 if} (initialized) {\cf19 return} 0;\par
00067 \par
00068     {\cf20 /* Get serial number (optional, non-fatal) */}\par
00069     uint16_t serialNumber[3];\par
00070     (void)sgp41_getSerialNumber(serialNumber);\par
00071 \par
00072     {\cf20 /* Run self-test once (non-fatal) */}\par
00073     uint16_t testResult = 0;\par
00074     (void)sgp41_executeSelfTest(&testResult);\par
00075 \par
00076     {\cf20 /* Initialize gas index algorithms for VOC and NOx */}\par
00077     GasIndexAlgorithm_init(&voc_params, GasIndexAlgorithm_ALGORITHM_TYPE_VOC);\par
00078     GasIndexAlgorithm_init(&nox_params, GasIndexAlgorithm_ALGORITHM_TYPE_NOX);\par
00079 \par
00080     initialized = 1;\par
00081     {\cf19 return} 0;\par
00082 \}\par
00083 \par
00084 {\cf20 /* Perform one measurement and compute VOC/NOx indices. Caller provides pointers}\par
00085 {\cf20  * to store results. Returns 0 on success or non-zero on error.}\par
00086 {\cf20  */}\par
00087 {\cf18 int} sgp41_measure_once(int32_t *voc_index, int32_t *nox_index)\par
00088 \{\par
00089     {\cf19 if} (!initialized) {\cf19 return} -1;\par
00090 \par
00091     uint16_t defaultRh = 0x8000;\par
00092     uint16_t defaultT = 0x6666;\par
00093     uint16_t srawVoc = 0;\par
00094     uint16_t srawNox = 0;\par
00095 \par
00096     uint16_t err;\par
00097     {\cf19 if} (conditioning_s > 0) \{\par
00098         {\cf20 /* run conditioning command to keep sensor heater conditioned */}\par
00099         (void)sgp41_executeConditioning(defaultRh, defaultT, &srawVoc);\par
00100         {\cf20 /* always perform a measurement to obtain both VOC and NOx */}\par
00101         err = sgp41_measureRawSignals(defaultRh, defaultT, &srawVoc, &srawNox);\par
00102         conditioning_s--;\par
00103     \} {\cf19 else} \{\par
00104         err = sgp41_measureRawSignals(defaultRh, defaultT, &srawVoc, &srawNox);\par
00105     \}\par
00106 \par
00107     {\cf19 if} (err) {\cf19 return} ({\cf18 int})err;\par
00108 \par
00109     {\cf20 /* Process raw sraw values through gas index algorithms */}\par
00110     GasIndexAlgorithm_process(&voc_params, (int32_t)srawVoc, voc_index);\par
00111     GasIndexAlgorithm_process(&nox_params, (int32_t)srawNox, nox_index);\par
00112 \par
00113     {\cf19 return} 0;\par
00114 \}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
